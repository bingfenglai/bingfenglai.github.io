<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>赖柄沣的技术博客</title>
    <link>https://bingfenglai.github.io/</link>
    
    <atom:link href="https://bingfenglai.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>赖柄沣的技术博客</description>
    <pubDate>Mon, 17 Jan 2022 16:09:04 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Golang网络编程</title>
      <link>https://bingfenglai.github.io/2022/01/18/golang/18_golang%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
      <guid>https://bingfenglai.github.io/2022/01/18/golang/18_golang%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
      <pubDate>Mon, 17 Jan 2022 16:06:06 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/bingfenglai/art-demo/master/art-img/computer-gf34facf2a_1920.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/bingfenglai/art-demo/master/art-img/computer-gf34facf2a_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在前面的文章当中，我们学习了go当中的通道（channel）与协程（go-routine）及其应用。接下来，我们将学习go关于网络编程方面的内容。</p><h2 id="Golang网络编程初识"><a href="#Golang网络编程初识" class="headerlink" title="Golang网络编程初识"></a>Golang网络编程初识</h2><p>在正式的跟大家讲解网络编程之前，需要提前跟大家说明一下：网络编程是一个很庞大的领域，本文当中只是通过一些简单的demo带大家初步了解golang在网络编程方面的应用。</p><p>为了大家能够更好地理解本文，大家需要先了解互联网协议的相关知识点。这包括OSI七层模型，了解各层的作用、协议等。如果大家学习过其他的高级语言，例如Java、Python等，了解socket编程的相关知识点，那这再好不过。</p><h2 id="Golang-socket编程"><a href="#Golang-socket编程" class="headerlink" title="Golang socket编程"></a>Golang socket编程</h2><h3 id="socket是什么？"><a href="#socket是什么？" class="headerlink" title="socket是什么？"></a>socket是什么？</h3><p>socket是一种操作系统提供的进程间通信机制，中文翻译为“套接字”。它用于描述IP地址和端口，是一个通信链的句柄。</p><blockquote><p>socket最初被翻译为把socket译为“介质(字)”。不久，ARPANET的socket就被翻译为“套接字”，其理由是：</p><p>由于每个主机系统都有各自命名进程的方法，而且常常是不兼容的，因此，要在全网范围内硬把进程名字统一起来是不现实的。所以，每个计算机网络中都要引入一种起介质作用的、全网一致的标准名字空间。这种标准名字，在ARPA网中称作套接字，而在很多其他计算机网中称作信口。更确切地说，进程之间的连接是通过套接字或信口构成的。</p></blockquote><p>在操作系统当中，通常会为应用程序提供一组API，称之为套接字接口。应用程序可以通过套接字接口，向网络发出请求或者应答网络请求，进行数据交换。</p><p>一个套接字对（socket pairs）由本地的IP地址和端口、远程的IP地址和端口以及建立连接所使用的协议（protocol）组成。</p><h3 id="对于socket的理解"><a href="#对于socket的理解" class="headerlink" title="对于socket的理解"></a>对于socket的理解</h3><p>socket位于应用层与TCP/IP协议族通信的中间，相当于设计模式当中的门面。对于程序员来说，不需要关系通信协议的具体实现，只需要调用socket提供的相关API，就可以进行网络数据交换。</p><h2 id="Golang的TCP-client-server-Demo"><a href="#Golang的TCP-client-server-Demo" class="headerlink" title="Golang的TCP client-server Demo"></a>Golang的TCP client-server Demo</h2><p>服务端程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;go_code/web/tcp/constants&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">listen, err := net.Listen(constants.Protocol, constants.Addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;监听端口出错&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;服务器启动完成 &quot;</span> + time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">accept, err := listen.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;出现错误:\n&quot;</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> doServerStuff(accept)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doServerStuff</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;关闭连接&quot;</span>)</span><br><span class="line">conn.Close()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">read, err := conn.Read(buf)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;EOF&quot;</span> == err.Error() &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;数据读取结束&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;出现错误:&quot;</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;接收到数据：&quot;</span>)</span><br><span class="line"><span class="built_in">println</span>(<span class="keyword">string</span>(buf[:read]))</span><br><span class="line">_, err = conn.Write([]<span class="keyword">byte</span>(<span class="string">&quot; hello client &quot;</span> + conn.RemoteAddr().String()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;出现错误\n&quot;</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在服务端程序当中，服务启动后，使用for无限循环接收客户端的请求并启动协程处理来自客户端的请求。</p><p>客户端程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;go_code/web/tcp/constants&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立连接</span></span><br><span class="line"></span><br><span class="line">conn, err := net.Dial(constants.Protocol, constants.Addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;建立连接失败&quot;</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;建立连接成功&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">conn.Write([]<span class="keyword">byte</span>(<span class="string">&quot;hello server &quot;</span> + time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)))</span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">read, err := conn.Read(buf)</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;收到服务器发送来的消息&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;读取数据失败 &quot;</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="keyword">string</span>(buf[:read]))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端启动后，与服务器建立连接，并向服务器发送数据。</p><p>服务器程序输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">服务器启动完成 <span class="number">2022</span><span class="number">-01</span><span class="number">-16</span> <span class="number">18</span>:<span class="number">37</span>:<span class="number">53</span></span><br><span class="line">接收到数据：</span><br><span class="line">hello server <span class="number">2022</span><span class="number">-01</span><span class="number">-16</span> <span class="number">18</span>:<span class="number">38</span>:<span class="number">01</span></span><br><span class="line">数据读取结束</span><br><span class="line">关闭连接</span><br></pre></td></tr></table></figure><p>客户端程序输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">建立连接成功</span><br><span class="line">收到服务器发送来的消息</span><br><span class="line"> hello client <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3471</span></span><br><span class="line"></span><br><span class="line">进程完成，并显示退出代码 <span class="number">0</span></span><br></pre></td></tr></table></figure><p>以上就是Go 关于tcp编程的一个简单的demo，其中主要应用到了net包和协程的相关知识点。</p><h2 id="http-服务器demo"><a href="#http-服务器demo" class="headerlink" title="http 服务器demo"></a>http 服务器demo</h2><p>接下来，我们通过一个小demo来学习Go当中简单的http服务编程的相关知识点。</p><p><code>constants.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> constants</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">ADDR         = <span class="string">&quot;localhost:9527&quot;</span></span><br><span class="line">CONTEXT_PATH = <span class="string">&quot;/&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>http_server.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;go_code/web/http/constants&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handlerMap = <span class="keyword">map</span>[<span class="keyword">string</span>]http.HandlerFunc&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">handlerMap[<span class="string">&quot;/sayHello&quot;</span>] = SayHelloHandler</span><br><span class="line">handlerMap[<span class="string">&quot;/goodbye&quot;</span>] = SayGoodbyeHandler</span><br><span class="line"></span><br><span class="line">http.HandleFunc(constants.CONTEXT_PATH, BaseHandler)</span><br><span class="line"></span><br><span class="line">err := http.ListenAndServe(constants.ADDR, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;启动http服务器错误\n&quot;</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BaseHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">uri := strings.Split(r.RequestURI, <span class="string">&quot;?&quot;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;请求URI &quot;</span>, uri)</span><br><span class="line"><span class="comment">//println(i)</span></span><br><span class="line"></span><br><span class="line">handlerFunc, ok := handlerMap[uri]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">handlerFunc(w, r)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">w.WriteHeader(http.StatusNotFound)</span><br><span class="line">_, _ = w.Write([]<span class="keyword">byte</span>(<span class="string">&quot;请求资源不存在&quot;</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHelloHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取get请求参数</span></span><br><span class="line">name := r.URL.Query().Get(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> name != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">_, _ = w.Write([]<span class="keyword">byte</span>(<span class="string">&quot;hello ! &quot;</span> + name))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">_, _ = w.Write([]<span class="keyword">byte</span>(<span class="string">&quot;缺少参数name&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayGoodbyeHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">name := r.FormValue(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> name != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">_, _ = w.Write([]<span class="keyword">byte</span>(<span class="string">&quot;goodbye ! &quot;</span> + name))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">_, _ = w.Write([]<span class="keyword">byte</span>(<span class="string">&quot;缺少参数name&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子当中，<code>http.ListenAndServe</code>函数主要用来监听并启动http服务，如果启动出现异常，则会返回相应的error。<code>http.HandleFunc</code>函数用于注册对应请求路径的处理函数，在这个例子当中，我们对<code>/</code>路径注册了对应的处理函数<code>BaseHandler</code>,它实现于http包中的<code>Handler</code>接口。在BaseHandler接口当中我们再对请求进一步的转发到具体的处理器函数。</p><p>而具体的处理函数也很简单，分别是一个sayHello和sayGoodbye的模拟业务处理的函数。当程序启动后，使用<code>curl</code>进行测试</p><p>程序输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9527/sayHello?name=韩立</span><br><span class="line">hello ! 韩立</span><br><span class="line">curl http://localhost:9527/sayHello</span><br><span class="line">缺少参数name</span><br><span class="line">curl http://localhost:9527/sayHell</span><br><span class="line">请求资源不存在</span><br><span class="line">curl http://localhost:9527/goodbye?name=陈师姐</span><br><span class="line">goodbye ! 陈师姐</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>在这篇文章当中，我们主要通过两个例子初步地认识了go语言网络编程的相关知识点。本文当中涉及到的例子可以<a href="https://github.com/bingfenglai/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p>]]></content:encoded>
      
      
      
      <category domain="https://bingfenglai.github.io/tags/golang/">golang</category>
      
      
      <comments>https://bingfenglai.github.io/2022/01/18/golang/18_golang%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>golang中的协程与通道（三）</title>
      <link>https://bingfenglai.github.io/2022/01/12/golang/17_golang%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93%EF%BC%88%E4%B8%89%EF%BC%89/</link>
      <guid>https://bingfenglai.github.io/2022/01/12/golang/17_golang%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93%EF%BC%88%E4%B8%89%EF%BC%89/</guid>
      <pubDate>Wed, 12 Jan 2022 15:48:19 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/bingfenglai/art-demo/master/art-img/british-shorthair-g32cbd97b6_1920.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在前一篇文章《&lt;a href=&quot;https://bingfenglai.github.io/2021/12/15/golang/16_golang%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93%EF%BC%88%E4%BA%8C%EF%BC%89/&quot;&gt;golang中的协程与通道（二） &lt;/a&gt;》当中，我们初步学习了通道的相关内容，并结合协程进行了简单的应用，接下来，我们将通过具体的练习来进一步学习该知识点。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/bingfenglai/art-demo/master/art-img/british-shorthair-g32cbd97b6_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在前一篇文章《<a href="https://bingfenglai.github.io/2021/12/15/golang/16_golang%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93%EF%BC%88%E4%BA%8C%EF%BC%89/">golang中的协程与通道（二） </a>》当中，我们初步学习了通道的相关内容，并结合协程进行了简单的应用，接下来，我们将通过具体的练习来进一步学习该知识点。</p><span id="more"></span><h2 id="使用-select-切换协程"><a href="#使用-select-切换协程" class="headerlink" title="使用 select 切换协程"></a>使用 select 切换协程</h2><p>从不同的并发执行的协程中获取值可以通过关键字<code>select</code>来完成，它和<code>switch</code>控制语句非常相似，也被称作通信开关。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-ch1:</span><br><span class="line">fmt.Println(i)</span><br><span class="line"><span class="keyword">case</span> j := &lt;-ch2:</span><br><span class="line">fmt.Println(j)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot; default&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<code>select</code> 使用的说明：</p><ol><li><p><code>default</code> 语句是可选的；</p></li><li><p>在任何一个 case 中执行 <code>break</code> 或者 <code>return</code>，select 就结束了；</p></li><li><p><code>select</code> 做的就是：选择处理列出的多个通信情况中的一个：</p><p>3.1 如果通道都属于阻塞状态，则会等待直到其中一个可以处理（没有default的情况下）</p><p>3.2 如果多个可以处理，则随机选择其中一个</p><p>3.3 如果没有通道操作可以处理了并且写了<code>default</code> 语句，则会执行<code>default</code>语句：<code>default</code> 永远是可运行的。</p></li></ol><h2 id="惰性生成器的实现"><a href="#惰性生成器的实现" class="headerlink" title="惰性生成器的实现"></a>惰性生成器的实现</h2><p>生成器是指被调用时返回下一个序列中下一个值的函数。一般用来生成订单号等。因为生成器每次返回的是序列中下一个值而非整个序列，这种特性也被称之为<strong>惰性求值</strong>。</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> interval</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interval <span class="keyword">struct</span> &#123;</span><br><span class="line">maxValue    <span class="keyword">int</span></span><br><span class="line">currentVale <span class="keyword">int</span></span><br><span class="line">step        <span class="keyword">int</span></span><br><span class="line">lock        sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewInterval</span><span class="params">(maxValue, step <span class="keyword">int</span>)</span> *<span class="title">Interval</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;Interval&#123;</span><br><span class="line">maxValue:    maxValue,</span><br><span class="line">currentVale: <span class="number">1</span>,</span><br><span class="line">step:        step,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取序列的下一个区间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver *Interval)</span> <span class="title">GetNextInterval</span><span class="params">()</span> <span class="params">(min, max <span class="keyword">int</span>,err error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">receiver.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> receiver.lock.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> receiver.currentVale &gt;= receiver.maxValue &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, errors.New(<span class="string">&quot;序列号已耗尽&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">min = receiver.currentVale</span><br><span class="line">max = receiver.currentVale + receiver.step</span><br><span class="line"><span class="keyword">if</span> max &gt; receiver.maxValue &#123;</span><br><span class="line">max = receiver.maxValue</span><br><span class="line">&#125;</span><br><span class="line">receiver.currentVale = max + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> min, max,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;go_code/channel_demo/gen/interval&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个chan int 类型的通道</span></span><br><span class="line"><span class="keyword">var</span> resume <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间实例</span></span><br><span class="line"><span class="keyword">var</span> myInterval = interval.NewInterval(<span class="number">99999</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> count <span class="keyword">struct</span> &#123;</span><br><span class="line">i <span class="keyword">int</span></span><br><span class="line">mu sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化通道</span></span><br><span class="line">resume = intergers()</span><br><span class="line"></span><br><span class="line">count := count&#123;</span><br><span class="line">i:  <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不断地获取下一个序列值并格式化打印</span></span><br><span class="line"><span class="comment">// 为了验证所有的协程获取的序列号不重复，每获取一个记录数count+1</span></span><br><span class="line"><span class="keyword">for</span> j :=<span class="number">10</span>;j&gt;<span class="number">0</span>;j-- &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(fmt.Sprintf(<span class="string">&quot;%05d&quot;</span>, generateInteger()))</span><br><span class="line">count.mu.Lock()</span><br><span class="line">count.i = count.i+<span class="number">1</span></span><br><span class="line">count.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">1e9</span>*<span class="number">3</span>)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;总共获取：&quot;</span>,count.i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从chan int 通道当作获取下一个值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateInteger</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &lt;-resume</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个chan int 类型的通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intergers</span><span class="params">()</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">yield := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">min, max, _ := myInterval.GetNextInterval()</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="comment">// 开启一个协程，不断地向通道当中写入下一个序列号（阻塞的）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> min &lt;= max &#123;</span><br><span class="line">yield &lt;- min</span><br><span class="line">min++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">min, max, err = myInterval.GetNextInterval()</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> yield</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子当中，Interval存储的是整个序列的信息，包括序列的最大值，步长，当前开始值。函数<code>GetNextInterval()</code> 获取下一个区间值。函数<code>generateInteger()</code>获取序列当中的下一个值。我们在main函数当中，使用协程和无限循环不断地获取序列值并打印，每获取一个<code>count</code>+1，最终打印获取到的总数。</p><p>程序输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总共获取： 99999</span><br></pre></td></tr></table></figure><h2 id="实现-Futures-模式"><a href="#实现-Futures-模式" class="headerlink" title="实现 Futures 模式"></a>实现 Futures 模式</h2><p>所谓的<strong>Futures</strong>指的是：在某些场景当中，我们使用某一个值之前需要先对其进行计算。在这种情况下，我们可以在另一个处理器上进行该值的计算，到使用时，该值就已经计算完毕。</p><p>Futures类似于生成器，不同的地方在于Futures需要返回一个值。</p><p>请看下面的例子：</p><p>在某一场景当中，我们的程序需要不断地接收图片并对其进行特征提取。那么，我们应当如何实现呢？</p><p>实现方式一：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">file := receiverImagesFile()</span><br><span class="line">resolve(file)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receiverImagesFile</span><span class="params">()</span>  <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;1.png&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resolve</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;对图片 &quot;</span>+s+<span class="string">&quot; 进行特征提取&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方式当中，接收文件跟对文件进行处理采用同步的方式进行，分为接收函数<code>receiverImagesFile()</code>和处理函数<code>resolve（）</code> 。在这个简单的模式当中，因为是同步的，当接收函数正在接收文件时（IO相对而言是缓慢的），处理函数可能会存在空闲状态，这样会导致资源的浪费。</p><p>那么，Futures模式是如何处理的呢？请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">resolve()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resolve</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">s := &lt;-receiverImageFile()</span><br><span class="line">time.Sleep(<span class="number">1e9</span> * <span class="number">0.3</span>)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;文件&quot;</span> + s + <span class="string">&quot;处理完毕&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receiverImageFile</span><span class="params">()</span> <span class="title">chan</span> <span class="title">string</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟接收文件过程</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;接收文件中...&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">1e9</span> * <span class="number">1</span>)</span><br><span class="line">ch &lt;- time.Now().Format(<span class="string">&quot;20060102150405&quot;</span>) + <span class="string">&quot;.png&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Futures当中，接收函数跟处理函数通过通道进行解耦。接收函数可以不断地接收新的图片文件，而处理函数不断地对图片进行运算。再给通道设置缓存后，两者之间可以（理想情况下）做到互不影响，使得资源利用率得到提升。并且，我们可以配置多数接收函数对应少数的处理函数，进而减少计算资源的等待时间。对于密集计算型任务，Futures模式可以使得API以异步的形式暴露出来，使得API调用方可以在等待结果的时间处理其他任务。</p><h2 id="协程与通道在CS模式中的应用"><a href="#协程与通道在CS模式中的应用" class="headerlink" title="协程与通道在CS模式中的应用"></a>协程与通道在CS模式中的应用</h2><p>客户端（client）可以是运行在任意设备上的任意程序，它会按需发送请求（rrequest）到服务器。服务器（server）接收到请求后开始对应的工作，并将结果（也称之为响应，response）返回给客户端。一般情况下，多个客户端对应少数的服务器。日常我们使用的浏览器，移动App等都属于客户端。</p><p>在Golang当中，请求的执行一般在协程当中进行。请求的响应将通过请求当中包含的通道将结果进行返回。而server程序将不断地从通道当中接收请求，并开启一个协程对其进行处理。</p><p>请看下面的demo:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求</span></span><br><span class="line"><span class="keyword">type</span> request <span class="keyword">struct</span> &#123;</span><br><span class="line">args   <span class="keyword">string</span></span><br><span class="line">replyc <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sayHello <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟调度具体的业务方法，并通过通道返回结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(do sayHello, req *request)</span></span> &#123;</span><br><span class="line">req.replyc &lt;- do(req.args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟服务器应用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">(do sayHello, service <span class="keyword">chan</span> *request, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">close</span>(quit)</span><br><span class="line"><span class="keyword">for</span>  &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span>(service) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">close</span>(service)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;程序退出&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> req := &lt;-service:</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;收到请求&quot;</span>, req.args)</span><br><span class="line"><span class="keyword">go</span> run(do, req)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> &lt;-quit:</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;收到退出指令&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器方法</span></span><br><span class="line"><span class="comment">// resp: 请求通道、退出信号通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startServer</span><span class="params">(do sayHello)</span> <span class="params">(seivice <span class="keyword">chan</span> *request, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">seivice = <span class="built_in">make</span>(<span class="keyword">chan</span> *request)</span><br><span class="line">quit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> server(do, seivice, quit)</span><br><span class="line"><span class="keyword">return</span> seivice, quit</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">4</span>)</span><br><span class="line">service, quit := startServer(<span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello! &quot;</span> + name</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> N = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reqs [N]request</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化N个请求实例，并对服务器发器请求</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">req := &amp;reqs[i]</span><br><span class="line">req.args = strconv.Itoa(i) + <span class="string">&quot; name&quot;</span></span><br><span class="line">req.replyc = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟接收响应结果</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := &lt;-req.replyc</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;接收响应：&quot;</span>,s)</span><br><span class="line"></span><br><span class="line">&#125;()</span><br><span class="line">service &lt;- req</span><br><span class="line"><span class="keyword">if</span> i == N<span class="number">-1</span> &#123;</span><br><span class="line">quit&lt;<span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">2</span> * <span class="number">1e9</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子当中，我们封装了请求<code>request</code> ，里面包含了请求参数和结果返回的通道信息。在服务器当中，每收到一个请求就开启一个协程对该请求进行处理（go协程是非常轻量的），并将结果发送到请求的响应通道当中。服务器通过<code>select</code>机制进行不同通道之间的切换。</p><h2 id="通道在限制并发当中的应用"><a href="#通道在限制并发当中的应用" class="headerlink" title="通道在限制并发当中的应用"></a>通道在限制并发当中的应用</h2><p>我们知道，在硬件资源不变的情况下，计算机处理的最大请求数是固定。当某些极限情况下，可能会出现大量的请求打到计算机上，这时，可能会出现请求过载，导致计算机宕机。因此，我们需要将请求最大值限制在计算机能够处理的范围之内，也就是<code>限流</code>。在<code>Golang</code>中使用带有缓冲的通道就很容易实现这一点，<strong>通道的缓冲大小就是同时处理请求的最大数量。</strong></p><p>我们将上面的例子当中的<code>service</code>通道修改一下，在初始化时指定缓冲大小</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动服务器方法</span></span><br><span class="line"><span class="comment">// resp: 请求通道、退出信号通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startServer</span><span class="params">(do sayHello)</span> <span class="params">(seivice <span class="keyword">chan</span> *request, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">seivice = <span class="built_in">make</span>(<span class="keyword">chan</span> *request,<span class="number">4</span>)</span><br><span class="line">quit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> server(do, seivice, quit)</span><br><span class="line"><span class="keyword">return</span> seivice, quit</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，我们再次运行一下demo,就可以看到此时服务器函数同时接收到请求就扩大到了4.</p><h2 id="并行计算的应用"><a href="#并行计算的应用" class="headerlink" title="并行计算的应用"></a>并行计算的应用</h2><p>现代计算机绝大多数都是多核心CPU。并行计算可以理解为：利用多个处理器协同求解同一问题的过程。接下来，我们通过一个demo了解Golang在并行计算上面的应用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数列求和函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(list []<span class="keyword">int</span>, ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, j := <span class="keyword">range</span> list &#123;</span><br><span class="line">i = i + j</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;分段结果:&quot;</span> + strconv.Itoa(i))</span><br><span class="line">ch &lt;- i</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参与运算的cpu数</span></span><br><span class="line"><span class="keyword">const</span> cpu_num = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">runtime.GOMAXPROCS(cpu_num)</span><br><span class="line"><span class="keyword">var</span> list = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">34</span>, <span class="number">52</span>, <span class="number">46</span>, <span class="number">87</span>, <span class="number">18</span>, <span class="number">91</span>, <span class="number">101</span>, <span class="number">161</span>, <span class="number">182</span>&#125;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 分为六等份</span></span><br><span class="line">num := <span class="built_in">cap</span>(list) / cpu_num</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;每份大小：&quot;</span> + strconv.Itoa(num))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cpu_num; i++ &#123;</span><br><span class="line">sub := list[i*num : i*num+num]</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> sum(sub, ch)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> total []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cpu_num; i++ &#123;</span><br><span class="line">sum := &lt;-ch</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;收到结果&quot;</span> + strconv.Itoa(sum))</span><br><span class="line">total = <span class="built_in">append</span>(total, sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;结果长度&quot;</span>, <span class="built_in">len</span>(total))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(total)<span class="number">-1</span>; i++ &#123;</span><br><span class="line"><span class="built_in">println</span>(total[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;==========&quot;</span>)</span><br><span class="line"><span class="keyword">go</span> sum(total, ch)</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(&lt;-ch)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">每份大小：<span class="number">2</span></span><br><span class="line">分段结果:<span class="number">23</span></span><br><span class="line">收到结果<span class="number">23</span></span><br><span class="line">分段结果:<span class="number">98</span></span><br><span class="line">收到结果<span class="number">98</span></span><br><span class="line">分段结果:<span class="number">343</span></span><br><span class="line">分段结果:<span class="number">192</span></span><br><span class="line">分段结果:<span class="number">65</span></span><br><span class="line">收到结果<span class="number">343</span></span><br><span class="line">收到结果<span class="number">192</span></span><br><span class="line">收到结果<span class="number">65</span></span><br><span class="line">分段结果:<span class="number">105</span></span><br><span class="line">收到结果<span class="number">105</span></span><br><span class="line">结果长度 <span class="number">6</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">98</span></span><br><span class="line"><span class="number">343</span></span><br><span class="line"><span class="number">192</span></span><br><span class="line"><span class="number">65</span></span><br><span class="line">==========</span><br><span class="line">分段结果:<span class="number">826</span></span><br><span class="line"><span class="number">826</span></span><br></pre></td></tr></table></figure><p>在这个例子当中，存在一个长度为N的数组，我们需要对数组内的元素（元素是无规律的）进行求和。我们将其分为n（n为N的公约数且n小于计算机CPU核心数）等份，并通过协程去同时计算n等分的分段和，最后进行再对分段和组成的数组（可以再次切分为m等分，依次类推）进行求和。</p><p>在这个例子当中，我们可以充分的利用资源进行协同求解，使得计算效率大大提升。</p><h2 id="通过通道来访问共享资源"><a href="#通过通道来访问共享资源" class="headerlink" title="通过通道来访问共享资源"></a>通过通道来访问共享资源</h2><p>在这之前，我们为了安全地访问共享资源，一般通过加锁来实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Info <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu sync.Mutex</span><br><span class="line">    <span class="comment">// ... other fields, e.g.: Str string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，对于通道内的元素，我们将其取出是具备顺序性的，因此，我们可不可利用此特性来实现对共享资源的访问呢？请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 共享资源</span></span><br><span class="line"><span class="keyword">type</span> Count <span class="keyword">struct</span> &#123;</span><br><span class="line">count <span class="keyword">int</span></span><br><span class="line">funCh <span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCount</span><span class="params">(i <span class="keyword">int</span>)</span> *<span class="title">Count</span></span> &#123;</span><br><span class="line"></span><br><span class="line">count := &amp;Count&#123;</span><br><span class="line"></span><br><span class="line">count: i,</span><br><span class="line">funCh: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span>),</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> count.backend()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后台协程方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver *Count)</span> <span class="title">backend</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">f := &lt;-receiver.funCh</span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问资源的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver *Count)</span> <span class="title">AddCount</span><span class="params">(count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">receiver.count = receiver.count + count</span><br><span class="line">&#125;</span><br><span class="line">receiver.funCh &lt;- f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">runtime.GOMAXPROCS(<span class="number">2</span>)</span><br><span class="line">count := NewCount(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">total := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(count *Count)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">500</span>; i++ &#123;</span><br><span class="line">count.AddCount(<span class="number">1</span>)</span><br><span class="line">total = total + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;(count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(count *Count)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">500</span>; i++ &#123;</span><br><span class="line">count.AddCount(<span class="number">-1</span>)</span><br><span class="line">total = total - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;(count)</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">1</span> * <span class="number">1e9</span>)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;通过通道访问的资源：&quot;</span>, count.count)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;直接访问的资源：&quot;</span>, total)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过通道访问的资源： <span class="number">0</span></span><br><span class="line">直接访问的资源： <span class="number">-2</span></span><br></pre></td></tr></table></figure><p>在这个例子当中，我们分别通过通道和直接访问的方式操作资源，最后打印结果。可以看到，通过通道去组织对资源的访问，可以起到对资源加锁的作用。当然，这仅仅是一个简化的demo，虽然不能直接用于实际开发，但是这种方式给我们提供了在实际场景中并发编程对于资源访问方面提供了思路。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>在这篇文章当中，我们通过几个小案例跟大家探讨了关于协程、通道的应用，使得我们可以更好地掌握这些知识点。</p><p>本文当中涉及到的例子可以<a href="https://github.com/bingfenglai/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p>]]></content:encoded>
      
      
      
      <category domain="https://bingfenglai.github.io/tags/golang/">golang</category>
      
      
      <comments>https://bingfenglai.github.io/2022/01/12/golang/17_golang%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93%EF%BC%88%E4%B8%89%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>golang中的协程与通道（二）</title>
      <link>https://bingfenglai.github.io/2021/12/15/golang/16_golang%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93%EF%BC%88%E4%BA%8C%EF%BC%89/</link>
      <guid>https://bingfenglai.github.io/2021/12/15/golang/16_golang%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93%EF%BC%88%E4%BA%8C%EF%BC%89/</guid>
      <pubDate>Tue, 14 Dec 2021 16:27:08 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/bingfenglai/art-demo/master/art-img/woman-ga2a1fc987_1920.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在上一篇文章&lt;a href=&quot;https://bingfenglai.github.io/2021/12/12/golang/15_golang%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93/&quot;&gt;《golang中的协程与通道（上）》&lt;/a&gt;当中，我们初步认识了golang当中的协程的相关知识点。接下来，我们将开始学习通道(channel) 的相关知识点。&lt;/p&gt;
&lt;h2 id=&quot;通道的概念&quot;&gt;&lt;a href=&quot;#通道的概念&quot; class=&quot;headerlink&quot; title=&quot;通道的概念&quot;&gt;&lt;/a&gt;通道的概念&lt;/h2&gt;&lt;p&gt;在上一篇文章的demo当中，协程是独立执行的，他们之间没有进行通信。然而在实际情况下，协程之间必须要通信才会变得更加有用：协程之间通过发送和接收消息来协调或同步他们之间的工作。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/bingfenglai/art-demo/master/art-img/woman-ga2a1fc987_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在上一篇文章<a href="https://bingfenglai.github.io/2021/12/12/golang/15_golang%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93/">《golang中的协程与通道（上）》</a>当中，我们初步认识了golang当中的协程的相关知识点。接下来，我们将开始学习通道(channel) 的相关知识点。</p><h2 id="通道的概念"><a href="#通道的概念" class="headerlink" title="通道的概念"></a>通道的概念</h2><p>在上一篇文章的demo当中，协程是独立执行的，他们之间没有进行通信。然而在实际情况下，协程之间必须要通信才会变得更加有用：协程之间通过发送和接收消息来协调或同步他们之间的工作。</p><span id="more"></span><p>一组协程组成一条流水线，他们通过皮带流水装配线来协同工作，以提升资源利用率和工作效率。</p><p>Golang中有一种特殊的类型，通道（channel），它是一个可以用于发送类型化数据的管道，由其负责协程之间的通信，通过这种通信方式从而保证了同步性。</p><h2 id="通道的声明"><a href="#通道的声明" class="headerlink" title="通道的声明"></a>通道的声明</h2><p>通道的声明方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 通道标识符 <span class="keyword">chan</span> datatype</span><br></pre></td></tr></table></figure><p>未初始化的通道的值是<code>nil</code>.</p><p>从上面的声明语句当中我们知道，通道只能传输一种类型的数据，并且所有的数据类型都可用于通道。interface{}类型也是可以的。</p><p>实际上，通道是类型化消息的队列：它是先进先出（FIFO）的结构的，这保证了数据传输的顺序性。</p><p>通道是一种引用类型，因此我们可以使用make()函数来给它分配内存。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">ch1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br></pre></td></tr></table></figure><p>通道是第一类对象：可以存储在变量中，作为函数的参数传递，从函数返回以及通过通道发送它们自身。另外它们是类型化的，允许类型检查，比如尝试使用整数通道发送一个指针。</p><h2 id="通信操作符-lt"><a href="#通信操作符-lt" class="headerlink" title="通信操作符&lt;-"></a>通信操作符&lt;-</h2><p>通信操作符<code>&lt;-</code>箭头的方向为数据的流向。</p><p>流向通道：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch :=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch &lt;- int1</span><br></pre></td></tr></table></figure><p>从通道流出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int2 := &lt;- ch</span><br></pre></td></tr></table></figure><p><code>&lt;- ch</code> 可以单独调用获取通道的（下一个）值，当前值会被丢弃:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;- ch !=<span class="number">-1</span>&#123;</span><br><span class="line">    do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通道的特点"><a href="#通道的特点" class="headerlink" title="通道的特点"></a>通道的特点</h2><ol><li>为了可读性通道的命名通常以 <code>ch</code> 开头或者包含 <code>chan</code>。</li><li>通道的发送和接收都是原子操作：它们总是互不干扰的完成的。</li></ol><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>在下面的这个demo当中，我们结合前面学到的协程实际运用一下通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;runtime&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">2</span>)</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">ch1 :=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> sendData(ch)</span><br><span class="line"><span class="keyword">go</span> sayHello(ch,ch1)</span><br><span class="line"></span><br><span class="line">&lt;-ch1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendData</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="string">&quot;韩立&quot;</span></span><br><span class="line">ch &lt;- <span class="string">&quot;厉飞羽&quot;</span></span><br><span class="line">ch &lt;- <span class="string">&quot;张铁&quot;</span></span><br><span class="line">ch &lt;- <span class="string">&quot;墨大夫&quot;</span></span><br><span class="line">ch &lt;- <span class="string">&quot;南宫婉&quot;</span></span><br><span class="line">ch &lt;- <span class="string">&quot;六道传人&quot;</span></span><br><span class="line">ch &lt;- <span class="string">&quot;董萱儿&quot;</span></span><br><span class="line">ch &lt;-<span class="string">&quot;EOF&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(ch,ch1 <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">input := &lt;-ch</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> input!=<span class="string">&quot;EOF&quot;</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;hello !&quot;</span>,input)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ch1 &lt;- <span class="string">&quot;EOF&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hello ! 韩立</span><br><span class="line">hello ! 厉飞羽</span><br><span class="line">hello ! 张铁</span><br><span class="line">hello ! 墨大夫</span><br><span class="line">hello ! 南宫婉</span><br><span class="line">hello ! 六道传人</span><br><span class="line">hello ! 董萱儿</span><br></pre></td></tr></table></figure><p>在这个例子当中，<code>sendData()</code>函数向通道<code>ch</code>发送数据,<code>sayHello()</code>函数接受并处理，处理完数据后向<code>ch1</code>通道发送结束符，主程序退出。在这个例子当中，很好地展示了通道以及协程的综合使用。</p><h2 id="通道阻塞"><a href="#通道阻塞" class="headerlink" title="通道阻塞"></a>通道阻塞</h2><p>在上面的例子我们可以发现：在默认情况下，使用通道通信是同步且无缓冲的,必须要一个接收者准备好接收通道的数据后发送者才可以将数据发送给接收者，在这之前，通道是阻塞的。</p><p>在默认情况下：</p><ol><li><p>对于同一个通道，发送操作（协程或者函数中的），在接收者准备好之前是阻塞的：如果ch中的数据无人接收，就无法再给通道传入其他数据：新的输入无法在通道非空的情况下传入。所以发送操作会等待 ch 再次变为可用状态：就是通道值被接收时（可以传入变量）。</p></li><li><p>对于同一个通道，接收操作是阻塞的（协程或函数中的），直到发送者可用：如果通道中没有数据，接收者就阻塞了。</p></li></ol><h2 id="使用带缓冲的通道"><a href="#使用带缓冲的通道" class="headerlink" title="使用带缓冲的通道"></a>使用带缓冲的通道</h2><p>下面，我们将通过一个例子来学习带缓冲通道的使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 缓冲元素个数</span></span><br><span class="line">buf := <span class="number">3</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,buf)</span><br><span class="line"></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> sendData(ch)</span><br><span class="line"><span class="keyword">go</span> receivingData(ch,ch1)</span><br><span class="line"></span><br><span class="line">&lt;-ch1</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendData</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">data := [...]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;韩立&quot;</span>,</span><br><span class="line"><span class="string">&quot;厉飞羽&quot;</span>,</span><br><span class="line"><span class="string">&quot;张铁&quot;</span>,</span><br><span class="line"><span class="string">&quot;墨大夫&quot;</span>,</span><br><span class="line"><span class="string">&quot;南宫婉&quot;</span>,</span><br><span class="line"><span class="string">&quot;六道传人&quot;</span>,</span><br><span class="line"><span class="string">&quot;董萱儿&quot;</span>,</span><br><span class="line"><span class="string">&quot;EOF&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;开始发送数据&quot;</span>,time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> data &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ch &lt;- data[i]</span><br><span class="line">fmt.Println(<span class="string">&quot;发送数据：&quot;</span>, data[i])</span><br><span class="line"><span class="keyword">if</span> data[i] == <span class="string">&quot;EOF&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;数据发送完毕&quot;</span>,time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receivingData</span><span class="params">(ch, ch1 <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 为了演示缓冲效果，先让接收者函数休眠3秒</span></span><br><span class="line">time.Sleep(<span class="number">3</span>*<span class="number">1e9</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;开始接收数据&quot;</span>,time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">input := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> input != <span class="string">&quot;EOF&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;接收到数据：&quot;</span>, input)</span><br><span class="line">fmt.Println(<span class="string">&quot;数据处理中...&quot;</span>)</span><br><span class="line"><span class="comment">// 模拟数据处理耗时</span></span><br><span class="line">time.Sleep(<span class="number">1</span>*<span class="number">1e9</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;数据接收完毕&quot;</span>,time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ch1 &lt;- <span class="string">&quot;EOF&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">开始发送数据 <span class="number">2021</span><span class="number">-12</span><span class="number">-14</span> <span class="number">22</span>:<span class="number">25</span>:<span class="number">24</span></span><br><span class="line">发送数据： 韩立</span><br><span class="line">发送数据： 厉飞羽</span><br><span class="line">发送数据： 张铁</span><br><span class="line">开始接收数据 <span class="number">2021</span><span class="number">-12</span><span class="number">-14</span> <span class="number">22</span>:<span class="number">25</span>:<span class="number">27</span></span><br><span class="line">接收到数据： 韩立</span><br><span class="line">数据处理中...</span><br><span class="line">发送数据： 墨大夫</span><br><span class="line">接收到数据： 厉飞羽</span><br><span class="line">发送数据： 南宫婉</span><br><span class="line">数据处理中...</span><br><span class="line">接收到数据： 张铁</span><br><span class="line">数据处理中...</span><br><span class="line">发送数据： 六道传人</span><br><span class="line">接收到数据： 墨大夫</span><br><span class="line">数据处理中...</span><br><span class="line">发送数据： 董萱儿</span><br><span class="line">接收到数据： 南宫婉</span><br><span class="line">数据处理中...</span><br><span class="line">发送数据： EOF</span><br><span class="line">数据发送完毕 <span class="number">2021</span><span class="number">-12</span><span class="number">-14</span> <span class="number">22</span>:<span class="number">25</span>:<span class="number">31</span></span><br><span class="line">接收到数据： 六道传人</span><br><span class="line">数据处理中...</span><br><span class="line">接收到数据： 董萱儿</span><br><span class="line">数据处理中...</span><br><span class="line">数据接收完毕 <span class="number">2021</span><span class="number">-12</span><span class="number">-14</span> <span class="number">22</span>:<span class="number">25</span>:<span class="number">34</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子当中，<code>ch</code>是一个缓冲大小为3的通道。这意味着数据发送方可以在接收方未准备好的情况下先往通道里面塞3个数据，等接收方拿第一个数据后发送方就可以继续往里面塞数据。</p><p>总结如下：</p><ol><li><p>以上demo中buf 是通道可以同时容纳的元素（这里是 string）个数</p></li><li><p>在缓冲满载（缓冲被全部使用）之前，给一个带缓冲的通道发送数据是不会阻塞的，而从通道读取数据也不会阻塞，直到缓冲空了。</p></li><li><p>缓冲容量和类型无关，所以可以（尽管可能导致危险）给一些通道设置不同的容量，只要他们拥有同样的元素类型。内置的 <code>cap</code> 函数可以返回缓冲区的容量。</p></li><li><p>如果容量大于 0，通道就是异步的了：缓冲满载（发送）或变空（接收）之前通信不会阻塞，元素会按照发送的顺序被接收。如果容量是0或者未设置，通信仅在收发双方准备好的情况下才可以成功。</p></li></ol><h2 id="信号量模式"><a href="#信号量模式" class="headerlink" title="信号量模式"></a>信号量模式</h2><p>在上面的例子当中，为了告诉数据接收方数据已经发送完了，双方约定好：当接收到的数据等于”EOF”符号时，表示数据已发送完毕。数据接收方处理完数据后通过通道<code>ch1</code>发送”EOF”告诉主程序数据处理完毕，使得主程序退出。这里的”EOF”就是一个信号.</p><p>除此之外，信号量还经常用以实现互斥锁，限制对资源的并发访问。</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">2</span>)</span><br><span class="line">ch :=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i :=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++ &#123;</span><br><span class="line"><span class="keyword">go</span> buyGoods(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">3</span>* <span class="number">1e9</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buyGoods</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;准备下单&quot;</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;购买成功！库存剩余&quot;</span>,<span class="built_in">cap</span>(ch)-<span class="built_in">len</span>(ch))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">准备下单</span><br><span class="line">购买成功！库存剩余 <span class="number">2</span></span><br><span class="line">准备下单</span><br><span class="line">购买成功！库存剩余 <span class="number">1</span></span><br><span class="line">准备下单</span><br><span class="line">购买成功！库存剩余 <span class="number">0</span></span><br><span class="line">准备下单</span><br><span class="line">准备下单</span><br><span class="line">准备下单</span><br><span class="line">准备下单</span><br><span class="line">准备下单</span><br><span class="line">准备下单</span><br><span class="line">准备下单</span><br></pre></td></tr></table></figure><p>在这个例子当中，我们使用通道缓存元素个数来表示商品的库存，使用协程模拟并发访问，来模拟下单场景。可以看到使用通道缓存来实现信号量机制，可以保护我们的共享资源的并发访问。</p><p>除此之外，大家可以考虑一种计算场景：输入是一个很长的数据序列，我们要对这个序列求和，也就是1+2+…+n-1+n。这时，我们可以通过协程加通道的形式，使用并行计算的方式，计算好每个分段的和，然后将其发送到通道当中，主程序收到后进行最后的运算，这样可以极大的提高资源利用率，加快运算速度。关于这一块，这里只是顺嘴提一句，大家可以尝试着实现一下。</p><h2 id="通道的方向与习惯用法"><a href="#通道的方向与习惯用法" class="headerlink" title="通道的方向与习惯用法"></a>通道的方向与习惯用法</h2><h3 id="通道的方向"><a href="#通道的方向" class="headerlink" title="通道的方向"></a>通道的方向</h3><p>通道类型可以用注解来表示它只发送或者只接收：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只发送</span></span><br><span class="line"><span class="keyword">var</span> send_only <span class="keyword">chan</span>&lt;- <span class="keyword">int</span> </span><br><span class="line"><span class="comment">// 只接收</span></span><br><span class="line"><span class="keyword">var</span> recv_only &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>       </span><br></pre></td></tr></table></figure><p>只接收的通道（&lt;-chan T）无法关闭，因为关闭通道是发送者用来表示不再给通道发送值了，所以对只接收通道是没有意义的。</p><p>通道在创建时都是双向的，但是我们可以分配有方向的通道变量。</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch :=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> sendData(ch)</span><br><span class="line"><span class="keyword">go</span> receivingData(ch)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendData</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receivingData</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="习惯用法1：通道迭代器"><a href="#习惯用法1：通道迭代器" class="headerlink" title="习惯用法1：通道迭代器"></a>习惯用法1：通道迭代器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> container <span class="keyword">struct</span> &#123;</span><br><span class="line">items []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *container)</span> <span class="title">Len</span><span class="params">()</span><span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(c.items)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *container)</span> <span class="title">Iter</span> <span class="params">()</span> &lt;- <span class="title">chan</span> <span class="title">string</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; c.Len(); i++&#123;</span><br><span class="line">ch &lt;- c.items[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">&#125; ()</span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := container&#123;items: []<span class="keyword">string</span>&#123;<span class="string">&quot;韩立&quot;</span>,<span class="string">&quot;南宫婉&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s := <span class="keyword">range</span> c.Iter() &#123;</span><br><span class="line"><span class="built_in">println</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">韩立</span><br><span class="line">南宫婉</span><br></pre></td></tr></table></figure><p>以上就是给通道使用for循环实现的迭代器,其中<code>container</code>为存放资源的容器。使用for循环遍历通道，意味着它从指定通道中读取数据直到通道关闭，才继续执行下边的代码。<strong>写入完成后必须要关闭通道</strong> 。因为Iter函数返回的是一个只读通道，它是没法关闭的。</p><h3 id="习惯用法2-：生产者消费者模式"><a href="#习惯用法2-：生产者消费者模式" class="headerlink" title="习惯用法2 ：生产者消费者模式"></a>习惯用法2 ：生产者消费者模式</h3><p>假设存在生产者函数Produce()不断产生消费者consume()所需要的值，它们都可以运行在独立的协程中,那么你可以使用一下的写法:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">Consume(Produce(<span class="number">10</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Produce</span><span class="params">(size <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span>&#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;size;i++ &#123;</span><br><span class="line">ch&lt;-i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Consume</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ch &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;收到数据&quot;</span>,i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">收到数据 <span class="number">0</span></span><br><span class="line">收到数据 <span class="number">1</span></span><br><span class="line">收到数据 <span class="number">2</span></span><br><span class="line">收到数据 <span class="number">3</span></span><br><span class="line">收到数据 <span class="number">4</span></span><br><span class="line">收到数据 <span class="number">5</span></span><br><span class="line">收到数据 <span class="number">6</span></span><br><span class="line">收到数据 <span class="number">7</span></span><br><span class="line">收到数据 <span class="number">8</span></span><br><span class="line">收到数据 <span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>关于通道的内容我们就简单学习到这，下面一篇文章将学习协程与通道的更多用法。</p><p>本文当中涉及到的例子可以<a href="https://github.com/bingfenglai/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p>]]></content:encoded>
      
      
      
      <category domain="https://bingfenglai.github.io/tags/golang/">golang</category>
      
      
      <comments>https://bingfenglai.github.io/2021/12/15/golang/16_golang%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93%EF%BC%88%E4%BA%8C%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>golang中的协程与通道（一）</title>
      <link>https://bingfenglai.github.io/2021/12/12/golang/15_golang%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93/</link>
      <guid>https://bingfenglai.github.io/2021/12/12/golang/15_golang%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93/</guid>
      <pubDate>Sun, 12 Dec 2021 11:00:44 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/bingfenglai/art-demo/master/art-img/fox-ge22f332d8_1920.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在上一篇文章&lt;a href=&quot;https://bingfenglai.github.io/2021/12/11/golang/14_golang%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/&quot;&gt;《golang中的错误处理》&lt;/a&gt;当中，我们简单介绍了Golang当中的错误处理部分的内容。接下来，我们将学习Golang当中的&lt;strong&gt;协程&lt;/strong&gt;（goroutine）和&lt;strong&gt;通道&lt;/strong&gt;（channel）两部分的内容。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;作为一门 21 世纪的语言，Go 原生支持应用之间的通信和程序的并发。程序可以在不同的处理器和计算机上同时执行不同的代码段。Go 语言为构建并发程序的基本代码块是 &lt;strong&gt;协程&lt;/strong&gt; (go-routine) 与&lt;strong&gt;通道&lt;/strong&gt; (channel)。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/bingfenglai/art-demo/master/art-img/fox-ge22f332d8_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在上一篇文章<a href="https://bingfenglai.github.io/2021/12/11/golang/14_golang%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/">《golang中的错误处理》</a>当中，我们简单介绍了Golang当中的错误处理部分的内容。接下来，我们将学习Golang当中的<strong>协程</strong>（goroutine）和<strong>通道</strong>（channel）两部分的内容。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>作为一门 21 世纪的语言，Go 原生支持应用之间的通信和程序的并发。程序可以在不同的处理器和计算机上同时执行不同的代码段。Go 语言为构建并发程序的基本代码块是 <strong>协程</strong> (go-routine) 与<strong>通道</strong> (channel)。</p><span id="more"></span><h2 id="并发、并行和协程"><a href="#并发、并行和协程" class="headerlink" title="并发、并行和协程"></a>并发、并行和协程</h2><h3 id="协程的定义"><a href="#协程的定义" class="headerlink" title="协程的定义"></a>协程的定义</h3><p>在讲协程的定义之前，我们首先需要来了解什么是并发和并行，以及他们之间的区别。</p><p>一般来说，一个应用程序运行在机器上时，它对应着一个进程。一个进程由一个或多个操作系统线程组成，这些线程共享进程的内存地址空间。那么我们说，<strong>一个并发程序可以在一个处理器或者内核上使用多个线程来执行任务，但是只有同一个程序在某个时间点同时运行在多核或者多处理器上才是真正的并行。</strong></p><p>公认的，使用多线程的应用难以做到准确，最主要的问题是内存中的数据共享，它们会被多线程以无法预知的方式进行操作，导致一些无法重现或者随机的结果（称作 <code>竞态</code>）。那么解决这个问题的方法便是对数据加锁。这样同时就只有一个线程可以变更数据。在 Go 的标准库 <code>sync</code> 中有一些工具用来在低级别的代码中实现加锁。</p><p>为了方便大家理解加锁这个问题，下面给大家举一个形象的例子：</p><p>例如，在现实生活当中，妹子可以类比做数据。为了数据访问合法性，假设有一线程男要对某一数据女进行操作，那么在这之前，他需要带着妹子先去领证。那么领完证之后，就类比于对数据加了锁（排他锁、独占锁）。那么线程对数据才能进行操作，其他线程想要操作这个数据，那么就得等到原先的线程释放锁。而释放锁的过程正好与加锁的过程相反，就可以类比于离婚了。</p><p>上面的例子当中只是为了方便部分读者去理解锁的相关概念，例子当中涉及到的只有独占锁一类锁。实际编程当中还涉及到了读写锁、更新锁、乐观锁、悲观锁等等概念，关于这部分，大家可以去Google，这并不是今天的重点。</p><p>在过去的软件开发经验告诉我们这会带来更高的复杂度，更容易使代码出错以及更低的性能，所以这个经典的方法明显不再适合现代多核/多处理器编程。</p><p>在Golang当中，应用程序并发处理这部分被称作<strong>go-routines</strong>（协程或者go协程）（需要注意的是：这里的协程与Python当中的协程概念并不相同，这是两个完全不同的东西。），并鼓励开发者使用channels进行协程同步（后面会详细讲），而不是通过<code>sync</code>包当中的锁来实现。</p><h3 id="协程的特点"><a href="#协程的特点" class="headerlink" title="协程的特点"></a>协程的特点</h3><ol><li>协程与操作系统线程之间并没有一一对应的关系：协程是根据一个或多个线程的可用性，映射（多路复用）执行于他们之上的。</li><li>当系统调用（比如等待 I/O）阻塞协程时，其他协程会继续在其他线程上工作。协程的设计隐藏了许多线程创建和管理方面的复杂工作。</li><li>协程是轻量的，它比线程更轻。使用4K的栈内存就可以在堆当中创建它们。栈的管理是自动的，但不是由垃圾回收器管理的，而是在协程退出后自动释放。</li><li>协程可以运行在多个操作系统线程之间，也可以运行在线程之内，让你可以很小的内存占用就可以处理大量的任务。即使有协程阻塞，该线程的其他协程也可以被<code>runtime</code>调度，转移到其他可运行的线程上。并且这个细节对于开发者来说是透明的，降低了编程的难度。</li><li>线程是运行协程的实体，协程调度器将可运行的协程分配到工作线程上。</li></ol><h3 id="协程的调用"><a href="#协程的调用" class="headerlink" title="协程的调用"></a>协程的调用</h3><p>协程是通过使用关键字 <code>go</code> 调用（执行）一个函数或者方法来实现的（也可以是匿名或者 lambda 函数）。这样会在当前的计算过程中开始一个同时进行的函数，在相同的地址空间中并且分配了独立的栈，比如：<code>go sum(bigArray)</code>，在后台计算总和。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> 函数名（实参列表）</span><br></pre></td></tr></table></figure><h3 id="GOMAXPROCS参数的使用"><a href="#GOMAXPROCS参数的使用" class="headerlink" title="GOMAXPROCS参数的使用"></a>GOMAXPROCS参数的使用</h3><p>在上文中提到：线程是运行协程的实体，协程调度器将可运行的协程分配到工作线程上。那么，如何设置多少系统线程用于执行协程呢？这时就需要用到<strong>GOMAXPROCS</strong>参数。GOMAXPROCS参数默认值为1。这时，程序的所有协程都由1个线程执行，也就是N-1模式（关于其他几种模式，后面有时间再详细讲解）。</p><p>在N-1模式下，协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。但是缺点也很明显：无法使用多核加速能力，一旦某协程阻塞，就会造成线程阻塞。也因此，我们需要通过设置该参数，来充分利用多核CPU。</p><p>假设 n 是机器上处理器或者核心的数量。如果你设置环境变量 GOMAXPROCS&gt;=n，或者执行 <code>runtime.GOMAXPROCS(n)</code>，接下来协程会被分割（分散）到 n 个处理器上。更多的处理器并不意味着性能的线性提升。有这样一个经验法则，对于 n 个核心的情况设置 GOMAXPROCS 为 n-1 以获得最佳性能，也同样需要遵守这条规则：协程的数量 &gt; 1 + GOMAXPROCS &gt; 1。</p><p>一句话概括：GOMAXPROCS参数值等同于（并发的）线程数量，在一台核心数多于1个的机器上，会尽可能有等同于核心数的线程在并行运行。</p><h3 id="协程的简单应用demo"><a href="#协程的简单应用demo" class="headerlink" title="协程的简单应用demo"></a>协程的简单应用demo</h3><p>下面，我们将通过一个简单的的demo来实际应用协程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">i = <span class="built_in">append</span>(i, <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>)</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> sum(i)</span><br><span class="line"><span class="keyword">go</span> multiply(i)</span><br><span class="line"><span class="comment">// 为了保证协程逻辑执行完</span></span><br><span class="line">time.Sleep(<span class="number">1</span> * <span class="number">1e9</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求和函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(num []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> total <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> num &#123;</span><br><span class="line"></span><br><span class="line">total = num[i]+total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;求和结果为：&quot;</span>,total)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 乘积</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span><span class="params">(num []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> total <span class="keyword">int</span></span><br><span class="line">total = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> num &#123;</span><br><span class="line"></span><br><span class="line">total = num[i]*total</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;乘积结果为：&quot;</span>,total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">乘积结果为： 48</span><br><span class="line">求和结果为： 12</span><br></pre></td></tr></table></figure><p>在这个例子当中，我们需要对输入的一组数据分别进行求和运算与乘积运算。这两个运算可以同时进行。我们通过创建2个协程对其分别进行乘积与求和运算并打印最终的结果。</p><p>等我们学习完通道的相关知识点后，我们将对其进行一个综合的应用。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>在这篇文章当中，我们初步认识了Go语言当中的协程，并通过一个简单的demo跟大家分享协程的使用。在下一篇文章当中，我们将介绍通道的相关知识点。</p><p>本文当中涉及到的例子可以<a href="https://github.com/bingfenglai/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p>]]></content:encoded>
      
      
      
      <category domain="https://bingfenglai.github.io/tags/golang/">golang</category>
      
      
      <comments>https://bingfenglai.github.io/2021/12/12/golang/15_golang%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>golang中的错误处理</title>
      <link>https://bingfenglai.github.io/2021/12/11/golang/14_golang%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link>
      <guid>https://bingfenglai.github.io/2021/12/11/golang/14_golang%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid>
      <pubDate>Sat, 11 Dec 2021 07:23:40 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/bingfenglai/art-demo/master/art-img/photographer-g1a4cb0395_1920.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在前面的几篇文章当中，我们主要是学习了Golang当中文件的读写以及数据的编码方式相关的知识。接下来，我们将开始来学习Golang中的&lt;strong&gt;错误处理&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;Golang的错误处理模式&quot;&gt;&lt;a href=&quot;#Golang的错误处理模式&quot; class=&quot;headerlink&quot; title=&quot;Golang的错误处理模式&quot;&gt;&lt;/a&gt;Golang的错误处理模式&lt;/h2&gt;&lt;p&gt;Go并没有像Java那样的一套try/catch异常处理机制，它不能执行抛异常操作。它使用的是一套defer-panic-and-recover机制。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/bingfenglai/art-demo/master/art-img/photographer-g1a4cb0395_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在前面的几篇文章当中，我们主要是学习了Golang当中文件的读写以及数据的编码方式相关的知识。接下来，我们将开始来学习Golang中的<strong>错误处理</strong>。</p><h2 id="Golang的错误处理模式"><a href="#Golang的错误处理模式" class="headerlink" title="Golang的错误处理模式"></a>Golang的错误处理模式</h2><p>Go并没有像Java那样的一套try/catch异常处理机制，它不能执行抛异常操作。它使用的是一套defer-panic-and-recover机制。</p><span id="more"></span><p>那么，Golang是怎么处理错误的呢？它的处理方式是这样的：通过在函数和方法中返回错误对象作为它们的唯一或最后一个返回值——如果返回 nil，则没有错误发生——并且主调（calling）函数总是应该检查收到的错误。而上面提到的<code>panic and recover</code> 是用来处理真正的异常（无法预测的错误）而不是普通的错误。</p><h2 id="定义一个错误"><a href="#定义一个错误" class="headerlink" title="定义一个错误"></a>定义一个错误</h2><p>在Go中有一个预先定义好的error类型的接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>errors</code>这个包当中有一个errorString的结构体实现了这个接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误值s用来表示异常状态,当你需要一个新的错误类型，都可以用 <code>errors</code>包的 <code>errors.New</code> 函数接收合适的错误信息来创建。</p><p>请看下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">hello, err := sayHello(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">log.Default().Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(hello)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>,error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;&quot;</span>==name &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, errors.New(<span class="string">&quot;name 不能是一个空字符串&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span>+name,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021/10/02 14:53:16 name 不能是一个空字符串</span><br></pre></td></tr></table></figure><p>在这个例子当中，如果函数<code>sayHello</code>收到的参数<code>name</code>是一个空串的话,函数将返回一个错误，主调函数当中必须对错误进行处理。如果有不同错误条件可能发生，那么可以对实际的错误使用类型断言或类型判断（type-switch），然后根据错误场景做一些补救和恢复操作。</p><p>在Golang当中，对于错误类型以及错误变量有以下的命名规范：错误类型以 “Error” 结尾，错误变量以 “err” 或 “Err” 开头。</p><h2 id="运行时异常与panic"><a href="#运行时异常与panic" class="headerlink" title="运行时异常与panic"></a>运行时异常与<code>panic</code></h2><p>在Golang中，当发生了类似于数组下标越界或者是类型断言失败这样的运行时错误时，Go将会触发运行时<code>panic</code> (程序崩溃)。</p><p>这里需要注意的一点是，**<code>panic</code>的使用条件应当是相当严苛的并且是不能由程序自行恢复的**。发生这样的错误时，意味着程序将不能为我们提供服务，而需要终止程序。</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;发生程序崩溃前&quot;</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;程序崩溃了&quot;</span>)</span><br><span class="line">    <span class="comment">// 下面这条语句将不会被执行</span></span><br><span class="line">fmt.Println(<span class="string">&quot;已产生panic...&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个程序将导致它抛出<code>panic</code>，它打印出错误信息和<code>goroutine</code>痕迹，并以非零状态(非正常状态)退出。</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">发生程序崩溃前</span><br><span class="line">panic: 程序崩溃了</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">G:/06_golangProject/golang/src/go_code/err/panic_demo/main.go:8 +0xa5</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="panic使用场景与panicking"><a href="#panic使用场景与panicking" class="headerlink" title="panic使用场景与panicking"></a>panic使用场景与panicking</h3><p>在前面我们介绍了panic。在这里，我们来探讨一个问题：<strong>我们应该给在什么时候使用panic呢？</strong></p><p>我个人理解，panic适用于这样的场景：当发生的错误是我们不知道要怎么处理时（不打算优雅处理时），这种错误必须要中止程序运行了，那么，我们将使用到panic。</p><p>例如在我们学习Golang读写数据时，编写的小程序mycat（它用于打印文件内容，<a href="https://code81192.github.io/2021/09/28/golang/11_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%AD%EF%BC%89/#more">博文点击此处传送</a>）当中，程序根据用户输入的参数打开一个指定的文件，当文件不存在时，就可以抛出<code>panic</code>.</p><p>在多层嵌套的函数调用中调用 panic，可以马上中止当前函数的执行，所有的 defer 语句都会保证执行并把控制权交还给接收到 panic 的函数调用者。这样向上冒泡直到最顶层，并执行（每层的） defer，在栈顶处程序崩溃，并在命令行中用传给 panic 的值报告错误情况：这个终止过程就是 <em>panicking</em>。</p><p><strong>注意：</strong> 不要随意地用 panic 中止程序，应当尽力补救错误让程序能继续执行。 </p><h2 id="从-panic-中恢复（Recover）"><a href="#从-panic-中恢复（Recover）" class="headerlink" title="从 panic 中恢复（Recover）"></a>从 panic 中恢复（Recover）</h2><p>学会了panic的基本使用，我们需要思考一个问题，那就是，对于panic，我们只能中止程序运行吗？有没有从panic中恢复的方法？</p><p>这时，我们将使用到内建函数<code>recover()</code> 。它用于从panic或错误场景当中恢复，从而使得程序可以从panicking重新获得控制权，停止终止过程进而恢复程序的正常运行。</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;done...&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err:=<span class="built_in">recover</span>();err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;end...&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;start...&quot;</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;this is a error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start...</span><br><span class="line">done...</span><br><span class="line">this is a error</span><br><span class="line">end...</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> </p><ol><li><code>recover</code> 只能在 defer 修饰的函数中使用：用于取得 panic 调用中传递过来的错误值，如果是正常执行，调用 <code>recover</code> 会返回 nil，且没有其它效果。</li><li><strong>panic 会导致栈被展开直到 defer 修饰的 recover() 被调用或者程序中止。</strong></li></ol><p>以上就是defer-panic-and-recover机制。你也可以将其理解为像if、for一样的流程控制。它类似于Java当中的<code>try...catch</code> 机制。</p><p>我们在使用panic时，可以遵循Go 库的原则：即使在包的内部使用了 panic，在它的对外接口（API）中也必须用 recover 处理成返回显式的错误。</p><h2 id="自定义包中的错误处理和-panicking"><a href="#自定义包中的错误处理和-panicking" class="headerlink" title="自定义包中的错误处理和 panicking"></a>自定义包中的错误处理和 panicking</h2><p>在自定义包中的错误处理时，我们遵循以下原则：</p><ol><li>在包内部，总是应该和<code>panic</code> 中<code>recover</code>: 不应该显式的超出包范围的<code>panic</code> ()</li><li>向包的调用者返回错误值</li></ol><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> name []<span class="keyword">string</span></span><br><span class="line">name = <span class="built_in">append</span>(name, <span class="string">&quot;韩立&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;南宫婉&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> name &#123;</span><br><span class="line"></span><br><span class="line">err := SayHello(name[i])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHello</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//var ok bool</span></span><br><span class="line">err = fmt.Errorf(<span class="string">&quot;%v&quot;</span>,r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 注意： 抛出panic的函数必须在defer之后调用</span></span><br><span class="line">doSayHello(name)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSayHello</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(name)==<span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;名字不能是一个空字符串&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;hello %s\n&quot;</span>, name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello 韩立</span><br><span class="line">名字不能是一个空字符串</span><br><span class="line">hello 南宫婉</span><br></pre></td></tr></table></figure><p>在这个例子当中，包内从<code>panic</code>中<code>recover</code>，并返回给调用者错误提示，使得程序可以继续往下执行。重要的事情多说几遍，<strong>panic</strong>的使用应当严格地限制其场景，尽可能地使程序从<strong>panic</strong>中<strong>recover</strong></p><h2 id="使用闭包优雅地处理错误"><a href="#使用闭包优雅地处理错误" class="headerlink" title="使用闭包优雅地处理错误"></a>使用闭包优雅地处理错误</h2><p>像上面的代码一样，每当调用函数时，必须检查错误是否发生，这将增加代码的重复率，到处充斥着错误检查，这一点都不优雅。那么，在Golang中有没有机制像Java当中一样，可以统一地对错误进行处理呢？</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 = <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> name != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;Hello! &quot;</span>,name)</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;姓名不能为空&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">errorHandler(<span class="string">&quot;&quot;</span>,f1)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">errorHandler</span><span class="params">(name <span class="keyword">string</span>,f1 <span class="keyword">func</span>(s <span class="keyword">string</span>)</span> <span class="title">error</span>)</span>  &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>();r!=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">err := f1(name)</span><br><span class="line">check(err)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(e error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">姓名不能为空</span><br></pre></td></tr></table></figure><p>在这个例子当中，<code>errorHandler</code>是一个包装函数。它有两个参数，一个是<code>string</code> 类型的参数<code>name</code>,另一个则是匿名函数<code>f1</code> 。在<code>errorHandler</code>函数当中将调用函数<code>f1</code>,并通过<code>check</code>函数对程序执行进行校验这时，所有的错误都将被recover.</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>关于Golang当中的错误处理我们就初步介绍到这里。</p><p>本文当中涉及到的例子可以<a href="https://github.com/bingfenglai/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p>]]></content:encoded>
      
      
      
      <category domain="https://bingfenglai.github.io/tags/golang/">golang</category>
      
      
      <comments>https://bingfenglai.github.io/2021/12/11/golang/14_golang%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>golang中的读写数据之Gob</title>
      <link>https://bingfenglai.github.io/2021/10/01/golang/13_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E4%B9%8BGob/</link>
      <guid>https://bingfenglai.github.io/2021/10/01/golang/13_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E4%B9%8BGob/</guid>
      <pubDate>Fri, 01 Oct 2021 09:50:41 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/code81192/art-demo/master/art-img/sunset-gd662f1f15_1920.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在上一篇文章&lt;a href=&quot;https://bingfenglai.github.io/2021/09/29/golang/12_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%8B%EF%BC%89/&quot;&gt;《Golang中的读写数据（下）》&lt;/a&gt;当中，我们学会了Golang当中对于JSON数据的解析，接下来，我们将学习Gob编码方式。&lt;/p&gt;
&lt;h2 id=&quot;什么是Gob&quot;&gt;&lt;a href=&quot;#什么是Gob&quot; class=&quot;headerlink&quot; title=&quot;什么是Gob&quot;&gt;&lt;/a&gt;什么是Gob&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Gob的定义：&lt;/strong&gt; Gob是Go自己的以二进制形式序列化和反序列化程序数据的格式，这种数据格式简称之为&lt;strong&gt;Gob&lt;/strong&gt; (Go binary)。&lt;/p&gt;
&lt;p&gt;它类似于Java语言当中的&lt;code&gt;Serialization&lt;/code&gt; 。你可以在&lt;code&gt;encoding&lt;/code&gt; 包中找到它。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/sunset-gd662f1f15_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在上一篇文章<a href="https://bingfenglai.github.io/2021/09/29/golang/12_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%8B%EF%BC%89/">《Golang中的读写数据（下）》</a>当中，我们学会了Golang当中对于JSON数据的解析，接下来，我们将学习Gob编码方式。</p><h2 id="什么是Gob"><a href="#什么是Gob" class="headerlink" title="什么是Gob"></a>什么是Gob</h2><p><strong>Gob的定义：</strong> Gob是Go自己的以二进制形式序列化和反序列化程序数据的格式，这种数据格式简称之为<strong>Gob</strong> (Go binary)。</p><p>它类似于Java语言当中的<code>Serialization</code> 。你可以在<code>encoding</code> 包中找到它。</p><span id="more"></span><h2 id="Gob可以做什么"><a href="#Gob可以做什么" class="headerlink" title="Gob可以做什么"></a>Gob可以做什么</h2><p>Gob 通常用于远程方法调用（RPC）参数和结果的传输，以及应用程序和机器之间的数据传输。</p><p> 那么，它与我们之前普遍用到的JSON有什么不同呢？</p><p>Gob因为是 Go自己的以二进制形式序列化和反序列化程序数据的格式，因此呢只能用于纯Go环境当中，并不适用于异构的环境。例如，它可以用于两个Go程序之间的通信。</p><h2 id="Gob的特点"><a href="#Gob的特点" class="headerlink" title="Gob的特点"></a>Gob的特点</h2><ol><li><p>Gob 文件或流是完全自描述的：里面包含的所有类型都有一个对应的描述，并且总是可以用 Go 解码，而不需要了解文件的内容。</p></li><li><p>只有<strong>可导出</strong>的字段会被编码，零值会被忽略。</p></li><li><p>在解码结构体的时候，只有<strong>同时匹配名称和可兼容类型</strong>的字段才会被解码。</p></li><li><p>当源数据类型增加新字段后，Gob 解码客户端仍然可以以这种方式正常工作：解码客户端会继续识别以前存在的字段。</p></li></ol><h2 id="使用Gob传输数据"><a href="#使用Gob传输数据" class="headerlink" title="使用Gob传输数据"></a>使用Gob传输数据</h2><p>和 JSON 的使用方式一样，Gob 使用通用的 <code>io.Writer</code> 接口，通过 <code>NewEncoder()</code> 函数创建 <code>Encoder</code> 对象并调用 <code>Encode()</code>；相反的过程使用通用的 <code>io.Reader</code> 接口，通过 <code>NewDecoder()</code> 函数创建 <code>Decoder</code> 对象并调用 <code>Decode()</code>。</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/gob&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修仙者</span></span><br><span class="line"><span class="keyword">type</span> Immortal <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Age    <span class="keyword">int</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SimpleImmortal <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Age    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf  bytes.Buffer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hanli = Immortal&#123;</span><br><span class="line">Name:   <span class="string">&quot;韩立&quot;</span>,</span><br><span class="line">Age:    <span class="number">18</span>,</span><br><span class="line">Gender: <span class="string">&quot;男性&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;发送数据: &quot;</span>,hanli)</span><br><span class="line">sendMsg(&amp;hanli)</span><br><span class="line">fmt.Println(<span class="string">&quot;buf中的数据：&quot;</span>,buf)</span><br><span class="line"><span class="keyword">var</span> i SimpleImmortal</span><br><span class="line">msg, _ := receiveMsg(i)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;接收到数据：&quot;</span>,msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendMsg</span><span class="params">(immortal *Immortal)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">enc :=gob.NewEncoder(&amp;buf)</span><br><span class="line"><span class="keyword">return</span> enc.Encode(immortal)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receiveMsg</span><span class="params">(immortal SimpleImmortal)</span> <span class="params">(SimpleImmortal,error)</span></span> &#123;</span><br><span class="line">dec := gob.NewDecoder(&amp;buf)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> immortal,dec.Decode(&amp;immortal)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">发送数据:  &#123;韩立 <span class="number">18</span> 男性&#125;</span><br><span class="line">buf中的数据： &#123;[<span class="number">50</span> <span class="number">255</span> <span class="number">129</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span> <span class="number">8</span> <span class="number">73</span> <span class="number">109</span> <span class="number">109</span> <span class="number">111</span> <span class="number">114</span> <span class="number">116</span> <span class="number">97</span> <span class="number">108</span> <span class="number">1</span> <span class="number">255</span> <span class="number">130</span> <span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">78</span> <span class="number">97</span> <span class="number">109</span> <span class="number">101</span> <span class="number">1</span> <span class="number">12</span> <span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">65</span> <span class="number">103</span> <span class="number">101</span> <span class="number">1</span> <span class="number">4</span> <span class="number">0</span> <span class="number">1</span> <span class="number">6</span> <span class="number">71</span> <span class="number">101</span> <span class="number">110</span> <span class="number">100</span> <span class="number">101</span> <span class="number">114</span> <span class="number">1</span> <span class="number">12</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">21</span> <span class="number">255</span> <span class="number">130</span> <span class="number">1</span> <span class="number">6</span> <span class="number">233</span> <span class="number">159</span> <span class="number">169</span> <span class="number">231</span> <span class="number">171</span> <span class="number">139</span> <span class="number">1</span> <span class="number">36</span> <span class="number">1</span> <span class="number">6</span> <span class="number">231</span> <span class="number">148</span> <span class="number">183</span> <span class="number">230</span> <span class="number">128</span> <span class="number">167</span> <span class="number">0</span>] <span class="number">0</span> <span class="number">0</span>&#125;</span><br><span class="line">接收到数据： &#123;韩立 <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>关于Gob的内容我们就简单介绍到这里。本文当中涉及到的例子可以<a href="https://github.com/code81192/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p><p>在下一篇文章当中，我们将一起来学习Golang当中的错误处理相关的内容。</p>]]></content:encoded>
      
      
      
      <category domain="https://bingfenglai.github.io/tags/golang/">golang</category>
      
      
      <comments>https://bingfenglai.github.io/2021/10/01/golang/13_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E4%B9%8BGob/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Golang中的读写数据（下）--JSON数据的编码与解码</title>
      <link>https://bingfenglai.github.io/2021/09/29/golang/12_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%8B%EF%BC%89/</link>
      <guid>https://bingfenglai.github.io/2021/09/29/golang/12_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%8B%EF%BC%89/</guid>
      <pubDate>Tue, 28 Sep 2021 16:33:22 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/code81192/art-demo/master/art-img/woman-5590119_1920.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在上一篇文章&lt;a href=&quot;https://bingfenglai.github.io/2021/09/28/golang/11_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%AD%EF%BC%89/&quot;&gt;《Golang中的读写数据（中）》&lt;/a&gt;中，我们学习了在Golang中如何读取命令行参数，接下来我们将学习Golang中的数据格式化。&lt;/p&gt;
&lt;p&gt;我们都知道数据要在网络当中进行传输，或者是将其保存到文件当中，就要必须对其编码和解码。常见的编码格式有JSON和XML等。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/woman-5590119_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在上一篇文章<a href="https://bingfenglai.github.io/2021/09/28/golang/11_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%AD%EF%BC%89/">《Golang中的读写数据（中）》</a>中，我们学习了在Golang中如何读取命令行参数，接下来我们将学习Golang中的数据格式化。</p><p>我们都知道数据要在网络当中进行传输，或者是将其保存到文件当中，就要必须对其编码和解码。常见的编码格式有JSON和XML等。</p><span id="more"></span><h3 id="一些概念的补充"><a href="#一些概念的补充" class="headerlink" title="一些概念的补充"></a>一些概念的补充</h3><p><strong>编码：</strong> 从特定数据结构到数据流这一过程</p><p><strong>解码：</strong> 解码是编码的逆过程，即从数据流到数据结构这一过程</p><p><strong>序列化：</strong> 将内存当中的数据抓换成指定的格式的过程，例如将一个Java对象转为一个字符串</p><p>接下来我们将介绍在Golang中将数据编码为JSON的相关内容，在这一部分内容当中，我们将使用到<code>encoding</code>这个库</p><h2 id="JSON数据操作"><a href="#JSON数据操作" class="headerlink" title="JSON数据操作"></a>JSON数据操作</h2><p>为了演示这一部分的内容，我将之前我们学习结构体时用到的结构体抄写在下面</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修仙者</span></span><br><span class="line"><span class="keyword">type</span> Immortal <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Age    <span class="keyword">int</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后大家请看下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修仙者</span></span><br><span class="line"><span class="keyword">type</span> Immortal <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Age    <span class="keyword">int</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">immortal := &amp;Immortal&#123;</span><br><span class="line">Name:   <span class="string">&quot;韩立&quot;</span>,</span><br><span class="line">Age:    <span class="number">18</span>,</span><br><span class="line">Gender: <span class="string">&quot;男性&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将修仙者韩立编码为json的[]byte</span></span><br><span class="line">jsonByteImmortal, _ := json.Marshal(immortal)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, jsonByteImmortal)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;Name&quot;</span>:<span class="string">&quot;韩立&quot;</span>,<span class="attr">&quot;Age&quot;</span>:<span class="number">18</span>,<span class="attr">&quot;Gender&quot;</span>:<span class="string">&quot;男性&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>上面用到的<code>json.Marshal</code>函数的函数签名是<code>func Marshal(v interface&#123;&#125;) ([]byte, error)</code> 它返回的是byte数组，因此打印时需要指定格式。</p><p>JSON 与 Go 类型对应如下：</p><ul><li>bool 对应 JSON 的 boolean</li><li>float64 对应 JSON 的 number</li><li>string 对应 JSON 的 string</li><li>nil 对应 JSON 的 null</li></ul><p>不是所有的数据都可以编码为 JSON 类型：只有验证通过的数据结构才能被编码：</p><ul><li>JSON 对象只支持字符串类型的 key；要编码一个 Go map 类型，map 必须是 map[string]T（T是 <code>json</code> 包中支持的任何类型）</li><li>Channel，复杂类型和函数类型不能被编码</li><li>不支持循环数据结构；它将引起序列化进入一个无限循环</li><li>指针可以被编码，实际上是对指针指向的值进行编码（或者指针是 nil）</li></ul><h2 id="反序列化操作"><a href="#反序列化操作" class="headerlink" title="反序列化操作"></a>反序列化操作</h2><p>在Golang中如何将一个JSON转换为Golang中的数据结构呢？</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修仙者</span></span><br><span class="line"><span class="keyword">type</span> Immortal <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Age    <span class="keyword">int</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">immortal := &amp;Immortal&#123;</span><br><span class="line">Name:   <span class="string">&quot;韩立&quot;</span>,</span><br><span class="line">Age:    <span class="number">18</span>,</span><br><span class="line">Gender: <span class="string">&quot;男性&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonImmortal, _ := json.Marshal(immortal)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, jsonImmortal)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 事先知道json对应的数据类型时</span></span><br><span class="line"> <span class="keyword">var</span> jsonValue Immortal</span><br><span class="line"></span><br><span class="line">json.Unmarshal(jsonImmortal, &amp;jsonValue)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;name&quot;</span>,jsonValue.Name)</span><br><span class="line">fmt.Println(<span class="string">&quot;age&quot;</span>,jsonValue.Age)</span><br><span class="line">fmt.Println(<span class="string">&quot;gender&quot;</span>,jsonValue.Gender)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 不知道json对应的数据结构</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">json.Unmarshal(jsonImmortal,&amp;m)</span><br><span class="line"></span><br><span class="line">jsonMap := m.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> jsonMap &#123;</span><br><span class="line">printJson(key,value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printJson</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> value.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">fmt.Println(key,<span class="string">&quot;value is a string: &quot;</span>,value)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">fmt.Println(key,<span class="string">&quot;value is int type: &quot;</span>,value)</span><br><span class="line"><span class="keyword">case</span> []<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">fmt.Println(key,<span class="string">&quot;value is a array&quot;</span>,value)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">m:= value.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">printJson(k,v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;Name&quot;:&quot;韩立&quot;,&quot;Age&quot;:18,&quot;Gender&quot;:&quot;男性&quot;&#125;</span><br><span class="line">name 韩立</span><br><span class="line">age 18</span><br><span class="line">gender 男性</span><br><span class="line">Name value is a string:  韩立</span><br><span class="line">Age value is int type:  18</span><br><span class="line">Gender value is a string:  男性</span><br></pre></td></tr></table></figure><p>在这个例子当中，存在着两种情况：</p><p>第一种情况：<strong>我们事先知道JSON数据对应的数据结构</strong>，则调用<code>json.Unmarshal</code>函数将其解码（也可以理解为反序列化）并存入该数据结构指针变量指向的内存地址当中；</p><p>第二种情况：<strong>我们事先不知道JSON数据对应的数据结构</strong>，则可以使用<strong>类型断言</strong>技术得到JSON数据当中<code>key: value</code>对应的值。</p><h2 id="解码以及编码JSON数据流"><a href="#解码以及编码JSON数据流" class="headerlink" title="解码以及编码JSON数据流"></a>解码以及编码JSON数据流</h2><p>json 包提供 Decoder 和 Encoder 类型来支持常用 JSON 数据流读写。NewDecoder 和 NewEncoder 函数分别封装了 io.Reader 和 io.Writer 接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDecoder</span><span class="params">(r io.Reader)</span> *<span class="title">Decoderfunc</span> <span class="title">NewEncoder</span><span class="params">(w io.Writer)</span> *<span class="title">Encoder</span></span></span><br></pre></td></tr></table></figure><p>要想把 JSON 直接写入文件，可以使用 json.NewEncoder 初始化文件（或者任何实现 io.Writer 的类型），并调用 Encode()；反过来与其对应的是使用 json.NewDecoder 和 Decode() 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDecoder</span><span class="params">(r io.Reader)</span> *<span class="title">Decoderfunc</span> <span class="params">(dec *Decoder)</span> <span class="title">Decode</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>在Golang中解析转换JSON数据的内容我们就简单介绍到这里。本文当中涉及到的例子可以<a href="https://github.com/code81192/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p><p>在下一篇文章当中，我们将一起来学习Golang当中一种独有的编码格式<code>Gob</code> </p>]]></content:encoded>
      
      
      
      <category domain="https://bingfenglai.github.io/tags/golang/">golang</category>
      
      
      <comments>https://bingfenglai.github.io/2021/09/29/golang/12_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%8B%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Golang中的读写数据（中）</title>
      <link>https://bingfenglai.github.io/2021/09/28/golang/11_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%AD%EF%BC%89/</link>
      <guid>https://bingfenglai.github.io/2021/09/28/golang/11_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%AD%EF%BC%89/</guid>
      <pubDate>Mon, 27 Sep 2021 16:36:11 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/code81192/art-demo/master/art-img/yoga-2176668_1920.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在上一篇文章《&lt;a href=&quot;https://bingfenglai.github.io/2021/09/24/golang/10_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE(%E4%B8%8A)/&quot;&gt;Golang中的读写数据（上）&lt;/a&gt;》当中，我们介绍了Golang中一些简单的文件读写、拷贝操作，接下来，我们将继续学习Golang中的读写数据的相关知识点。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/yoga-2176668_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在上一篇文章《<a href="https://bingfenglai.github.io/2021/09/24/golang/10_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE(%E4%B8%8A)/">Golang中的读写数据（上）</a>》当中，我们介绍了Golang中一些简单的文件读写、拷贝操作，接下来，我们将继续学习Golang中的读写数据的相关知识点。</p><span id="more"></span><h2 id="从命令行读取参数"><a href="#从命令行读取参数" class="headerlink" title="从命令行读取参数"></a>从命令行读取参数</h2><p>在一些场景当中，我们在执行一个软件，有时候需要传入一些初始化的信息，例如连接数据库的<code>username</code>和<code>password</code>等属性。那么，在Golang中是如何读取参数的呢？请看下面的例子:</p><h3 id="使用os-Args-获取参数"><a href="#使用os-Args-获取参数" class="headerlink" title="使用os.Args 获取参数"></a>使用<code>os.Args</code> 获取参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(os.Args);i++ &#123;</span><br><span class="line">sayHello(os.Args[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;参数为空&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(name... <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;hello!&quot;</span>,name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/image-20210927204103589.png" alt="image-20210927204103589"></p><p><strong>注意：</strong></p><p>这个命令行参数会放置在切片 <code>os.Args[]</code> 中（以空格分隔），从索引1开始（<code>os.Args[0]</code> 放的是程序本身的名字）。函数 <code>strings.Join</code> 以空格为间隔连接这些参数。</p><h3 id="使用flag-Args获取参数"><a href="#使用flag-Args获取参数" class="headerlink" title="使用flag.Args获取参数"></a>使用<code>flag.Args</code>获取参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, arg := <span class="keyword">range</span> flag.Args() &#123;</span><br><span class="line">sayHello(arg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(name... <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;hello!&quot;</span>,name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/image-20210927224440371.png" alt="image-20210927224440371"></p><p><strong>注意：</strong></p><p><code>flag.Arg(0)</code> 就是第一个真实的 flag，而不是像 <code>os.Args(0)</code> 放置程序的名字。</p><h3 id="一个例子：使用缓存读取文件与flag-Args的综合应用"><a href="#一个例子：使用缓存读取文件与flag-Args的综合应用" class="headerlink" title="一个例子：使用缓存读取文件与flag.Args的综合应用"></a>一个例子：使用缓存读取文件与<code>flag.Args</code>的综合应用</h3><p>接触过Linux系统的小伙伴们应该经常会<code>cat filename</code>这个命令，接下来，我们将使用Golang实现这个小工具.</p><h4 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h4><p>我们需要一个小工具来打印文件的内容，当文件不存在时给用户一个友好的提示。</p><h4 id="功能设计"><a href="#功能设计" class="headerlink" title="功能设计"></a>功能设计</h4><ol><li>根据用户输入的文件名读取文件到缓存并分批次打印</li><li>当文件不存在时输出”不存在文件 {文件名}”</li></ol><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">filename :=flag.Arg(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> filename==<span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Command Usage Format: mycat filename&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">open, err := os.Open(filename)</span><br><span class="line"><span class="keyword">defer</span> open.Close()</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">myCat(bufio.NewReader(open))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myCat</span><span class="params">(reader *bufio.Reader)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  &#123;</span><br><span class="line">buf, err := reader.ReadBytes(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">fmt.Fprintf(os.Stdout, <span class="string">&quot;%s\n&quot;</span>, buf)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><ol><li>当文件存在时打印文件内容：</li></ol><p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/image-20210927231646066.png" alt="image-20210927231646066"></p><ol start="2"><li>当文件不存在时给出提示：</li></ol><p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/image-20210927231918164.png" alt="image-20210927231918164"></p><h4 id="提个问题：这个程序能满足需求吗？"><a href="#提个问题：这个程序能满足需求吗？" class="headerlink" title="提个问题：这个程序能满足需求吗？"></a>提个问题：这个程序能满足需求吗？</h4><p>大家可以思考一下，如果被打印的文件是一个只有一行数据的大文件，会出现什么情况？</p><p>因此，为了避免出现这个情况，我们将对<code>mycat</code>进行改造。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">filename :=flag.Arg(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> filename==<span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Command Usage Format: mycat filename&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file, err := os.Open(filename)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myCatV2(bufio.NewReader(file))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myCatV2</span><span class="params">(reader *bufio.Reader)</span></span> &#123;</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">512</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  &#123;</span><br><span class="line">n, err := reader.Read(buf)</span><br><span class="line">fmt.Fprintf(os.Stdout,<span class="string">&quot;%s&quot;</span>,buf[<span class="number">0</span>:n])</span><br><span class="line"><span class="keyword">if</span> err ==io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这一版当中，我们指定了缓存区的大小，它是一个512位的<code>byte</code>数组。</p><p>输出：</p><p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/image-20210928002030354.png" alt="image-20210928002030354"></p><p>我们指定了缓冲区的大小，这样就避免了将整个文件都加载到内存当中。</p><p>当然，大家可以继续对程序进行改进，例如引入协程等技术，这便不在本文的讨论当中了。</p><h2 id="重要的一点：使用defer关闭文件"><a href="#重要的一点：使用defer关闭文件" class="headerlink" title="重要的一点：使用defer关闭文件"></a>重要的一点：使用<code>defer</code>关闭文件</h2><p>在前面的文章当中，我们介绍了<code>defer</code>关键字的作用：他将在函数退出时（return之后）执行其修饰的语句。在这里，我们使用其来在<code>main</code>函数退出前关闭文件。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>关于Golang中读取命令行参数以及与文件读写操作的综合应用我们就介绍到这里。本文当中涉及到的例子可以<a href="https://github.com/code81192/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p><p>在下一篇文章当中我们将一起来学习Golang中的数据格式化以及数据网络传输等内容。</p>]]></content:encoded>
      
      
      
      <category domain="https://bingfenglai.github.io/tags/golang/">golang</category>
      
      
      <comments>https://bingfenglai.github.io/2021/09/28/golang/11_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%AD%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>golang中的读写数据（上）</title>
      <link>https://bingfenglai.github.io/2021/09/24/golang/10_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE(%E4%B8%8A)/</link>
      <guid>https://bingfenglai.github.io/2021/09/24/golang/10_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE(%E4%B8%8A)/</guid>
      <pubDate>Fri, 24 Sep 2021 15:34:08 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/code81192/art-demo/master/art-img/spring-2298279_1920.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在前面的文章当中，我们学会了如何去搭建Golang开发环境、学习了Golang当中常见的数据结构、学习了基本流程控制语句、学习了函数和结构体等内容，接下来我们将开始学习Golang当中的文件读写。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/spring-2298279_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在前面的文章当中，我们学会了如何去搭建Golang开发环境、学习了Golang当中常见的数据结构、学习了基本流程控制语句、学习了函数和结构体等内容，接下来我们将开始学习Golang当中的文件读写。</p><span id="more"></span><h2 id="读取用户在控制台的输入"><a href="#读取用户在控制台的输入" class="headerlink" title="读取用户在控制台的输入"></a>读取用户在控制台的输入</h2><p>在Golang当中，如何读取用户在控制台的输入呢？在这里，我们可以使用<code>fmt</code>包当中<code>Scan</code>开头的函数。</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> firstname,lastname <span class="keyword">string</span></span><br><span class="line">fmt.Println(<span class="string">&quot;请输入您的姓名：&quot;</span>)</span><br><span class="line">_, _ = fmt.Scanln(&amp;firstname, &amp;lastname)</span><br><span class="line">fmt.Printf(<span class="string">&quot;你好！%s · %s\n&quot;</span>, lastname, firstname)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请输入您的姓名：</span><br><span class="line">韩 立</span><br><span class="line">你好！立 · 韩</span><br></pre></td></tr></table></figure><p><code>Scanln</code> 扫描来自标准输入的文本，将空格分隔的值依次存放到后续的参数内，直到碰到换行。<code>Scanf</code> 与其类似，除了 <code>Scanf</code> 的第一个参数用作格式字符串，用来决定如何读取。<code>Sscan</code> 和以 <code>Sscan</code> 开头的函数则是从字符串读取，除此之外，与 <code>Scanf</code> 相同。如果这些函数读取到的结果与您预想的不同，你可以检查成功读入数据的个数和返回的错误。</p><p>除此之外，我们也可以使用 <code>bufio</code> 包提供的缓冲读取（buffered reader）来读取数据</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;请输入一段文字&quot;</span>)</span><br><span class="line">inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line">s,err := inputReader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;你输入的是：&quot;</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请输入一段文字</span><br><span class="line">去年今日此门中 人面桃花相映红。人面不知何处在 桃花依旧笑春风。</span><br><span class="line">你输入的是：</span><br><span class="line">去年今日此门中 人面桃花相映红。人面不知何处在 桃花依旧笑春风。</span><br></pre></td></tr></table></figure><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id="文件读操作"><a href="#文件读操作" class="headerlink" title="文件读操作"></a>文件读操作</h3><p>在 Go 语言中，文件使用指向 <code>os.File</code> 类型的指针来表示的，也叫做文件句柄。</p><h4 id="按行读取"><a href="#按行读取" class="headerlink" title="按行读取"></a>按行读取</h4><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">inputFile, err := os.Open(<span class="string">&quot;G:\\06_golangProject\\golang\\doc\\筑基部分\\10_golang中的读写数据.md&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> inputFile.Close()</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">input :=bufio.NewReader(inputFile)</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">readString, err := input.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">fmt.Println(readString)</span><br><span class="line"><span class="keyword">if</span> err==io.EOF &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子当中，我们使用<code>os.Open</code>打开一个文件，并在循环当中逐行地打印该文件，直到打印完该文件。</p><h4 id="带缓冲的文件读取"><a href="#带缓冲的文件读取" class="headerlink" title="带缓冲的文件读取"></a>带缓冲的文件读取</h4><p>很不幸的是，在很多情况下，文件的内容不是按行划分的，甚至有时候文件是一个二进制文件。这时，我们应当如何去读取它呢？</p><p>请看下面的这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">inputFile, err := os.Open(<span class="string">&quot;G:\\06_golangProject\\golang\\doc\\筑基部分\\10_golang中的读写数据.md&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> inputFile.Close()</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>  &#123;</span><br><span class="line">_, err := inputFile.Read(buf)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err==io.EOF &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(buf))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义了一个<code>[]byte</code>类型的缓存，在读取文件时，将读到的内容存入这个缓存中并进行打印。这样，我们就不需要去在意文件当中内容是如何划分的了。</p><h3 id="文件写操作"><a href="#文件写操作" class="headerlink" title="文件写操作"></a>文件写操作</h3><p>简单地介绍了Golang中的文件读操作，再讲一下文件的写操作，请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">file, err := os.OpenFile(<span class="string">&quot;古丹丹方.txt&quot;</span>, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;打开文件出错&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span>  file.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个缓冲区</span></span><br><span class="line">writer := bufio.NewWriter(file)</span><br><span class="line"></span><br><span class="line">s := <span class="string">&quot;Hello World\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="comment">// 写入缓冲区</span></span><br><span class="line">_, _ = writer.WriteString(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将缓冲区的数据写入文件</span></span><br><span class="line">_ = writer.Flush()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来我们看一下这个<code>os.OpenFile(name string, flag int, perm FileMode) (*File, error)</code>函数。我们可以看到，它有三个参数，第一个参数为文件名，第二个参数是打开标志（我们以只写打开文件，如果文件不存在则创建它），第三个参数是文件权限。</p><p>对于第二个参数，当存在多个标志时使用逻辑运算符<code>|</code>连接，常见的标志有以下几个：</p><ul><li><code>os.O_RDONLY</code>：只读</li><li><code>os.O_WRONLY</code>：只写</li><li><code>os.O_CREATE</code>：创建：如果指定文件不存在，就创建该文件。</li><li><code>os.O_TRUNC</code>：截断：如果指定文件已存在，就将该文件的长度截为0。</li></ul><p>在读文件的时候，文件的权限是被忽略的，所以在使用 <code>OpenFile</code> 时传入的第三个参数可以用0。而在写文件时，不管是 Unix 还是 Windows，都需要使用 0666。</p><h2 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h2><p>不知还有道友记得没，韩立在筑基期的洞府里用两株草药换了他雷师伯的丹方，他雷师伯当然不会直接将古方给他，而是将丹方拷贝了一份到玉简给了韩立。</p><p>那么？在Golang中如何实现将文件<code>source.txt</code>拷贝到<code>target.txt</code>呢？请看下面的这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">copyFile(<span class="string">&quot;古丹丹方.txt&quot;</span>,<span class="string">&quot;给韩立的玉简.txt&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;拷贝完成！&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyFile</span><span class="params">(source, target <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">openFile, err := os.Open(source)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;打开源文件出错&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> openFile.Close()</span><br><span class="line"></span><br><span class="line">createFile, err := os.Create(target)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;创建目标文件出错&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> createFile.Close()</span><br><span class="line"></span><br><span class="line">written, err := io.Copy(createFile, openFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(written)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实看起来还是很简单的，直接使用<code>io.Copy</code>函数就OK了，但是要注意的是<strong>第一个参数是目标文件名，第二个参数才是源文件</strong>。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>以上就是Golang关于文件读写的上半部分内容，本文当中涉及到的例子可以<a href="https://github.com/code81192/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p><p>在下一篇文章当中我们将一起来学习Golang读取命令行参数和Golang中的数据网络传输等内容。</p>]]></content:encoded>
      
      
      
      <category domain="https://bingfenglai.github.io/tags/golang/">golang</category>
      
      
      <comments>https://bingfenglai.github.io/2021/09/24/golang/10_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE(%E4%B8%8A)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Golang入门学习之接口（interface）</title>
      <link>https://bingfenglai.github.io/2021/09/12/golang/09_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E6%8E%A5%E5%8F%A3/</link>
      <guid>https://bingfenglai.github.io/2021/09/12/golang/09_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E6%8E%A5%E5%8F%A3/</guid>
      <pubDate>Sun, 12 Sep 2021 11:26:45 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/code81192/art-demo/master/art-img/avenue-815297_1920.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在上一篇文章&lt;a href=&quot;https://bingfenglai.github.io/2021/09/09/golang/08_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E6%96%B9%E6%B3%95/&quot;&gt;《Golang入门学习之方法（method）》&lt;/a&gt;当中，我们学习了Golang当中的方法的定义与运用，在接下来的这篇文章当中，我们将一起来学习Goalng的接口（interface）。&lt;/p&gt;
&lt;h2 id=&quot;接口的定义&quot;&gt;&lt;a href=&quot;#接口的定义&quot; class=&quot;headerlink&quot; title=&quot;接口的定义&quot;&gt;&lt;/a&gt;接口的定义&lt;/h2&gt;&lt;p&gt;接口是定义了一组需要被实现的方法的&lt;strong&gt;抽象类型&lt;/strong&gt;，实现接口的数据类型可以视为接口的实例。接口由一组方法与一个接口类型组成。声明格式如下：&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/avenue-815297_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在上一篇文章<a href="https://bingfenglai.github.io/2021/09/09/golang/08_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E6%96%B9%E6%B3%95/">《Golang入门学习之方法（method）》</a>当中，我们学习了Golang当中的方法的定义与运用，在接下来的这篇文章当中，我们将一起来学习Goalng的接口（interface）。</p><h2 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h2><p>接口是定义了一组需要被实现的方法的<strong>抽象类型</strong>，实现接口的数据类型可以视为接口的实例。接口由一组方法与一个接口类型组成。声明格式如下：</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    方法名(形参列表) (返回值列表)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照Golang的编程风格（约定），只包含一个方法的接口的名字由方法名加 <code>[e]r</code> 后缀组成，例如 <code>Printer</code>、<code>Reader</code>、<code>Writer</code>、<code>Logger</code>、<code>Converter</code> 等等。还有一些不常用的方式（当后缀 <code>er</code> 不合适时），比如 <code>Recoverable</code>，此时接口名以 <code>able</code> 结尾，或者以 <code>I</code> 开头（像  <code>Java</code> 中那样）。</p><p>Go 语言中的接口都很简短，通常它们会包含 0 个、最多 3 个方法。</p><p>请看下面这个例子：</p><p>首先，我们在interfaces包中声明一个<code>SpiritualRootAble</code>（表示具备修行的能力,现了灵根接口的凡人即可修炼）接口</p><p><code>src/go_code/interface/interfaces/spiritual_root.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> interfaces</span><br><span class="line"></span><br><span class="line"><span class="comment">// 灵根接口，实现了灵根接口的凡人即可修炼</span></span><br><span class="line"><span class="keyword">type</span> SpiritualRootAble <span class="keyword">interface</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成灵根</span></span><br><span class="line">GenSpiritualRootNames() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取生成的灵根</span></span><br><span class="line">SpiritualRoot() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修行方法</span></span><br><span class="line">Practice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，我们在model包当中声明一个凡人结构体（<code>mortal</code>） 并实现<code>SpiritualRootAble</code>接口</p><p><code>src/go_code/interface/model/mortal.go</code> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/big&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 凡人</span></span><br><span class="line"><span class="keyword">type</span> Mortal <span class="keyword">struct</span> &#123;</span><br><span class="line">name ,</span><br><span class="line">gender ,</span><br><span class="line">spiritualRoot <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMortal</span><span class="params">(name, gender <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> <span class="title">Mortal</span></span> &#123;</span><br><span class="line">mortal:=Mortal&#123;</span><br><span class="line">name:   name,</span><br><span class="line">gender: gender,</span><br><span class="line">age:    age,</span><br><span class="line">&#125;</span><br><span class="line">mortal.spiritualRoot = mortal.GenSpiritualRootNames()</span><br><span class="line"><span class="keyword">return</span> mortal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv Mortal)</span> <span class="title">SpiritualRoot</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> &amp;recv.spiritualRoot == <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;没有灵根&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> recv.spiritualRoot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv Mortal)</span><span class="title">Practice</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(recv.name,<span class="string">&quot;开始修行...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv Mortal)</span> <span class="title">GenSpiritualRootNames</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">gsrn := []<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;金灵根&quot;</span>,<span class="string">&quot;水灵根&quot;</span>,<span class="string">&quot;木灵根&quot;</span>,<span class="string">&quot;火灵根&quot;</span>,<span class="string">&quot;土灵根&quot;</span>,<span class="string">&quot;没有灵根&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">index, _ := rand.Int(rand.Reader, big.NewInt(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  gsrn[index.Int64()]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，我们在main中使用他们</p><p><code>src/go_code/interface/main/main.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;go_code/interface/interfaces&quot;</span></span><br><span class="line"><span class="string">&quot;go_code/interface/model&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 声明了一个SpiritualRootAble接口类型的变量</span></span><br><span class="line"> <span class="keyword">var</span> sr interfaces.SpiritualRootAble</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 降生了一个凡人</span></span><br><span class="line"> mortal := model.NewMortal(<span class="string">&quot;韩立&quot;</span>,<span class="string">&quot;男性&quot;</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 接口变量指向凡人实例</span></span><br><span class="line">sr = mortal</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取凡人的灵根</span></span><br><span class="line">fmt.Println(sr.SpiritualRoot())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 凡人开始修炼</span></span><br><span class="line">sr.Practice()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">火灵根</span><br><span class="line">韩立 开始修行...</span><br></pre></td></tr></table></figure><p>可以看到：</p><p>在Golang中并需要显示地声明类型实现了某一接口（不需要如同Java那样<code>class implemments interfacesName</code>），只要类型实现了接口当中定义的方法集，类型即是实现了该接口。</p><p>实现某个接口的类型（除了实现接口方法外）可以有其他的方法。</p><p>一个类型可以实现多个接口(实际上<code>mortal</code>还实现了空接口，关于空接口的内容请继续往下看)。</p><p>接口类型可以包含一个实例的引用， 该实例的类型实现了此接口（接口是动态类型）。</p><h2 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h2><p>空接口即为不包含任何方法的接口。任何类型都实现了空接口。空接口有点类似于Java当中的Object的概念</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Any <span class="keyword">interface</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="接口嵌套接口"><a href="#接口嵌套接口" class="headerlink" title="接口嵌套接口"></a>接口嵌套接口</h2><p>一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。</p><p>比如接口 <code>File</code> 包含了 <code>ReadWrite</code> 和 <code>Lock</code> 的所有方法，它还额外有一个 <code>Close()</code> 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWrite <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(b Buffer) <span class="keyword">bool</span></span><br><span class="line">    Write(b Buffer) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Lock <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">interface</span> &#123;</span><br><span class="line">    ReadWrite</span><br><span class="line">    Lock</span><br><span class="line">    Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Golang中的类型断言"><a href="#Golang中的类型断言" class="headerlink" title="Golang中的类型断言"></a>Golang中的类型断言</h2><p>对于一个接口类型变量<code>varI</code>中可以包含任何类型的值，so,必须有一种方式来检测它的<strong>动态类型</strong>，也就是运行时变量var中存储的值的实际类型。而这，就是<strong>类型断言</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v := varI.(T)</span><br></pre></td></tr></table></figure><p>类型断言可能是无效的，虽然编译器会尽力检查转换是否有效，但是它不可能预见所有的可能性。如果转换在程序运行时失败会导致错误发生。更安全的方式是使用以下形式来进行类型断言：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v,ok :=varI.(T);ok&#123;</span><br><span class="line">    do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果转换合法，<code>v</code> 是 <code>varI</code> 转换到类型 <code>T</code> 的值，<code>ok</code> 会是 <code>true</code>；否则 <code>v</code> 是类型 <code>T</code> 的零值，<code>ok</code> 是 <code>false</code>，也没有运行时错误发生。</p><p>如果我们只是需要判断<code>varI</code>是否为T类型而不需要获取类型T的值时,可以这样做：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _,ok := varI.(T);ok&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们继续沿用上面的例子讲类型断言这部分的内容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;go_code/interface/interfaces&quot;</span></span><br><span class="line"><span class="string">&quot;go_code/interface/model&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 声明了一个SpiritualRootAble接口类型的变量</span></span><br><span class="line"> <span class="keyword">var</span> sr interfaces.SpiritualRootAble</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 降生了一个凡人</span></span><br><span class="line"> mortal := model.NewMortal(<span class="string">&quot;韩立&quot;</span>,<span class="string">&quot;男性&quot;</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 接口变量指向凡人实例</span></span><br><span class="line">sr = mortal</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型断言</span></span><br><span class="line"><span class="keyword">if</span> v,ok :=sr.(*model.Mortal);ok&#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;&#123;韩立 男性 金灵根 <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，我们在实现<code>SpiritualRootAble</code> 时方法的receiver类型为<code>*Mortal</code> ，即凡人的指针类型。因此实际上实现SpiritualRootAble接口的是*Mortal，因此在进行类型断言时T为<code>*Mortal</code> 。我们在使用类型断言的时候要注意这一点，不然编译器会报错。</p><h2 id="类型断言的应用"><a href="#类型断言的应用" class="headerlink" title="类型断言的应用"></a>类型断言的应用</h2><p>在Golang中，我们如何测试一个值是否实现了某一接口呢？答案就是通过类型断言</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m interfaceTypeName</span><br><span class="line"><span class="keyword">if</span> _,ok := m.(interfaceTypeName);ok &#123;</span><br><span class="line">fmt.Println(ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>接口可以理解为一种契约，实现类型必须满足它，它描述了类型的行为，规定类型可以做什么。接口彻底将类型能做什么，以及如何做分离开来，使得相同接口的变量在不同的时刻表现出不同的行为，这就是多态的本质。</p><p>在golang中：</p><ul><li>指针方法可以通过指针调用</li><li>值方法可以通过值调用</li><li>接收者是值的方法可以通过指针调用，因为指针会首先被解引用</li><li>接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址</li></ul><p>将一个值赋值给一个接口时，编译器会确保所有可能的接口方法都可以在此值上被调用，因此不正确的赋值在编译期就会失败。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>关于Golang当中接口的知识点我就简单介绍到这里。本文当中涉及到的例子可以<a href="https://github.com/code81192/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。从下一篇文章开始，我们将开启<strong>筑基系列</strong>的学习，具体涉及到的知识点有：反射、文件操作、数据交换、错误处理、Go协程（goroutine）和通道（channel）等内容。欢迎各位小伙伴订阅我的博客👊。</p>]]></content:encoded>
      
      
      
      <category domain="https://bingfenglai.github.io/tags/golang/">golang</category>
      
      
      <comments>https://bingfenglai.github.io/2021/09/12/golang/09_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E6%8E%A5%E5%8F%A3/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
