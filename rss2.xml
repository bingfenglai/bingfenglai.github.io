<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>赖柄沣的技术博客</title>
    <link>https://bingfenglai.github.io/</link>
    
    <atom:link href="https://bingfenglai.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>赖柄沣的技术博客</description>
    <pubDate>Sun, 12 Dec 2021 11:06:44 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>golang中的协程与通道（上）</title>
      <link>https://bingfenglai.github.io/2021/12/12/golang/15_golang%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93/</link>
      <guid>https://bingfenglai.github.io/2021/12/12/golang/15_golang%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93/</guid>
      <pubDate>Sun, 12 Dec 2021 11:00:44 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/bingfenglai/art-demo/master/art-img/fox-ge22f332d8_1920.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在上一篇文章&lt;a href=&quot;https://bingfenglai.github.io/2021/12/11/golang/14_golang%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/&quot;&gt;《golang中的错误处理》&lt;/a&gt;当中，我们简单介绍了Golang当中的错误处理部分的内容。接下来，我们将学习Golang当中的&lt;strong&gt;协程&lt;/strong&gt;（goroutine）和&lt;strong&gt;通道&lt;/strong&gt;（channel）两部分的内容。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;作为一门 21 世纪的语言，Go 原生支持应用之间的通信和程序的并发。程序可以在不同的处理器和计算机上同时执行不同的代码段。Go 语言为构建并发程序的基本代码块是 &lt;strong&gt;协程&lt;/strong&gt; (go-routine) 与&lt;strong&gt;通道&lt;/strong&gt; (channel)。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/bingfenglai/art-demo/master/art-img/fox-ge22f332d8_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在上一篇文章<a href="https://bingfenglai.github.io/2021/12/11/golang/14_golang%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/">《golang中的错误处理》</a>当中，我们简单介绍了Golang当中的错误处理部分的内容。接下来，我们将学习Golang当中的<strong>协程</strong>（goroutine）和<strong>通道</strong>（channel）两部分的内容。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>作为一门 21 世纪的语言，Go 原生支持应用之间的通信和程序的并发。程序可以在不同的处理器和计算机上同时执行不同的代码段。Go 语言为构建并发程序的基本代码块是 <strong>协程</strong> (go-routine) 与<strong>通道</strong> (channel)。</p><span id="more"></span><h2 id="并发、并行和协程"><a href="#并发、并行和协程" class="headerlink" title="并发、并行和协程"></a>并发、并行和协程</h2><h3 id="协程的定义"><a href="#协程的定义" class="headerlink" title="协程的定义"></a>协程的定义</h3><p>在讲协程的定义之前，我们首先需要来了解什么是并发和并行，以及他们之间的区别。</p><p>一般来说，一个应用程序运行在机器上时，它对应着一个进程。一个进程由一个或多个操作系统线程组成，这些线程共享进程的内存地址空间。那么我们说，<strong>一个并发程序可以在一个处理器或者内核上使用多个线程来执行任务，但是只有同一个程序在某个时间点同时运行在多核或者多处理器上才是真正的并行。</strong></p><p>公认的，使用多线程的应用难以做到准确，最主要的问题是内存中的数据共享，它们会被多线程以无法预知的方式进行操作，导致一些无法重现或者随机的结果（称作 <code>竞态</code>）。那么解决这个问题的方法便是对数据加锁。这样同时就只有一个线程可以变更数据。在 Go 的标准库 <code>sync</code> 中有一些工具用来在低级别的代码中实现加锁。</p><p>为了方便大家理解加锁这个问题，下面给大家举一个形象的例子：</p><p>例如，在现实生活当中，妹子可以类比做数据。为了数据访问合法性，假设有一线程男要对某一数据女进行操作，那么在这之前，他需要带着妹子先去领证。那么领完证之后，就类比于对数据加了锁（排他锁、独占锁）。那么线程对数据才能进行操作，其他线程想要操作这个数据，那么就得等到原先的线程释放锁。而释放锁的过程正好与加锁的过程相反，就可以类比于离婚了。</p><p>上面的例子当中只是为了方便部分读者去理解锁的相关概念，例子当中涉及到的只有独占锁一类锁。实际编程当中还涉及到了读写锁、更新锁、乐观锁、悲观锁等等概念，关于这部分，大家可以去Google，这并不是今天的重点。</p><p>在过去的软件开发经验告诉我们这会带来更高的复杂度，更容易使代码出错以及更低的性能，所以这个经典的方法明显不再适合现代多核/多处理器编程。</p><p>在Golang当中，应用程序并发处理这部分被称作<strong>go-routines</strong>（协程或者go协程）（需要注意的是：这里的协程与Python当中的协程概念并不相同，这是两个完全不同的东西。），并鼓励开发者使用channels进行协程同步（后面会详细讲），而不是通过<code>sync</code>包当中的锁来实现。</p><h3 id="协程的特点"><a href="#协程的特点" class="headerlink" title="协程的特点"></a>协程的特点</h3><ol><li>协程与操作系统线程之间并没有一一对应的关系：协程是根据一个或多个线程的可用性，映射（多路复用）执行于他们之上的。</li><li>当系统调用（比如等待 I/O）阻塞协程时，其他协程会继续在其他线程上工作。协程的设计隐藏了许多线程创建和管理方面的复杂工作。</li><li>协程是轻量的，它比线程更轻。使用4K的栈内存就可以在堆当中创建它们。栈的管理是自动的，但不是由垃圾回收器管理的，而是在协程退出后自动释放。</li><li>协程可以运行在多个操作系统线程之间，也可以运行在线程之内，让你可以很小的内存占用就可以处理大量的任务。即使有协程阻塞，该线程的其他协程也可以被<code>runtime</code>调度，转移到其他可运行的线程上。并且这个细节对于开发者来说是透明的，降低了编程的难度。</li><li>线程是运行协程的实体，协程调度器将可运行的协程分配到工作线程上。</li></ol><h3 id="协程的调用"><a href="#协程的调用" class="headerlink" title="协程的调用"></a>协程的调用</h3><p>协程是通过使用关键字 <code>go</code> 调用（执行）一个函数或者方法来实现的（也可以是匿名或者 lambda 函数）。这样会在当前的计算过程中开始一个同时进行的函数，在相同的地址空间中并且分配了独立的栈，比如：<code>go sum(bigArray)</code>，在后台计算总和。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> 函数名（实参列表）</span><br></pre></td></tr></table></figure><h3 id="GOMAXPROCS参数的使用"><a href="#GOMAXPROCS参数的使用" class="headerlink" title="GOMAXPROCS参数的使用"></a>GOMAXPROCS参数的使用</h3><p>在上文中提到：线程是运行协程的实体，协程调度器将可运行的协程分配到工作线程上。那么，如何设置多少系统线程用于执行协程呢？这时就需要用到<strong>GOMAXPROCS</strong>参数。GOMAXPROCS参数默认值为1。这时，程序的所有协程都由1个线程执行，也就是N-1模式（关于其他几种模式，后面有时间再详细讲解）。</p><p>在N-1模式下，协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。但是缺点也很明显：无法使用多核加速能力，一旦某协程阻塞，就会造成线程阻塞。也因此，我们需要通过设置该参数，来充分利用多核CPU。</p><p>假设 n 是机器上处理器或者核心的数量。如果你设置环境变量 GOMAXPROCS&gt;=n，或者执行 <code>runtime.GOMAXPROCS(n)</code>，接下来协程会被分割（分散）到 n 个处理器上。更多的处理器并不意味着性能的线性提升。有这样一个经验法则，对于 n 个核心的情况设置 GOMAXPROCS 为 n-1 以获得最佳性能，也同样需要遵守这条规则：协程的数量 &gt; 1 + GOMAXPROCS &gt; 1。</p><p>一句话概括：GOMAXPROCS参数值等同于（并发的）线程数量，在一台核心数多于1个的机器上，会尽可能有等同于核心数的线程在并行运行。</p><h3 id="协程的简单应用demo"><a href="#协程的简单应用demo" class="headerlink" title="协程的简单应用demo"></a>协程的简单应用demo</h3><p>下面，我们将通过一个简单的的demo来实际应用协程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">i = <span class="built_in">append</span>(i, <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>)</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> sum(i)</span><br><span class="line"><span class="keyword">go</span> multiply(i)</span><br><span class="line"><span class="comment">// 为了保证协程逻辑执行完</span></span><br><span class="line">time.Sleep(<span class="number">1</span> * <span class="number">1e9</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求和函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(num []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> total <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> num &#123;</span><br><span class="line"></span><br><span class="line">total = num[i]+total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;求和结果为：&quot;</span>,total)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 乘积</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span><span class="params">(num []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> total <span class="keyword">int</span></span><br><span class="line">total = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> num &#123;</span><br><span class="line"></span><br><span class="line">total = num[i]*total</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;乘积结果为：&quot;</span>,total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">乘积结果为： 48</span><br><span class="line">求和结果为： 12</span><br></pre></td></tr></table></figure><p>在这个例子当中，我们需要对输入的一组数据分别进行求和运算与乘积运算。这两个运算可以同时进行。我们通过创建2个协程对其分别进行乘积与求和运算并打印最终的结果。</p><p>等我们学习完通道的相关知识点后，我们将对其进行一个综合的应用。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>在这篇文章当中，我们初步认识了Go语言当中的协程，并通过一个简单的demo跟大家分享协程的使用。在下一篇文章当中，我们将介绍通道的相关知识点。</p><p>本文当中涉及到的例子可以<a href="https://github.com/bingfenglai/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p>]]></content:encoded>
      
      
      
      <category domain="https://bingfenglai.github.io/tags/golang/">golang</category>
      
      
      <comments>https://bingfenglai.github.io/2021/12/12/golang/15_golang%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>golang中的错误处理</title>
      <link>https://bingfenglai.github.io/2021/12/11/golang/14_golang%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link>
      <guid>https://bingfenglai.github.io/2021/12/11/golang/14_golang%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid>
      <pubDate>Sat, 11 Dec 2021 07:23:40 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/bingfenglai/art-demo/master/art-img/photographer-g1a4cb0395_1920.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在前面的几篇文章当中，我们主要是学习了Golang当中文件的读写以及数据的编码方式相关的知识。接下来，我们将开始来学习Golang中的&lt;strong&gt;错误处理&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;Golang的错误处理模式&quot;&gt;&lt;a href=&quot;#Golang的错误处理模式&quot; class=&quot;headerlink&quot; title=&quot;Golang的错误处理模式&quot;&gt;&lt;/a&gt;Golang的错误处理模式&lt;/h2&gt;&lt;p&gt;Go并没有像Java那样的一套try/catch异常处理机制，它不能执行抛异常操作。它使用的是一套defer-panic-and-recover机制。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/bingfenglai/art-demo/master/art-img/photographer-g1a4cb0395_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在前面的几篇文章当中，我们主要是学习了Golang当中文件的读写以及数据的编码方式相关的知识。接下来，我们将开始来学习Golang中的<strong>错误处理</strong>。</p><h2 id="Golang的错误处理模式"><a href="#Golang的错误处理模式" class="headerlink" title="Golang的错误处理模式"></a>Golang的错误处理模式</h2><p>Go并没有像Java那样的一套try/catch异常处理机制，它不能执行抛异常操作。它使用的是一套defer-panic-and-recover机制。</p><span id="more"></span><p>那么，Golang是怎么处理错误的呢？它的处理方式是这样的：通过在函数和方法中返回错误对象作为它们的唯一或最后一个返回值——如果返回 nil，则没有错误发生——并且主调（calling）函数总是应该检查收到的错误。而上面提到的<code>panic and recover</code> 是用来处理真正的异常（无法预测的错误）而不是普通的错误。</p><h2 id="定义一个错误"><a href="#定义一个错误" class="headerlink" title="定义一个错误"></a>定义一个错误</h2><p>在Go中有一个预先定义好的error类型的接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>errors</code>这个包当中有一个errorString的结构体实现了这个接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误值s用来表示异常状态,当你需要一个新的错误类型，都可以用 <code>errors</code>包的 <code>errors.New</code> 函数接收合适的错误信息来创建。</p><p>请看下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">hello, err := sayHello(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">log.Default().Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(hello)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>,error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;&quot;</span>==name &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, errors.New(<span class="string">&quot;name 不能是一个空字符串&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span>+name,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021/10/02 14:53:16 name 不能是一个空字符串</span><br></pre></td></tr></table></figure><p>在这个例子当中，如果函数<code>sayHello</code>收到的参数<code>name</code>是一个空串的话,函数将返回一个错误，主调函数当中必须对错误进行处理。如果有不同错误条件可能发生，那么可以对实际的错误使用类型断言或类型判断（type-switch），然后根据错误场景做一些补救和恢复操作。</p><p>在Golang当中，对于错误类型以及错误变量有以下的命名规范：错误类型以 “Error” 结尾，错误变量以 “err” 或 “Err” 开头。</p><h2 id="运行时异常与panic"><a href="#运行时异常与panic" class="headerlink" title="运行时异常与panic"></a>运行时异常与<code>panic</code></h2><p>在Golang中，当发生了类似于数组下标越界或者是类型断言失败这样的运行时错误时，Go将会触发运行时<code>panic</code> (程序崩溃)。</p><p>这里需要注意的一点是，**<code>panic</code>的使用条件应当是相当严苛的并且是不能由程序自行恢复的**。发生这样的错误时，意味着程序将不能为我们提供服务，而需要终止程序。</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;发生程序崩溃前&quot;</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;程序崩溃了&quot;</span>)</span><br><span class="line">    <span class="comment">// 下面这条语句将不会被执行</span></span><br><span class="line">fmt.Println(<span class="string">&quot;已产生panic...&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个程序将导致它抛出<code>panic</code>，它打印出错误信息和<code>goroutine</code>痕迹，并以非零状态(非正常状态)退出。</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">发生程序崩溃前</span><br><span class="line">panic: 程序崩溃了</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">G:/06_golangProject/golang/src/go_code/err/panic_demo/main.go:8 +0xa5</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="panic使用场景与panicking"><a href="#panic使用场景与panicking" class="headerlink" title="panic使用场景与panicking"></a>panic使用场景与panicking</h3><p>在前面我们介绍了panic。在这里，我们来探讨一个问题：<strong>我们应该给在什么时候使用panic呢？</strong></p><p>我个人理解，panic适用于这样的场景：当发生的错误是我们不知道要怎么处理时（不打算优雅处理时），这种错误必须要中止程序运行了，那么，我们将使用到panic。</p><p>例如在我们学习Golang读写数据时，编写的小程序mycat（它用于打印文件内容，<a href="https://code81192.github.io/2021/09/28/golang/11_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%AD%EF%BC%89/#more">博文点击此处传送</a>）当中，程序根据用户输入的参数打开一个指定的文件，当文件不存在时，就可以抛出<code>panic</code>.</p><p>在多层嵌套的函数调用中调用 panic，可以马上中止当前函数的执行，所有的 defer 语句都会保证执行并把控制权交还给接收到 panic 的函数调用者。这样向上冒泡直到最顶层，并执行（每层的） defer，在栈顶处程序崩溃，并在命令行中用传给 panic 的值报告错误情况：这个终止过程就是 <em>panicking</em>。</p><p><strong>注意：</strong> 不要随意地用 panic 中止程序，应当尽力补救错误让程序能继续执行。 </p><h2 id="从-panic-中恢复（Recover）"><a href="#从-panic-中恢复（Recover）" class="headerlink" title="从 panic 中恢复（Recover）"></a>从 panic 中恢复（Recover）</h2><p>学会了panic的基本使用，我们需要思考一个问题，那就是，对于panic，我们只能中止程序运行吗？有没有从panic中恢复的方法？</p><p>这时，我们将使用到内建函数<code>recover()</code> 。它用于从panic或错误场景当中恢复，从而使得程序可以从panicking重新获得控制权，停止终止过程进而恢复程序的正常运行。</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;done...&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err:=<span class="built_in">recover</span>();err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;end...&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;start...&quot;</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;this is a error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start...</span><br><span class="line">done...</span><br><span class="line">this is a error</span><br><span class="line">end...</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> </p><ol><li><code>recover</code> 只能在 defer 修饰的函数中使用：用于取得 panic 调用中传递过来的错误值，如果是正常执行，调用 <code>recover</code> 会返回 nil，且没有其它效果。</li><li><strong>panic 会导致栈被展开直到 defer 修饰的 recover() 被调用或者程序中止。</strong></li></ol><p>以上就是defer-panic-and-recover机制。你也可以将其理解为像if、for一样的流程控制。它类似于Java当中的<code>try...catch</code> 机制。</p><p>我们在使用panic时，可以遵循Go 库的原则：即使在包的内部使用了 panic，在它的对外接口（API）中也必须用 recover 处理成返回显式的错误。</p><h2 id="自定义包中的错误处理和-panicking"><a href="#自定义包中的错误处理和-panicking" class="headerlink" title="自定义包中的错误处理和 panicking"></a>自定义包中的错误处理和 panicking</h2><p>在自定义包中的错误处理时，我们遵循以下原则：</p><ol><li>在包内部，总是应该和<code>panic</code> 中<code>recover</code>: 不应该显式的超出包范围的<code>panic</code> ()</li><li>向包的调用者返回错误值</li></ol><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> name []<span class="keyword">string</span></span><br><span class="line">name = <span class="built_in">append</span>(name, <span class="string">&quot;韩立&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;南宫婉&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> name &#123;</span><br><span class="line"></span><br><span class="line">err := SayHello(name[i])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHello</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//var ok bool</span></span><br><span class="line">err = fmt.Errorf(<span class="string">&quot;%v&quot;</span>,r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 注意： 抛出panic的函数必须在defer之后调用</span></span><br><span class="line">doSayHello(name)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSayHello</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(name)==<span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;名字不能是一个空字符串&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;hello %s\n&quot;</span>, name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello 韩立</span><br><span class="line">名字不能是一个空字符串</span><br><span class="line">hello 南宫婉</span><br></pre></td></tr></table></figure><p>在这个例子当中，包内从<code>panic</code>中<code>recover</code>，并返回给调用者错误提示，使得程序可以继续往下执行。重要的事情多说几遍，<strong>panic</strong>的使用应当严格地限制其场景，尽可能地使程序从<strong>panic</strong>中<strong>recover</strong></p><h2 id="使用闭包优雅地处理错误"><a href="#使用闭包优雅地处理错误" class="headerlink" title="使用闭包优雅地处理错误"></a>使用闭包优雅地处理错误</h2><p>像上面的代码一样，每当调用函数时，必须检查错误是否发生，这将增加代码的重复率，到处充斥着错误检查，这一点都不优雅。那么，在Golang中有没有机制像Java当中一样，可以统一地对错误进行处理呢？</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 = <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> name != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;Hello! &quot;</span>,name)</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;姓名不能为空&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">errorHandler(<span class="string">&quot;&quot;</span>,f1)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">errorHandler</span><span class="params">(name <span class="keyword">string</span>,f1 <span class="keyword">func</span>(s <span class="keyword">string</span>)</span> <span class="title">error</span>)</span>  &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>();r!=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">err := f1(name)</span><br><span class="line">check(err)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(e error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">姓名不能为空</span><br></pre></td></tr></table></figure><p>在这个例子当中，<code>errorHandler</code>是一个包装函数。它有两个参数，一个是<code>string</code> 类型的参数<code>name</code>,另一个则是匿名函数<code>f1</code> 。在<code>errorHandler</code>函数当中将调用函数<code>f1</code>,并通过<code>check</code>函数对程序执行进行校验这时，所有的错误都将被recover.</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>关于Golang当中的错误处理我们就初步介绍到这里。</p><p>本文当中涉及到的例子可以<a href="https://github.com/bingfenglai/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p>]]></content:encoded>
      
      
      
      <category domain="https://bingfenglai.github.io/tags/golang/">golang</category>
      
      
      <comments>https://bingfenglai.github.io/2021/12/11/golang/14_golang%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>golang中的读写数据之Gob</title>
      <link>https://bingfenglai.github.io/2021/10/01/golang/13_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E4%B9%8BGob/</link>
      <guid>https://bingfenglai.github.io/2021/10/01/golang/13_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E4%B9%8BGob/</guid>
      <pubDate>Fri, 01 Oct 2021 09:50:41 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/code81192/art-demo/master/art-img/sunset-gd662f1f15_1920.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在上一篇文章&lt;a href=&quot;https://bingfenglai.github.io/2021/09/29/golang/12_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%8B%EF%BC%89/&quot;&gt;《Golang中的读写数据（下）》&lt;/a&gt;当中，我们学会了Golang当中对于JSON数据的解析，接下来，我们将学习Gob编码方式。&lt;/p&gt;
&lt;h2 id=&quot;什么是Gob&quot;&gt;&lt;a href=&quot;#什么是Gob&quot; class=&quot;headerlink&quot; title=&quot;什么是Gob&quot;&gt;&lt;/a&gt;什么是Gob&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Gob的定义：&lt;/strong&gt; Gob是Go自己的以二进制形式序列化和反序列化程序数据的格式，这种数据格式简称之为&lt;strong&gt;Gob&lt;/strong&gt; (Go binary)。&lt;/p&gt;
&lt;p&gt;它类似于Java语言当中的&lt;code&gt;Serialization&lt;/code&gt; 。你可以在&lt;code&gt;encoding&lt;/code&gt; 包中找到它。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/sunset-gd662f1f15_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在上一篇文章<a href="https://bingfenglai.github.io/2021/09/29/golang/12_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%8B%EF%BC%89/">《Golang中的读写数据（下）》</a>当中，我们学会了Golang当中对于JSON数据的解析，接下来，我们将学习Gob编码方式。</p><h2 id="什么是Gob"><a href="#什么是Gob" class="headerlink" title="什么是Gob"></a>什么是Gob</h2><p><strong>Gob的定义：</strong> Gob是Go自己的以二进制形式序列化和反序列化程序数据的格式，这种数据格式简称之为<strong>Gob</strong> (Go binary)。</p><p>它类似于Java语言当中的<code>Serialization</code> 。你可以在<code>encoding</code> 包中找到它。</p><span id="more"></span><h2 id="Gob可以做什么"><a href="#Gob可以做什么" class="headerlink" title="Gob可以做什么"></a>Gob可以做什么</h2><p>Gob 通常用于远程方法调用（RPC）参数和结果的传输，以及应用程序和机器之间的数据传输。</p><p> 那么，它与我们之前普遍用到的JSON有什么不同呢？</p><p>Gob因为是 Go自己的以二进制形式序列化和反序列化程序数据的格式，因此呢只能用于纯Go环境当中，并不适用于异构的环境。例如，它可以用于两个Go程序之间的通信。</p><h2 id="Gob的特点"><a href="#Gob的特点" class="headerlink" title="Gob的特点"></a>Gob的特点</h2><ol><li><p>Gob 文件或流是完全自描述的：里面包含的所有类型都有一个对应的描述，并且总是可以用 Go 解码，而不需要了解文件的内容。</p></li><li><p>只有<strong>可导出</strong>的字段会被编码，零值会被忽略。</p></li><li><p>在解码结构体的时候，只有<strong>同时匹配名称和可兼容类型</strong>的字段才会被解码。</p></li><li><p>当源数据类型增加新字段后，Gob 解码客户端仍然可以以这种方式正常工作：解码客户端会继续识别以前存在的字段。</p></li></ol><h2 id="使用Gob传输数据"><a href="#使用Gob传输数据" class="headerlink" title="使用Gob传输数据"></a>使用Gob传输数据</h2><p>和 JSON 的使用方式一样，Gob 使用通用的 <code>io.Writer</code> 接口，通过 <code>NewEncoder()</code> 函数创建 <code>Encoder</code> 对象并调用 <code>Encode()</code>；相反的过程使用通用的 <code>io.Reader</code> 接口，通过 <code>NewDecoder()</code> 函数创建 <code>Decoder</code> 对象并调用 <code>Decode()</code>。</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/gob&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修仙者</span></span><br><span class="line"><span class="keyword">type</span> Immortal <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Age    <span class="keyword">int</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SimpleImmortal <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Age    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf  bytes.Buffer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hanli = Immortal&#123;</span><br><span class="line">Name:   <span class="string">&quot;韩立&quot;</span>,</span><br><span class="line">Age:    <span class="number">18</span>,</span><br><span class="line">Gender: <span class="string">&quot;男性&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;发送数据: &quot;</span>,hanli)</span><br><span class="line">sendMsg(&amp;hanli)</span><br><span class="line">fmt.Println(<span class="string">&quot;buf中的数据：&quot;</span>,buf)</span><br><span class="line"><span class="keyword">var</span> i SimpleImmortal</span><br><span class="line">msg, _ := receiveMsg(i)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;接收到数据：&quot;</span>,msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendMsg</span><span class="params">(immortal *Immortal)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">enc :=gob.NewEncoder(&amp;buf)</span><br><span class="line"><span class="keyword">return</span> enc.Encode(immortal)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receiveMsg</span><span class="params">(immortal SimpleImmortal)</span> <span class="params">(SimpleImmortal,error)</span></span> &#123;</span><br><span class="line">dec := gob.NewDecoder(&amp;buf)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> immortal,dec.Decode(&amp;immortal)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">发送数据:  &#123;韩立 <span class="number">18</span> 男性&#125;</span><br><span class="line">buf中的数据： &#123;[<span class="number">50</span> <span class="number">255</span> <span class="number">129</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span> <span class="number">8</span> <span class="number">73</span> <span class="number">109</span> <span class="number">109</span> <span class="number">111</span> <span class="number">114</span> <span class="number">116</span> <span class="number">97</span> <span class="number">108</span> <span class="number">1</span> <span class="number">255</span> <span class="number">130</span> <span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">78</span> <span class="number">97</span> <span class="number">109</span> <span class="number">101</span> <span class="number">1</span> <span class="number">12</span> <span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">65</span> <span class="number">103</span> <span class="number">101</span> <span class="number">1</span> <span class="number">4</span> <span class="number">0</span> <span class="number">1</span> <span class="number">6</span> <span class="number">71</span> <span class="number">101</span> <span class="number">110</span> <span class="number">100</span> <span class="number">101</span> <span class="number">114</span> <span class="number">1</span> <span class="number">12</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">21</span> <span class="number">255</span> <span class="number">130</span> <span class="number">1</span> <span class="number">6</span> <span class="number">233</span> <span class="number">159</span> <span class="number">169</span> <span class="number">231</span> <span class="number">171</span> <span class="number">139</span> <span class="number">1</span> <span class="number">36</span> <span class="number">1</span> <span class="number">6</span> <span class="number">231</span> <span class="number">148</span> <span class="number">183</span> <span class="number">230</span> <span class="number">128</span> <span class="number">167</span> <span class="number">0</span>] <span class="number">0</span> <span class="number">0</span>&#125;</span><br><span class="line">接收到数据： &#123;韩立 <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>关于Gob的内容我们就简单介绍到这里。本文当中涉及到的例子可以<a href="https://github.com/code81192/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p><p>在下一篇文章当中，我们将一起来学习Golang当中的错误处理相关的内容。</p>]]></content:encoded>
      
      
      
      <category domain="https://bingfenglai.github.io/tags/golang/">golang</category>
      
      
      <comments>https://bingfenglai.github.io/2021/10/01/golang/13_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E4%B9%8BGob/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Golang中的读写数据（下）--JSON数据的编码与解码</title>
      <link>https://bingfenglai.github.io/2021/09/29/golang/12_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%8B%EF%BC%89/</link>
      <guid>https://bingfenglai.github.io/2021/09/29/golang/12_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%8B%EF%BC%89/</guid>
      <pubDate>Tue, 28 Sep 2021 16:33:22 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/code81192/art-demo/master/art-img/woman-5590119_1920.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在上一篇文章&lt;a href=&quot;https://bingfenglai.github.io/2021/09/28/golang/11_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%AD%EF%BC%89/&quot;&gt;《Golang中的读写数据（中）》&lt;/a&gt;中，我们学习了在Golang中如何读取命令行参数，接下来我们将学习Golang中的数据格式化。&lt;/p&gt;
&lt;p&gt;我们都知道数据要在网络当中进行传输，或者是将其保存到文件当中，就要必须对其编码和解码。常见的编码格式有JSON和XML等。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/woman-5590119_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在上一篇文章<a href="https://bingfenglai.github.io/2021/09/28/golang/11_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%AD%EF%BC%89/">《Golang中的读写数据（中）》</a>中，我们学习了在Golang中如何读取命令行参数，接下来我们将学习Golang中的数据格式化。</p><p>我们都知道数据要在网络当中进行传输，或者是将其保存到文件当中，就要必须对其编码和解码。常见的编码格式有JSON和XML等。</p><span id="more"></span><h3 id="一些概念的补充"><a href="#一些概念的补充" class="headerlink" title="一些概念的补充"></a>一些概念的补充</h3><p><strong>编码：</strong> 从特定数据结构到数据流这一过程</p><p><strong>解码：</strong> 解码是编码的逆过程，即从数据流到数据结构这一过程</p><p><strong>序列化：</strong> 将内存当中的数据抓换成指定的格式的过程，例如将一个Java对象转为一个字符串</p><p>接下来我们将介绍在Golang中将数据编码为JSON的相关内容，在这一部分内容当中，我们将使用到<code>encoding</code>这个库</p><h2 id="JSON数据操作"><a href="#JSON数据操作" class="headerlink" title="JSON数据操作"></a>JSON数据操作</h2><p>为了演示这一部分的内容，我将之前我们学习结构体时用到的结构体抄写在下面</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修仙者</span></span><br><span class="line"><span class="keyword">type</span> Immortal <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Age    <span class="keyword">int</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后大家请看下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修仙者</span></span><br><span class="line"><span class="keyword">type</span> Immortal <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Age    <span class="keyword">int</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">immortal := &amp;Immortal&#123;</span><br><span class="line">Name:   <span class="string">&quot;韩立&quot;</span>,</span><br><span class="line">Age:    <span class="number">18</span>,</span><br><span class="line">Gender: <span class="string">&quot;男性&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将修仙者韩立编码为json的[]byte</span></span><br><span class="line">jsonByteImmortal, _ := json.Marshal(immortal)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, jsonByteImmortal)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;Name&quot;</span>:<span class="string">&quot;韩立&quot;</span>,<span class="attr">&quot;Age&quot;</span>:<span class="number">18</span>,<span class="attr">&quot;Gender&quot;</span>:<span class="string">&quot;男性&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>上面用到的<code>json.Marshal</code>函数的函数签名是<code>func Marshal(v interface&#123;&#125;) ([]byte, error)</code> 它返回的是byte数组，因此打印时需要指定格式。</p><p>JSON 与 Go 类型对应如下：</p><ul><li>bool 对应 JSON 的 boolean</li><li>float64 对应 JSON 的 number</li><li>string 对应 JSON 的 string</li><li>nil 对应 JSON 的 null</li></ul><p>不是所有的数据都可以编码为 JSON 类型：只有验证通过的数据结构才能被编码：</p><ul><li>JSON 对象只支持字符串类型的 key；要编码一个 Go map 类型，map 必须是 map[string]T（T是 <code>json</code> 包中支持的任何类型）</li><li>Channel，复杂类型和函数类型不能被编码</li><li>不支持循环数据结构；它将引起序列化进入一个无限循环</li><li>指针可以被编码，实际上是对指针指向的值进行编码（或者指针是 nil）</li></ul><h2 id="反序列化操作"><a href="#反序列化操作" class="headerlink" title="反序列化操作"></a>反序列化操作</h2><p>在Golang中如何将一个JSON转换为Golang中的数据结构呢？</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修仙者</span></span><br><span class="line"><span class="keyword">type</span> Immortal <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Age    <span class="keyword">int</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">immortal := &amp;Immortal&#123;</span><br><span class="line">Name:   <span class="string">&quot;韩立&quot;</span>,</span><br><span class="line">Age:    <span class="number">18</span>,</span><br><span class="line">Gender: <span class="string">&quot;男性&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonImmortal, _ := json.Marshal(immortal)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, jsonImmortal)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 事先知道json对应的数据类型时</span></span><br><span class="line"> <span class="keyword">var</span> jsonValue Immortal</span><br><span class="line"></span><br><span class="line">json.Unmarshal(jsonImmortal, &amp;jsonValue)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;name&quot;</span>,jsonValue.Name)</span><br><span class="line">fmt.Println(<span class="string">&quot;age&quot;</span>,jsonValue.Age)</span><br><span class="line">fmt.Println(<span class="string">&quot;gender&quot;</span>,jsonValue.Gender)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 不知道json对应的数据结构</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">json.Unmarshal(jsonImmortal,&amp;m)</span><br><span class="line"></span><br><span class="line">jsonMap := m.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> jsonMap &#123;</span><br><span class="line">printJson(key,value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printJson</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> value.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">fmt.Println(key,<span class="string">&quot;value is a string: &quot;</span>,value)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">fmt.Println(key,<span class="string">&quot;value is int type: &quot;</span>,value)</span><br><span class="line"><span class="keyword">case</span> []<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">fmt.Println(key,<span class="string">&quot;value is a array&quot;</span>,value)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">m:= value.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">printJson(k,v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;Name&quot;:&quot;韩立&quot;,&quot;Age&quot;:18,&quot;Gender&quot;:&quot;男性&quot;&#125;</span><br><span class="line">name 韩立</span><br><span class="line">age 18</span><br><span class="line">gender 男性</span><br><span class="line">Name value is a string:  韩立</span><br><span class="line">Age value is int type:  18</span><br><span class="line">Gender value is a string:  男性</span><br></pre></td></tr></table></figure><p>在这个例子当中，存在着两种情况：</p><p>第一种情况：<strong>我们事先知道JSON数据对应的数据结构</strong>，则调用<code>json.Unmarshal</code>函数将其解码（也可以理解为反序列化）并存入该数据结构指针变量指向的内存地址当中；</p><p>第二种情况：<strong>我们事先不知道JSON数据对应的数据结构</strong>，则可以使用<strong>类型断言</strong>技术得到JSON数据当中<code>key: value</code>对应的值。</p><h2 id="解码以及编码JSON数据流"><a href="#解码以及编码JSON数据流" class="headerlink" title="解码以及编码JSON数据流"></a>解码以及编码JSON数据流</h2><p>json 包提供 Decoder 和 Encoder 类型来支持常用 JSON 数据流读写。NewDecoder 和 NewEncoder 函数分别封装了 io.Reader 和 io.Writer 接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDecoder</span><span class="params">(r io.Reader)</span> *<span class="title">Decoderfunc</span> <span class="title">NewEncoder</span><span class="params">(w io.Writer)</span> *<span class="title">Encoder</span></span></span><br></pre></td></tr></table></figure><p>要想把 JSON 直接写入文件，可以使用 json.NewEncoder 初始化文件（或者任何实现 io.Writer 的类型），并调用 Encode()；反过来与其对应的是使用 json.NewDecoder 和 Decode() 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDecoder</span><span class="params">(r io.Reader)</span> *<span class="title">Decoderfunc</span> <span class="params">(dec *Decoder)</span> <span class="title">Decode</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>在Golang中解析转换JSON数据的内容我们就简单介绍到这里。本文当中涉及到的例子可以<a href="https://github.com/code81192/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p><p>在下一篇文章当中，我们将一起来学习Golang当中一种独有的编码格式<code>Gob</code> </p>]]></content:encoded>
      
      
      
      <category domain="https://bingfenglai.github.io/tags/golang/">golang</category>
      
      
      <comments>https://bingfenglai.github.io/2021/09/29/golang/12_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%8B%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Golang中的读写数据（中）</title>
      <link>https://bingfenglai.github.io/2021/09/28/golang/11_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%AD%EF%BC%89/</link>
      <guid>https://bingfenglai.github.io/2021/09/28/golang/11_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%AD%EF%BC%89/</guid>
      <pubDate>Mon, 27 Sep 2021 16:36:11 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/code81192/art-demo/master/art-img/yoga-2176668_1920.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在上一篇文章《&lt;a href=&quot;https://bingfenglai.github.io/2021/09/24/golang/10_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE(%E4%B8%8A)/&quot;&gt;Golang中的读写数据（上）&lt;/a&gt;》当中，我们介绍了Golang中一些简单的文件读写、拷贝操作，接下来，我们将继续学习Golang中的读写数据的相关知识点。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/yoga-2176668_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在上一篇文章《<a href="https://bingfenglai.github.io/2021/09/24/golang/10_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE(%E4%B8%8A)/">Golang中的读写数据（上）</a>》当中，我们介绍了Golang中一些简单的文件读写、拷贝操作，接下来，我们将继续学习Golang中的读写数据的相关知识点。</p><span id="more"></span><h2 id="从命令行读取参数"><a href="#从命令行读取参数" class="headerlink" title="从命令行读取参数"></a>从命令行读取参数</h2><p>在一些场景当中，我们在执行一个软件，有时候需要传入一些初始化的信息，例如连接数据库的<code>username</code>和<code>password</code>等属性。那么，在Golang中是如何读取参数的呢？请看下面的例子:</p><h3 id="使用os-Args-获取参数"><a href="#使用os-Args-获取参数" class="headerlink" title="使用os.Args 获取参数"></a>使用<code>os.Args</code> 获取参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(os.Args);i++ &#123;</span><br><span class="line">sayHello(os.Args[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;参数为空&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(name... <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;hello!&quot;</span>,name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/image-20210927204103589.png" alt="image-20210927204103589"></p><p><strong>注意：</strong></p><p>这个命令行参数会放置在切片 <code>os.Args[]</code> 中（以空格分隔），从索引1开始（<code>os.Args[0]</code> 放的是程序本身的名字）。函数 <code>strings.Join</code> 以空格为间隔连接这些参数。</p><h3 id="使用flag-Args获取参数"><a href="#使用flag-Args获取参数" class="headerlink" title="使用flag.Args获取参数"></a>使用<code>flag.Args</code>获取参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, arg := <span class="keyword">range</span> flag.Args() &#123;</span><br><span class="line">sayHello(arg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(name... <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;hello!&quot;</span>,name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/image-20210927224440371.png" alt="image-20210927224440371"></p><p><strong>注意：</strong></p><p><code>flag.Arg(0)</code> 就是第一个真实的 flag，而不是像 <code>os.Args(0)</code> 放置程序的名字。</p><h3 id="一个例子：使用缓存读取文件与flag-Args的综合应用"><a href="#一个例子：使用缓存读取文件与flag-Args的综合应用" class="headerlink" title="一个例子：使用缓存读取文件与flag.Args的综合应用"></a>一个例子：使用缓存读取文件与<code>flag.Args</code>的综合应用</h3><p>接触过Linux系统的小伙伴们应该经常会<code>cat filename</code>这个命令，接下来，我们将使用Golang实现这个小工具.</p><h4 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h4><p>我们需要一个小工具来打印文件的内容，当文件不存在时给用户一个友好的提示。</p><h4 id="功能设计"><a href="#功能设计" class="headerlink" title="功能设计"></a>功能设计</h4><ol><li>根据用户输入的文件名读取文件到缓存并分批次打印</li><li>当文件不存在时输出”不存在文件 {文件名}”</li></ol><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">filename :=flag.Arg(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> filename==<span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Command Usage Format: mycat filename&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">open, err := os.Open(filename)</span><br><span class="line"><span class="keyword">defer</span> open.Close()</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">myCat(bufio.NewReader(open))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myCat</span><span class="params">(reader *bufio.Reader)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  &#123;</span><br><span class="line">buf, err := reader.ReadBytes(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">fmt.Fprintf(os.Stdout, <span class="string">&quot;%s\n&quot;</span>, buf)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><ol><li>当文件存在时打印文件内容：</li></ol><p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/image-20210927231646066.png" alt="image-20210927231646066"></p><ol start="2"><li>当文件不存在时给出提示：</li></ol><p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/image-20210927231918164.png" alt="image-20210927231918164"></p><h4 id="提个问题：这个程序能满足需求吗？"><a href="#提个问题：这个程序能满足需求吗？" class="headerlink" title="提个问题：这个程序能满足需求吗？"></a>提个问题：这个程序能满足需求吗？</h4><p>大家可以思考一下，如果被打印的文件是一个只有一行数据的大文件，会出现什么情况？</p><p>因此，为了避免出现这个情况，我们将对<code>mycat</code>进行改造。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">filename :=flag.Arg(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> filename==<span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Command Usage Format: mycat filename&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file, err := os.Open(filename)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myCatV2(bufio.NewReader(file))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myCatV2</span><span class="params">(reader *bufio.Reader)</span></span> &#123;</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">512</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  &#123;</span><br><span class="line">n, err := reader.Read(buf)</span><br><span class="line">fmt.Fprintf(os.Stdout,<span class="string">&quot;%s&quot;</span>,buf[<span class="number">0</span>:n])</span><br><span class="line"><span class="keyword">if</span> err ==io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这一版当中，我们指定了缓存区的大小，它是一个512位的<code>byte</code>数组。</p><p>输出：</p><p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/image-20210928002030354.png" alt="image-20210928002030354"></p><p>我们指定了缓冲区的大小，这样就避免了将整个文件都加载到内存当中。</p><p>当然，大家可以继续对程序进行改进，例如引入协程等技术，这便不在本文的讨论当中了。</p><h2 id="重要的一点：使用defer关闭文件"><a href="#重要的一点：使用defer关闭文件" class="headerlink" title="重要的一点：使用defer关闭文件"></a>重要的一点：使用<code>defer</code>关闭文件</h2><p>在前面的文章当中，我们介绍了<code>defer</code>关键字的作用：他将在函数退出时（return之后）执行其修饰的语句。在这里，我们使用其来在<code>main</code>函数退出前关闭文件。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>关于Golang中读取命令行参数以及与文件读写操作的综合应用我们就介绍到这里。本文当中涉及到的例子可以<a href="https://github.com/code81192/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p><p>在下一篇文章当中我们将一起来学习Golang中的数据格式化以及数据网络传输等内容。</p>]]></content:encoded>
      
      
      
      <category domain="https://bingfenglai.github.io/tags/golang/">golang</category>
      
      
      <comments>https://bingfenglai.github.io/2021/09/28/golang/11_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%AD%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>golang中的读写数据（上）</title>
      <link>https://bingfenglai.github.io/2021/09/24/golang/10_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE(%E4%B8%8A)/</link>
      <guid>https://bingfenglai.github.io/2021/09/24/golang/10_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE(%E4%B8%8A)/</guid>
      <pubDate>Fri, 24 Sep 2021 15:34:08 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/code81192/art-demo/master/art-img/spring-2298279_1920.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在前面的文章当中，我们学会了如何去搭建Golang开发环境、学习了Golang当中常见的数据结构、学习了基本流程控制语句、学习了函数和结构体等内容，接下来我们将开始学习Golang当中的文件读写。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/spring-2298279_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在前面的文章当中，我们学会了如何去搭建Golang开发环境、学习了Golang当中常见的数据结构、学习了基本流程控制语句、学习了函数和结构体等内容，接下来我们将开始学习Golang当中的文件读写。</p><span id="more"></span><h2 id="读取用户在控制台的输入"><a href="#读取用户在控制台的输入" class="headerlink" title="读取用户在控制台的输入"></a>读取用户在控制台的输入</h2><p>在Golang当中，如何读取用户在控制台的输入呢？在这里，我们可以使用<code>fmt</code>包当中<code>Scan</code>开头的函数。</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> firstname,lastname <span class="keyword">string</span></span><br><span class="line">fmt.Println(<span class="string">&quot;请输入您的姓名：&quot;</span>)</span><br><span class="line">_, _ = fmt.Scanln(&amp;firstname, &amp;lastname)</span><br><span class="line">fmt.Printf(<span class="string">&quot;你好！%s · %s\n&quot;</span>, lastname, firstname)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请输入您的姓名：</span><br><span class="line">韩 立</span><br><span class="line">你好！立 · 韩</span><br></pre></td></tr></table></figure><p><code>Scanln</code> 扫描来自标准输入的文本，将空格分隔的值依次存放到后续的参数内，直到碰到换行。<code>Scanf</code> 与其类似，除了 <code>Scanf</code> 的第一个参数用作格式字符串，用来决定如何读取。<code>Sscan</code> 和以 <code>Sscan</code> 开头的函数则是从字符串读取，除此之外，与 <code>Scanf</code> 相同。如果这些函数读取到的结果与您预想的不同，你可以检查成功读入数据的个数和返回的错误。</p><p>除此之外，我们也可以使用 <code>bufio</code> 包提供的缓冲读取（buffered reader）来读取数据</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;请输入一段文字&quot;</span>)</span><br><span class="line">inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line">s,err := inputReader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;你输入的是：&quot;</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请输入一段文字</span><br><span class="line">去年今日此门中 人面桃花相映红。人面不知何处在 桃花依旧笑春风。</span><br><span class="line">你输入的是：</span><br><span class="line">去年今日此门中 人面桃花相映红。人面不知何处在 桃花依旧笑春风。</span><br></pre></td></tr></table></figure><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id="文件读操作"><a href="#文件读操作" class="headerlink" title="文件读操作"></a>文件读操作</h3><p>在 Go 语言中，文件使用指向 <code>os.File</code> 类型的指针来表示的，也叫做文件句柄。</p><h4 id="按行读取"><a href="#按行读取" class="headerlink" title="按行读取"></a>按行读取</h4><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">inputFile, err := os.Open(<span class="string">&quot;G:\\06_golangProject\\golang\\doc\\筑基部分\\10_golang中的读写数据.md&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> inputFile.Close()</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">input :=bufio.NewReader(inputFile)</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">readString, err := input.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">fmt.Println(readString)</span><br><span class="line"><span class="keyword">if</span> err==io.EOF &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子当中，我们使用<code>os.Open</code>打开一个文件，并在循环当中逐行地打印该文件，直到打印完该文件。</p><h4 id="带缓冲的文件读取"><a href="#带缓冲的文件读取" class="headerlink" title="带缓冲的文件读取"></a>带缓冲的文件读取</h4><p>很不幸的是，在很多情况下，文件的内容不是按行划分的，甚至有时候文件是一个二进制文件。这时，我们应当如何去读取它呢？</p><p>请看下面的这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">inputFile, err := os.Open(<span class="string">&quot;G:\\06_golangProject\\golang\\doc\\筑基部分\\10_golang中的读写数据.md&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> inputFile.Close()</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>  &#123;</span><br><span class="line">_, err := inputFile.Read(buf)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err==io.EOF &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(buf))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义了一个<code>[]byte</code>类型的缓存，在读取文件时，将读到的内容存入这个缓存中并进行打印。这样，我们就不需要去在意文件当中内容是如何划分的了。</p><h3 id="文件写操作"><a href="#文件写操作" class="headerlink" title="文件写操作"></a>文件写操作</h3><p>简单地介绍了Golang中的文件读操作，再讲一下文件的写操作，请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">file, err := os.OpenFile(<span class="string">&quot;古丹丹方.txt&quot;</span>, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;打开文件出错&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span>  file.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个缓冲区</span></span><br><span class="line">writer := bufio.NewWriter(file)</span><br><span class="line"></span><br><span class="line">s := <span class="string">&quot;Hello World\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="comment">// 写入缓冲区</span></span><br><span class="line">_, _ = writer.WriteString(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将缓冲区的数据写入文件</span></span><br><span class="line">_ = writer.Flush()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来我们看一下这个<code>os.OpenFile(name string, flag int, perm FileMode) (*File, error)</code>函数。我们可以看到，它有三个参数，第一个参数为文件名，第二个参数是打开标志（我们以只写打开文件，如果文件不存在则创建它），第三个参数是文件权限。</p><p>对于第二个参数，当存在多个标志时使用逻辑运算符<code>|</code>连接，常见的标志有以下几个：</p><ul><li><code>os.O_RDONLY</code>：只读</li><li><code>os.O_WRONLY</code>：只写</li><li><code>os.O_CREATE</code>：创建：如果指定文件不存在，就创建该文件。</li><li><code>os.O_TRUNC</code>：截断：如果指定文件已存在，就将该文件的长度截为0。</li></ul><p>在读文件的时候，文件的权限是被忽略的，所以在使用 <code>OpenFile</code> 时传入的第三个参数可以用0。而在写文件时，不管是 Unix 还是 Windows，都需要使用 0666。</p><h2 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h2><p>不知还有道友记得没，韩立在筑基期的洞府里用两株草药换了他雷师伯的丹方，他雷师伯当然不会直接将古方给他，而是将丹方拷贝了一份到玉简给了韩立。</p><p>那么？在Golang中如何实现将文件<code>source.txt</code>拷贝到<code>target.txt</code>呢？请看下面的这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">copyFile(<span class="string">&quot;古丹丹方.txt&quot;</span>,<span class="string">&quot;给韩立的玉简.txt&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;拷贝完成！&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyFile</span><span class="params">(source, target <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">openFile, err := os.Open(source)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;打开源文件出错&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> openFile.Close()</span><br><span class="line"></span><br><span class="line">createFile, err := os.Create(target)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;创建目标文件出错&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> createFile.Close()</span><br><span class="line"></span><br><span class="line">written, err := io.Copy(createFile, openFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(written)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实看起来还是很简单的，直接使用<code>io.Copy</code>函数就OK了，但是要注意的是<strong>第一个参数是目标文件名，第二个参数才是源文件</strong>。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>以上就是Golang关于文件读写的上半部分内容，本文当中涉及到的例子可以<a href="https://github.com/code81192/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p><p>在下一篇文章当中我们将一起来学习Golang读取命令行参数和Golang中的数据网络传输等内容。</p>]]></content:encoded>
      
      
      
      <category domain="https://bingfenglai.github.io/tags/golang/">golang</category>
      
      
      <comments>https://bingfenglai.github.io/2021/09/24/golang/10_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE(%E4%B8%8A)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Golang入门学习之接口（interface）</title>
      <link>https://bingfenglai.github.io/2021/09/12/golang/09_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E6%8E%A5%E5%8F%A3/</link>
      <guid>https://bingfenglai.github.io/2021/09/12/golang/09_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E6%8E%A5%E5%8F%A3/</guid>
      <pubDate>Sun, 12 Sep 2021 11:26:45 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/code81192/art-demo/master/art-img/avenue-815297_1920.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在上一篇文章&lt;a href=&quot;https://bingfenglai.github.io/2021/09/09/golang/08_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E6%96%B9%E6%B3%95/&quot;&gt;《Golang入门学习之方法（method）》&lt;/a&gt;当中，我们学习了Golang当中的方法的定义与运用，在接下来的这篇文章当中，我们将一起来学习Goalng的接口（interface）。&lt;/p&gt;
&lt;h2 id=&quot;接口的定义&quot;&gt;&lt;a href=&quot;#接口的定义&quot; class=&quot;headerlink&quot; title=&quot;接口的定义&quot;&gt;&lt;/a&gt;接口的定义&lt;/h2&gt;&lt;p&gt;接口是定义了一组需要被实现的方法的&lt;strong&gt;抽象类型&lt;/strong&gt;，实现接口的数据类型可以视为接口的实例。接口由一组方法与一个接口类型组成。声明格式如下：&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/avenue-815297_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在上一篇文章<a href="https://bingfenglai.github.io/2021/09/09/golang/08_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E6%96%B9%E6%B3%95/">《Golang入门学习之方法（method）》</a>当中，我们学习了Golang当中的方法的定义与运用，在接下来的这篇文章当中，我们将一起来学习Goalng的接口（interface）。</p><h2 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h2><p>接口是定义了一组需要被实现的方法的<strong>抽象类型</strong>，实现接口的数据类型可以视为接口的实例。接口由一组方法与一个接口类型组成。声明格式如下：</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    方法名(形参列表) (返回值列表)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照Golang的编程风格（约定），只包含一个方法的接口的名字由方法名加 <code>[e]r</code> 后缀组成，例如 <code>Printer</code>、<code>Reader</code>、<code>Writer</code>、<code>Logger</code>、<code>Converter</code> 等等。还有一些不常用的方式（当后缀 <code>er</code> 不合适时），比如 <code>Recoverable</code>，此时接口名以 <code>able</code> 结尾，或者以 <code>I</code> 开头（像  <code>Java</code> 中那样）。</p><p>Go 语言中的接口都很简短，通常它们会包含 0 个、最多 3 个方法。</p><p>请看下面这个例子：</p><p>首先，我们在interfaces包中声明一个<code>SpiritualRootAble</code>（表示具备修行的能力,现了灵根接口的凡人即可修炼）接口</p><p><code>src/go_code/interface/interfaces/spiritual_root.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> interfaces</span><br><span class="line"></span><br><span class="line"><span class="comment">// 灵根接口，实现了灵根接口的凡人即可修炼</span></span><br><span class="line"><span class="keyword">type</span> SpiritualRootAble <span class="keyword">interface</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成灵根</span></span><br><span class="line">GenSpiritualRootNames() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取生成的灵根</span></span><br><span class="line">SpiritualRoot() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修行方法</span></span><br><span class="line">Practice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，我们在model包当中声明一个凡人结构体（<code>mortal</code>） 并实现<code>SpiritualRootAble</code>接口</p><p><code>src/go_code/interface/model/mortal.go</code> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/big&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 凡人</span></span><br><span class="line"><span class="keyword">type</span> Mortal <span class="keyword">struct</span> &#123;</span><br><span class="line">name ,</span><br><span class="line">gender ,</span><br><span class="line">spiritualRoot <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMortal</span><span class="params">(name, gender <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> <span class="title">Mortal</span></span> &#123;</span><br><span class="line">mortal:=Mortal&#123;</span><br><span class="line">name:   name,</span><br><span class="line">gender: gender,</span><br><span class="line">age:    age,</span><br><span class="line">&#125;</span><br><span class="line">mortal.spiritualRoot = mortal.GenSpiritualRootNames()</span><br><span class="line"><span class="keyword">return</span> mortal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv Mortal)</span> <span class="title">SpiritualRoot</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> &amp;recv.spiritualRoot == <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;没有灵根&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> recv.spiritualRoot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv Mortal)</span><span class="title">Practice</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(recv.name,<span class="string">&quot;开始修行...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv Mortal)</span> <span class="title">GenSpiritualRootNames</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">gsrn := []<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;金灵根&quot;</span>,<span class="string">&quot;水灵根&quot;</span>,<span class="string">&quot;木灵根&quot;</span>,<span class="string">&quot;火灵根&quot;</span>,<span class="string">&quot;土灵根&quot;</span>,<span class="string">&quot;没有灵根&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">index, _ := rand.Int(rand.Reader, big.NewInt(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  gsrn[index.Int64()]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，我们在main中使用他们</p><p><code>src/go_code/interface/main/main.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;go_code/interface/interfaces&quot;</span></span><br><span class="line"><span class="string">&quot;go_code/interface/model&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 声明了一个SpiritualRootAble接口类型的变量</span></span><br><span class="line"> <span class="keyword">var</span> sr interfaces.SpiritualRootAble</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 降生了一个凡人</span></span><br><span class="line"> mortal := model.NewMortal(<span class="string">&quot;韩立&quot;</span>,<span class="string">&quot;男性&quot;</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 接口变量指向凡人实例</span></span><br><span class="line">sr = mortal</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取凡人的灵根</span></span><br><span class="line">fmt.Println(sr.SpiritualRoot())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 凡人开始修炼</span></span><br><span class="line">sr.Practice()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">火灵根</span><br><span class="line">韩立 开始修行...</span><br></pre></td></tr></table></figure><p>可以看到：</p><p>在Golang中并需要显示地声明类型实现了某一接口（不需要如同Java那样<code>class implemments interfacesName</code>），只要类型实现了接口当中定义的方法集，类型即是实现了该接口。</p><p>实现某个接口的类型（除了实现接口方法外）可以有其他的方法。</p><p>一个类型可以实现多个接口(实际上<code>mortal</code>还实现了空接口，关于空接口的内容请继续往下看)。</p><p>接口类型可以包含一个实例的引用， 该实例的类型实现了此接口（接口是动态类型）。</p><h2 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h2><p>空接口即为不包含任何方法的接口。任何类型都实现了空接口。空接口有点类似于Java当中的Object的概念</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Any <span class="keyword">interface</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="接口嵌套接口"><a href="#接口嵌套接口" class="headerlink" title="接口嵌套接口"></a>接口嵌套接口</h2><p>一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。</p><p>比如接口 <code>File</code> 包含了 <code>ReadWrite</code> 和 <code>Lock</code> 的所有方法，它还额外有一个 <code>Close()</code> 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWrite <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(b Buffer) <span class="keyword">bool</span></span><br><span class="line">    Write(b Buffer) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Lock <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">interface</span> &#123;</span><br><span class="line">    ReadWrite</span><br><span class="line">    Lock</span><br><span class="line">    Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Golang中的类型断言"><a href="#Golang中的类型断言" class="headerlink" title="Golang中的类型断言"></a>Golang中的类型断言</h2><p>对于一个接口类型变量<code>varI</code>中可以包含任何类型的值，so,必须有一种方式来检测它的<strong>动态类型</strong>，也就是运行时变量var中存储的值的实际类型。而这，就是<strong>类型断言</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v := varI.(T)</span><br></pre></td></tr></table></figure><p>类型断言可能是无效的，虽然编译器会尽力检查转换是否有效，但是它不可能预见所有的可能性。如果转换在程序运行时失败会导致错误发生。更安全的方式是使用以下形式来进行类型断言：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v,ok :=varI.(T);ok&#123;</span><br><span class="line">    do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果转换合法，<code>v</code> 是 <code>varI</code> 转换到类型 <code>T</code> 的值，<code>ok</code> 会是 <code>true</code>；否则 <code>v</code> 是类型 <code>T</code> 的零值，<code>ok</code> 是 <code>false</code>，也没有运行时错误发生。</p><p>如果我们只是需要判断<code>varI</code>是否为T类型而不需要获取类型T的值时,可以这样做：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _,ok := varI.(T);ok&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们继续沿用上面的例子讲类型断言这部分的内容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;go_code/interface/interfaces&quot;</span></span><br><span class="line"><span class="string">&quot;go_code/interface/model&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 声明了一个SpiritualRootAble接口类型的变量</span></span><br><span class="line"> <span class="keyword">var</span> sr interfaces.SpiritualRootAble</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 降生了一个凡人</span></span><br><span class="line"> mortal := model.NewMortal(<span class="string">&quot;韩立&quot;</span>,<span class="string">&quot;男性&quot;</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 接口变量指向凡人实例</span></span><br><span class="line">sr = mortal</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型断言</span></span><br><span class="line"><span class="keyword">if</span> v,ok :=sr.(*model.Mortal);ok&#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;&#123;韩立 男性 金灵根 <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，我们在实现<code>SpiritualRootAble</code> 时方法的receiver类型为<code>*Mortal</code> ，即凡人的指针类型。因此实际上实现SpiritualRootAble接口的是*Mortal，因此在进行类型断言时T为<code>*Mortal</code> 。我们在使用类型断言的时候要注意这一点，不然编译器会报错。</p><h2 id="类型断言的应用"><a href="#类型断言的应用" class="headerlink" title="类型断言的应用"></a>类型断言的应用</h2><p>在Golang中，我们如何测试一个值是否实现了某一接口呢？答案就是通过类型断言</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m interfaceTypeName</span><br><span class="line"><span class="keyword">if</span> _,ok := m.(interfaceTypeName);ok &#123;</span><br><span class="line">fmt.Println(ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>接口可以理解为一种契约，实现类型必须满足它，它描述了类型的行为，规定类型可以做什么。接口彻底将类型能做什么，以及如何做分离开来，使得相同接口的变量在不同的时刻表现出不同的行为，这就是多态的本质。</p><p>在golang中：</p><ul><li>指针方法可以通过指针调用</li><li>值方法可以通过值调用</li><li>接收者是值的方法可以通过指针调用，因为指针会首先被解引用</li><li>接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址</li></ul><p>将一个值赋值给一个接口时，编译器会确保所有可能的接口方法都可以在此值上被调用，因此不正确的赋值在编译期就会失败。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>关于Golang当中接口的知识点我就简单介绍到这里。本文当中涉及到的例子可以<a href="https://github.com/code81192/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。从下一篇文章开始，我们将开启<strong>筑基系列</strong>的学习，具体涉及到的知识点有：反射、文件操作、数据交换、错误处理、Go协程（goroutine）和通道（channel）等内容。欢迎各位小伙伴订阅我的博客👊。</p>]]></content:encoded>
      
      
      
      <category domain="https://bingfenglai.github.io/tags/golang/">golang</category>
      
      
      <comments>https://bingfenglai.github.io/2021/09/12/golang/09_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E6%8E%A5%E5%8F%A3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Golang入门学习之方法（method）</title>
      <link>https://bingfenglai.github.io/2021/09/09/golang/08_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E6%96%B9%E6%B3%95/</link>
      <guid>https://bingfenglai.github.io/2021/09/09/golang/08_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E6%96%B9%E6%B3%95/</guid>
      <pubDate>Thu, 09 Sep 2021 15:40:56 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/code81192/art-demo/master/art-img/young-woman-1745173_1920.jpg&quot; alt=&quot;young-woman-1745173_1920&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在上一篇文章&lt;a href=&quot;https://bingfenglai.github.io/2021/09/07/golang/07_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E7%BB%93%E6%9E%84%E4%BD%93/&quot;&gt;《Golang入门学习之结构体（struct）》&lt;/a&gt;当中，我们学习了Golang当中结构体（struct）的知识点，接下来我们讲学习Golang当中的方法（method）。&lt;/p&gt;
&lt;h2 id=&quot;方法的定义&quot;&gt;&lt;a href=&quot;#方法的定义&quot; class=&quot;headerlink&quot; title=&quot;方法的定义&quot;&gt;&lt;/a&gt;方法的定义&lt;/h2&gt;&lt;p&gt;在Golang当中，方法是作用在接收者（receiver）上的一个函数，接收者是某种类型的变量。因此，方法是一种特殊的函数。这里的接收者可以（几乎，接收者类型不能是一个接口类型或指针类型）任何类型，不仅仅是结构体类型，也就意味着，几乎任何类型都可以方法，甚至是函数类型，或者是int、bool等的别名类型。&lt;/p&gt;
&lt;p&gt;我们可以这样理解：一个类型（比如说是结构体）加上它的方法就等价于面向对象语言当中的一个类。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/young-woman-1745173_1920.jpg" alt="young-woman-1745173_1920"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在上一篇文章<a href="https://bingfenglai.github.io/2021/09/07/golang/07_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E7%BB%93%E6%9E%84%E4%BD%93/">《Golang入门学习之结构体（struct）》</a>当中，我们学习了Golang当中结构体（struct）的知识点，接下来我们讲学习Golang当中的方法（method）。</p><h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><p>在Golang当中，方法是作用在接收者（receiver）上的一个函数，接收者是某种类型的变量。因此，方法是一种特殊的函数。这里的接收者可以（几乎，接收者类型不能是一个接口类型或指针类型）任何类型，不仅仅是结构体类型，也就意味着，几乎任何类型都可以方法，甚至是函数类型，或者是int、bool等的别名类型。</p><p>我们可以这样理解：一个类型（比如说是结构体）加上它的方法就等价于面向对象语言当中的一个类。</p><span id="more"></span><h3 id="方法的定义格式"><a href="#方法的定义格式" class="headerlink" title="方法的定义格式"></a>方法的定义格式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv receiver_type)</span> <span class="title">methodName</span><span class="params">(parameter_list)</span> <span class="params">(return_value_list)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p><code>recv</code> 就像是面向对象语言中的 <code>this</code> 或 <code>self</code>，但是 Golang 中并没有这两个关键字。随个人喜好，你可以使用 <code>this</code> 或 <code>self</code> 作为 receiver 的名字。</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>在 Golang 中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在在不同的源文件，唯一的要求是：它们必须是同一个包的。请看下面这个例子：</p><p>我们在<code>src/go_code/method/model/immortal.go</code> 当中定义了一个修仙者类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修仙者</span></span><br><span class="line"><span class="keyword">type</span> immortal <span class="keyword">struct</span> &#123;</span><br><span class="line">name   <span class="keyword">string</span></span><br><span class="line">age    <span class="keyword">int</span></span><br><span class="line">gender <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们在<code>src/go_code/method/model/immortal_method.go</code> 当中定义<code>immortal</code> 类型的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewImmortal</span><span class="params">(age <span class="keyword">int</span>, name, gender <span class="keyword">string</span>)</span> *<span class="title">immortal</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;immortal&#123;</span><br><span class="line">name:   name,</span><br><span class="line">age:    age,</span><br><span class="line">gender: gender,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Getter</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv *immortal)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> recv.name</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>再然后，我们再main包当中使用它</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;go_code/method/model&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := model.NewImmortal(<span class="number">18</span>,<span class="string">&quot;韩立&quot;</span>,<span class="string">&quot;男&quot;</span>)</span><br><span class="line">name :=i.GetName()</span><br><span class="line">fmt.Println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">韩立</span><br></pre></td></tr></table></figure><h2 id="函数与方法的区别"><a href="#函数与方法的区别" class="headerlink" title="函数与方法的区别"></a>函数与方法的区别</h2><p>函数和方法都是一段可复用的代码段。他们的区别在于函数是面向过程的，方法是面向对象。从调用上来看，函数通过函数名进行调用，而方法则通过与实例关联的变量进行调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"><span class="comment">// 方法调用</span></span><br><span class="line">immortal := model.NewImmortal(<span class="number">18</span>,<span class="string">&quot;韩立&quot;</span>,<span class="string">&quot;男&quot;</span>)</span><br><span class="line">immortal.GetName()</span><br></pre></td></tr></table></figure><p>再看Golang当中，方法由接收者类型、方法名、形参列表、返回值列表和方法体五部分构成，并且接收者必须有一个显式的名字，这个名字必须在方法中被使用。而且，接收者类型（receiver_type）必须在和方法同样的包中被声明。</p><h2 id="Golang中方法的其他特性"><a href="#Golang中方法的其他特性" class="headerlink" title="Golang中方法的其他特性"></a>Golang中方法的其他特性</h2><p>在Golang当中，接收者类型关联的方法不写在类型结构里面（面向对象语言Java的方法是在类当中进行定义的）。因此，在Golang当中方法与接收者类型的耦合更加地宽松，也就是说，数据（字段）与其对应的行为是相互独立。</p><h2 id="接收者类型可以是一个值而不是类型的指针吗？"><a href="#接收者类型可以是一个值而不是类型的指针吗？" class="headerlink" title="接收者类型可以是一个值而不是类型的指针吗？"></a>接收者类型可以是一个值而不是类型的指针吗？</h2><p>接收者类型可以是一个值而不是类型的指针吗？答案是可以的。但是，基于性能方面的考虑，我并不建议大家这样做。因为接收者是作为值传递给对应的方法的，这相当于将实例的值拷贝传递给方法，这并不是一件划算的买卖。请看下面的例子，接收者完全可以是实例的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修仙者等级</span></span><br><span class="line"><span class="keyword">type</span> Level <span class="keyword">struct</span> &#123;</span><br><span class="line">level      <span class="keyword">string</span></span><br><span class="line">levelValue <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取等级描述</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv Level)</span> <span class="title">GetLevel</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> recv.level</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span></span>&#123;</span><br><span class="line">    level := model.Level&#123;<span class="string">&quot;练气九层&quot;</span>,<span class="number">9200</span>&#125;</span><br><span class="line">fmt.Println(level.GetLevel())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">练气九层</span><br></pre></td></tr></table></figure><p>注意：</p><p><strong>指针方法和值方法都可以在指针或非指针上被调用</strong>。如下面程序所示，类型 <code>Level</code> 在值上有一个方法 <code>GetLevel()</code>，在指针上有一个方法 <code>SetLevel()</code>，但是可以看到两个方法都可以在两种类型的变量上被调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修仙者等级</span></span><br><span class="line"><span class="keyword">type</span> Level <span class="keyword">struct</span> &#123;</span><br><span class="line">level      <span class="keyword">string</span></span><br><span class="line">levelValue <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLevel</span><span class="params">(level <span class="keyword">string</span>, levelValue <span class="keyword">int</span>)</span> <span class="title">Level</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Level&#123;</span><br><span class="line">level:      level,</span><br><span class="line">levelValue: levelValue,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取等级描述</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv Level)</span> <span class="title">Level</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> recv.level</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv *Level)</span> <span class="title">SetLevel</span><span class="params">(level <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">recv.level = level</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;go_code/method/model&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">level := model.NewLevel(<span class="string">&quot;练气九层&quot;</span>,<span class="number">9200</span>)</span><br><span class="line">levelPointer := &amp; level</span><br><span class="line">fmt.Println(<span class="string">&quot;晋级之前：&quot;</span>,level.Level())</span><br><span class="line">levelPointer.SetLevel(<span class="string">&quot;炼气大圆满&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;晋级之后：&quot;</span>,level.Level())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">晋级之前： 练气九层</span><br><span class="line">晋级之后： 炼气大圆满</span><br></pre></td></tr></table></figure><h2 id="方法和未导出字段"><a href="#方法和未导出字段" class="headerlink" title="方法和未导出字段"></a>方法和未导出字段</h2><p>在上面的例子当中，<code>level</code>类型的字段对包外部而言是不可见的（可以理解为面向对象语言当中的<code>private</code>属性）。因此如果在<code>main</code>包当中直接通过选择器进行访问的话，将会报错。这是，我们可以通过面向对象语言一个众所周知的技术来完成：提供 getter 和 setter 方法。在Golang当中，对于 setter 方法使用 Set 前缀，对于 getter 方法只使用成员名。</p><h3 id="关于并发访问对象"><a href="#关于并发访问对象" class="headerlink" title="关于并发访问对象"></a>关于并发访问对象</h3><p>对象的字段（属性）不应该由 2 个或 2 个以上的不同线程在同一时间去改变。如果在程序发生这种情况，为了安全并发访问，可以使用包 <code>sync</code>中的方法(比如加个互斥锁)。但是这并不是一个推荐的选项（之后我们将会学习通过 goroutines 和 channels 去探索一种新的方式）。请看下面的例子</p><p><code>src/go_code/method/model/level_lock.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修仙者等级</span></span><br><span class="line"><span class="keyword">type</span> levelLock <span class="keyword">struct</span> &#123;</span><br><span class="line">Lock sync.Mutex</span><br><span class="line">level      <span class="keyword">string</span></span><br><span class="line">levelValue <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLevelLock</span><span class="params">(level <span class="keyword">string</span>, levelValue <span class="keyword">int</span>)</span> *<span class="title">levelLock</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;levelLock&#123;</span><br><span class="line">level:      level,</span><br><span class="line">levelValue: levelValue,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv *levelLock)</span> <span class="title">SetLevel</span><span class="params">(level <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">recv.level  = level</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>src/go_code/struct/main/level_lock.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;go_code/method/model&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">level := model.NewLevelLock(<span class="string">&quot;练气九层&quot;</span>,<span class="number">9200</span>)</span><br><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">level.Lock.Lock()</span><br><span class="line"><span class="comment">//修改值</span></span><br><span class="line">level.SetLevel(<span class="string">&quot;练气圆满&quot;</span>)</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">defer</span> level.Lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="内嵌类型的方法和继承"><a href="#内嵌类型的方法和继承" class="headerlink" title="内嵌类型的方法和继承"></a>内嵌类型的方法和继承</h2><p>当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌，这在效果上等同于外层类型 <strong>继承</strong> 了这些方法：<strong>将父类型放在子类型中来实现亚型</strong>。这个机制提供了一种简单的方式来模拟经典面向对象语言中的子类和继承相关的效果。因为一个结构体可以嵌入多个匿名类型，所以实际上我们可以有一个简单版本的<code>多重继承</code>。</p><p>在model包当中定义一个<code>immortal2</code> 类型，并让其内嵌一个匿名类型<code>level</code> </p><p><code>src/go_code/method/model/anonymous_type.go</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修仙者</span></span><br><span class="line"><span class="keyword">type</span> immortal2 <span class="keyword">struct</span> &#123;</span><br><span class="line">name   <span class="keyword">string</span></span><br><span class="line">age    <span class="keyword">int</span></span><br><span class="line">gender <span class="keyword">string</span></span><br><span class="line">Level</span><br><span class="line">lingGen</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewImmortal2</span><span class="params">(age <span class="keyword">int</span>, name, gender <span class="keyword">string</span>,levelName <span class="keyword">string</span>,levelValue <span class="keyword">int</span>,lingGenNames...<span class="keyword">string</span>)</span> *<span class="title">immortal2</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;immortal2&#123;</span><br><span class="line">name:   name,</span><br><span class="line">age:    age,</span><br><span class="line">gender: gender,</span><br><span class="line">Level:  Level&#123;levelName,levelValue&#125;,</span><br><span class="line">lingGen: lingGen&#123;linGenNames: lingGenNames&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>src/go_code/method/model/level.go</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修仙者等级</span></span><br><span class="line"><span class="keyword">type</span> Level <span class="keyword">struct</span> &#123;</span><br><span class="line">level      <span class="keyword">string</span></span><br><span class="line">levelValue <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLevel</span><span class="params">(level <span class="keyword">string</span>, levelValue <span class="keyword">int</span>)</span> <span class="title">Level</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Level&#123;</span><br><span class="line">level:      level,</span><br><span class="line">levelValue: levelValue,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取等级描述</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv Level)</span> <span class="title">Level</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> recv.level</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv *Level)</span> <span class="title">SetLevel</span><span class="params">(level <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">recv.level = level</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv *Level)</span> <span class="title">LevelName</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> recv.level</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>src/go_code/method/model/lingen.go</code>: </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修士的灵根</span></span><br><span class="line"><span class="keyword">type</span> lingGen <span class="keyword">struct</span> &#123;</span><br><span class="line">linGenNames[] <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLinggen</span><span class="params">(name ...<span class="keyword">string</span>)</span> *<span class="title">lingGen</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;lingGen&#123;linGenNames: name&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv *lingGen)</span> <span class="title">LingGenNames</span><span class="params">()</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> recv.linGenNames</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在main包当中导入并使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;go_code/method/model&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">im := model.NewImmortal2(<span class="number">18</span>,<span class="string">&quot;韩立&quot;</span>,<span class="string">&quot;男&quot;</span>,</span><br><span class="line"><span class="string">&quot;练气九层&quot;</span>,<span class="number">9200</span>,<span class="string">&quot;木灵根&quot;</span>,<span class="string">&quot;水灵根&quot;</span>,<span class="string">&quot;火灵根&quot;</span>,<span class="string">&quot;土灵根&quot;</span>)</span><br><span class="line">im.SetLevel(<span class="string">&quot;练气大圆满&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;境界：&quot;</span>,im.LevelName())</span><br><span class="line">fmt.Println(<span class="string">&quot;灵根：&quot;</span>,im.LingGenNames())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">境界： 练气大圆满</span><br><span class="line">灵根： [木灵根 水灵根 火灵根 土灵根]</span><br></pre></td></tr></table></figure><h2 id="Go-的类型和方法和其他面向对象语言对比"><a href="#Go-的类型和方法和其他面向对象语言对比" class="headerlink" title="Go 的类型和方法和其他面向对象语言对比"></a>Go 的类型和方法和其他面向对象语言对比</h2><p>在如 C++、Java、C# 和 Python这样的面向对象语言中，方法在类的上下文中被定义和继承：在一个对象上调用方法时，运行时会检测类以及它的超类中是否有此方法的定义，如果没有会导致异常发生。</p><p>在 Golang 中，这样的继承层次是完全没必要的：如果方法在此类型定义了，就可以调用它，和其他类型上是否存在这个方法没有关系。在这个意义上，Golang具有更大的灵活性。</p><p>Golang不需要一个显式的类定义，如同 Java和C++等那样，相反地，“类”是通过提供一组作用于一个共同类型的方法集加类型本身来隐式定义的。类型可以是结构体或者任何用户自定义类型。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在Golang中，类=类型+与之关联的方法集。</p><p>在 Golang 中，代码复用通过组合和委托实现，多态通过接口的使用来实现：有时这也叫 <strong>组件编程（Component Programming）</strong>。</p><p>相比于类继承，Go 的接口提供了更强大、却更简单的多态行为。</p><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>关于Golang中方法的学习就写到这了。本文当中涉及到的例子可以<a href="https://github.com/code81192/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p>]]></content:encoded>
      
      
      
      <category domain="https://bingfenglai.github.io/tags/golang/">golang</category>
      
      
      <comments>https://bingfenglai.github.io/2021/09/09/golang/08_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E6%96%B9%E6%B3%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>go语言入门学习之结构体（struct）</title>
      <link>https://bingfenglai.github.io/2021/09/07/golang/07_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E7%BB%93%E6%9E%84%E4%BD%93/</link>
      <guid>https://bingfenglai.github.io/2021/09/07/golang/07_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E7%BB%93%E6%9E%84%E4%BD%93/</guid>
      <pubDate>Tue, 07 Sep 2021 14:57:26 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/code81192/art-demo/master/art-img/girl-2366438_1920.jpg&quot; alt=&quot;girl-2366438_1920&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在上一文&lt;a href=&quot;https://bingfenglai.github.io/2021/09/05/golang/06_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E5%87%BD%E6%95%B0/&quot;&gt;《Golang入门学习之函数》&lt;/a&gt;当中，我们学习了Golang当中函数的用法。接下来，我们将一起来学习Golang的结构体。&lt;/p&gt;
&lt;h2 id=&quot;结构体的定义&quot;&gt;&lt;a href=&quot;#结构体的定义&quot; class=&quot;headerlink&quot; title=&quot;结构体的定义&quot;&gt;&lt;/a&gt;结构体的定义&lt;/h2&gt;&lt;p&gt;&lt;code&gt;结构体&lt;/code&gt;（struct）类似于其他面向对象当中类（class）的概念，但它和类有着明显的不同。结构体是&lt;code&gt;复合类型&lt;/code&gt;（composite types），它由一系列属性组成，这些属性对应着不同的值与类型。组成结构体类型的那些数据称为&lt;code&gt;字段&lt;/code&gt;(fields).&lt;/p&gt;
&lt;p&gt;Golang通过结构体的形式支持用户自定义类型，或者叫定制类型。&lt;/p&gt;
&lt;p&gt;定义方式：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; StructName &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	field1 type1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	field2 type2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;结构体的实例化&quot;&gt;&lt;a href=&quot;#结构体的实例化&quot; class=&quot;headerlink&quot; title=&quot;结构体的实例化&quot;&gt;&lt;/a&gt;结构体的实例化&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/girl-2366438_1920.jpg" alt="girl-2366438_1920"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在上一文<a href="https://bingfenglai.github.io/2021/09/05/golang/06_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E5%87%BD%E6%95%B0/">《Golang入门学习之函数》</a>当中，我们学习了Golang当中函数的用法。接下来，我们将一起来学习Golang的结构体。</p><h2 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h2><p><code>结构体</code>（struct）类似于其他面向对象当中类（class）的概念，但它和类有着明显的不同。结构体是<code>复合类型</code>（composite types），它由一系列属性组成，这些属性对应着不同的值与类型。组成结构体类型的那些数据称为<code>字段</code>(fields).</p><p>Golang通过结构体的形式支持用户自定义类型，或者叫定制类型。</p><p>定义方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StructName <span class="keyword">struct</span> &#123;</span><br><span class="line">field1 type1</span><br><span class="line">field2 type2</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体的实例化"><a href="#结构体的实例化" class="headerlink" title="结构体的实例化"></a>结构体的实例化</h2><span id="more"></span><h3 id="使用new"><a href="#使用new" class="headerlink" title="使用new()"></a>使用new()</h3><p>我们可以使用 <strong>new</strong> 函数给一个新的结构体变量分配内存，它返回指向已分配内存的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t *StructName</span><br><span class="line">t = <span class="built_in">new</span>(StructName)</span><br></pre></td></tr></table></figure><p>请看下面这个例子：</p><p>首先，我们在<code>go_code/struct/model</code>这个包当中，定义了一个结构体<code>Immortal</code>表示修仙者，并在<code>main</code>当中引入这个包，并使用<code>Immortal</code></p><p><code>go_code/struct/model/immortal.go</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修仙者</span></span><br><span class="line"><span class="keyword">type</span> Immortal <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;go_code/struct/model&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// i是指向model.Immortal结构体变量的指针</span></span><br><span class="line"><span class="keyword">var</span> i *model.Immortal</span><br><span class="line">i= <span class="built_in">new</span>(model.Immortal)</span><br><span class="line">i.Age = <span class="number">500</span></span><br><span class="line">i.Name = <span class="string">&quot;韩立&quot;</span></span><br><span class="line">i.Gender = <span class="string">&quot;男&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(i.Name, strconv.Itoa(i.Age)+<span class="string">&quot;岁&quot;</span>,i.Gender)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">韩立 500岁 男</span><br></pre></td></tr></table></figure><p>我们可以通过点符号获取结构体的值或给其赋值，点符号在Golang中称之为选择器符(selector-notation)。</p><h3 id="使用混合字面量语法"><a href="#使用混合字面量语法" class="headerlink" title="使用混合字面量语法"></a>使用混合字面量语法</h3><p>初始化一个结构体实例的更简短和惯用的方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i的类型是 *model.Immortal</span></span><br><span class="line"><span class="keyword">var</span> i =  &amp;model.Immortal&#123;<span class="string">&quot;南宫婉&quot;</span>,<span class="number">18</span>,<span class="string">&quot;女&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> i model.Immortal</span><br><span class="line">i := model.Immortal&#123;<span class="string">&quot;南宫婉&quot;</span>,<span class="number">18</span>,<span class="string">&quot;女&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>上面这两个例子当中的写法(<code>&amp;model.Immortal&#123;&quot;南宫婉&quot;,18,&quot;女&quot;&#125;</code> )称之为<code>混合字面量语法</code> （composite literal sysntax），这是一种简写，底层仍然会调用new函数。在这种写法当中，需要注意的一点是<strong>值的顺序必须按照字段顺序来写</strong>。表达式<code>new(Type)</code>和<code>&amp;Type()</code>是等价的。</p><h2 id="Golang中结构体的特点"><a href="#Golang中结构体的特点" class="headerlink" title="Golang中结构体的特点"></a>Golang中结构体的特点</h2><h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><p>Go 语言中，结构体和它所包含的数据在内存中是以连续块的形式存在的，即使结构体中嵌套有其他的结构体，这在性能上带来了很大的优势。</p><h3 id="递归结构体"><a href="#递归结构体" class="headerlink" title="递归结构体"></a>递归结构体</h3><p>结构体类型可以通过引用自身来定义。这在定义链表或二叉树的元素（通常叫节点）时特别有用，此时节点包含指向临近节点的链接（地址）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">data <span class="keyword">string</span></span><br><span class="line">next *Node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，data字段当中存储的是当前节点的数据，next是指向下一个节点的指针</p><h3 id="结构体的转换"><a href="#结构体的转换" class="headerlink" title="结构体的转换"></a>结构体的转换</h3><p>Go 中的类型转换遵循严格的规则。当为结构体定义了一个 <code>alias</code> 类型时，此结构体类型和它的 alias 类型都有相同的底层类型。</p><p>请看下面的这个例子：</p><p><code>number.go</code> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Number <span class="keyword">struct</span> &#123;</span><br><span class="line">Value <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>conversion.go</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;go_code/struct/model&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = myNumber&#123;Value: <span class="number">18.0</span>&#125;</span><br><span class="line">b := model.Number(a)</span><br><span class="line"><span class="built_in">println</span>(b.Value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myNumber model.Number</span><br></pre></td></tr></table></figure><h2 id="使用工厂方法创建结构体实例"><a href="#使用工厂方法创建结构体实例" class="headerlink" title="使用工厂方法创建结构体实例"></a>使用工厂方法创建结构体实例</h2><p>Golang不支持其他面向对象编程语言（例如Java）那样的构造方法。我们通常通过定义一个构造工厂方法用于创建结构体实例。</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修仙者</span></span><br><span class="line"><span class="keyword">type</span> Immortal <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewImmortal</span><span class="params">(age <span class="keyword">int</span>, name, gender <span class="keyword">string</span>)</span> *<span class="title">Immortal</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> age&lt;<span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;Immortal&#123;Name: name,Gender: name,Age: age&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于工厂方法的命名，我们一般以<code>New</code>或<code>new</code>开头，它返回一个指向结构体实例的指针</p><h3 id="如何强制使用工厂方法而不是直接new？"><a href="#如何强制使用工厂方法而不是直接new？" class="headerlink" title="如何强制使用工厂方法而不是直接new？"></a>如何强制使用工厂方法而不是直接new？</h3><p>在讲这个问题之前，需要给大家补充一个知识点，那就是Golang当中包的可见性规则：</p><p>在Golang中，当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）。</p><p>因此，为了达到我们的目的，我们需要这样去定义我们的结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> v2</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> immortal <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">gender <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewImmortal</span><span class="params">(age <span class="keyword">int</span>, name, gender <span class="keyword">string</span>)</span> *<span class="title">immortal</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;immortal&#123;</span><br><span class="line">name:   name,</span><br><span class="line">age:    age,</span><br><span class="line">gender: gender,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带标签的结构体"><a href="#带标签的结构体" class="headerlink" title="带标签的结构体"></a>带标签的结构体</h2><p>结构体中的字段除了有名字和类型外，还可以有一个可选的标签（tag）：它是一个附属于字段的字符串，可以是文档或其他的重要标记。标签的内容不可以在一般的编程中使用，只有包 <code>reflect</code> 能获取它。在gorm（一个Golng的orm框架，类似于Java当中的<code>mybatis</code>）当中使用tag标记字段，从而起到映射数据库表字段的作用。</p><p>请看下面这个例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tag</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Immortal <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span> <span class="string">&quot;休仙者的名字&quot;</span></span><br><span class="line">Age <span class="keyword">int</span> <span class="string">&quot;修仙者的年龄&quot;</span></span><br><span class="line">Gender <span class="keyword">string</span> <span class="string">&quot;修仙者的性别&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintTag</span><span class="params">(im Immortal, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">imm :=reflect.TypeOf(im)</span><br><span class="line">value :=imm.Field(i)</span><br><span class="line">fmt.Println(value.Tag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;go_code/struct/model/tag&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> immortal = tag.Immortal&#123;Name: <span class="string">&quot;南宫婉&quot;</span>, Age: <span class="number">18</span>, Gender: <span class="string">&quot;女&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++ &#123;</span><br><span class="line">tag.PrintTag(immortal,i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">休仙者的名字</span><br><span class="line">修仙者的年龄</span><br><span class="line">修仙者的性别</span><br></pre></td></tr></table></figure><h2 id="匿名字段和内嵌结构体"><a href="#匿名字段和内嵌结构体" class="headerlink" title="匿名字段和内嵌结构体"></a>匿名字段和内嵌结构体</h2><p>结构体可以包含一个或多个 <strong>匿名（或内嵌）字段</strong>，即这些字段没有显式的名字，只有字段的类型是必须的，此时类型就是字段的名字。匿名字段本身可以是一个结构体类型，即 <strong>结构体可以包含内嵌结构体</strong>。在Golang当中，通过组合来实现其他面向对象编程语言当中的继承。</p><p>请看下面的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> immortal <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 姓名</span></span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"><span class="comment">// 年龄</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line"><span class="comment">// 修仙境界</span></span><br><span class="line">level</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> level <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 境界名称</span></span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"><span class="comment">// 灵气值</span></span><br><span class="line"><span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> im = immortal&#123;</span><br><span class="line"><span class="keyword">string</span>: <span class="string">&quot;韩立&quot;</span>,</span><br><span class="line"><span class="keyword">int</span>:    <span class="number">500</span>,</span><br><span class="line">level:  level&#123;</span><br><span class="line"><span class="string">&quot;练气七层&quot;</span>,</span><br><span class="line"><span class="number">7800.0</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;======修仙者资料卡======&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;姓名：&quot;</span>,im.<span class="keyword">string</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;年龄：&quot;</span>,im.<span class="keyword">int</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;------境界信息---------&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;境界名称：&quot;</span>,im.level.<span class="keyword">string</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;境界灵气值：&quot;</span>,im.level.<span class="keyword">float32</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;------境界信息---------&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;======修仙者资料卡======&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">======修仙者资料卡======</span><br><span class="line">姓名： 韩立</span><br><span class="line">年龄： <span class="number">500</span></span><br><span class="line">------境界信息---------</span><br><span class="line">境界名称： 练气七层</span><br><span class="line">境界灵气值： <span class="number">7800</span></span><br><span class="line">------境界信息---------</span><br><span class="line">======修仙者资料卡======</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>关于Golang结构体的学习就写到这里，本文当中涉及到的例子可以<a href="https://github.com/code81192/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p>]]></content:encoded>
      
      
      
      <category domain="https://bingfenglai.github.io/tags/golang/">golang</category>
      
      
      <comments>https://bingfenglai.github.io/2021/09/07/golang/07_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E7%BB%93%E6%9E%84%E4%BD%93/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Golang入门学习之函数</title>
      <link>https://bingfenglai.github.io/2021/09/05/golang/06_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E5%87%BD%E6%95%B0/</link>
      <guid>https://bingfenglai.github.io/2021/09/05/golang/06_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E5%87%BD%E6%95%B0/</guid>
      <pubDate>Sun, 05 Sep 2021 05:44:43 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/code81192/art-demo/master/art-img/woman-6572974_1920.jpg&quot; alt=&quot;woman-6572974_1920&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Golang-中函数的定义&quot;&gt;&lt;a href=&quot;#Golang-中函数的定义&quot; class=&quot;headerlink&quot; title=&quot;Golang 中函数的定义&quot;&gt;&lt;/a&gt;Golang 中函数的定义&lt;/h2&gt;&lt;p&gt;在编程语言中，函数是一段可复用的代码段，它由函数名、参数和返回值三部分构成。在golang当中，函数分为自定义函数和系统函数两大类。自定义函数就是你自己写的函数，系统函数就是系统原有的函数。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; 函数名&lt;span class=&quot;params&quot;&gt;(形参列表)&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(返回值列表)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    函数体&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; 返回值列表&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;说明：&lt;/code&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/woman-6572974_1920.jpg" alt="woman-6572974_1920"></p><h2 id="Golang-中函数的定义"><a href="#Golang-中函数的定义" class="headerlink" title="Golang 中函数的定义"></a>Golang 中函数的定义</h2><p>在编程语言中，函数是一段可复用的代码段，它由函数名、参数和返回值三部分构成。在golang当中，函数分为自定义函数和系统函数两大类。自定义函数就是你自己写的函数，系统函数就是系统原有的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(形参列表)</span><span class="params">(返回值列表)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">    <span class="keyword">return</span> 返回值列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>说明：</code></p><span id="more"></span><p>a. 函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也称不能重名;</p><p>b. 形参列表：形参列表也就是参数，参数由参数变量和参数类型组成，多个参数之间使用<code>,</code>隔开;</p><p>c. 返回值：返回值由返回值类型及其变量组成，也可以只写返回值类型，存在多个返回值时必须使用<code>()</code>括起来，并在其中用<code>,</code>分隔</p><p>d. 函数体： 实现特定功能、业务逻辑的代码块。</p><p>顺嘴说一句，<code>函数</code>是面向过程的概念，在面向对象语言中，称之为<code>方法</code></p><h2 id="Golang中函数的调用"><a href="#Golang中函数的调用" class="headerlink" title="Golang中函数的调用"></a>Golang中函数的调用</h2><p>对于同一个包中的函数，我们可以使用<code>函数名(参数)</code>的形式调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sayHello(<span class="string">&quot;厉飞羽&quot;</span>)</span><br><span class="line">s := getPhoneByName(<span class="string">&quot;南宫婉&quot;</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;你好！&quot;</span>,name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getPhoneByName</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> name+<span class="string">&quot; 的手机号是 &quot;</span> + <span class="string">&quot;120-6379-3306&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你好！ 厉飞羽</span><br><span class="line">南宫婉 的手机号是 <span class="number">120</span><span class="number">-6379</span><span class="number">-3306</span></span><br></pre></td></tr></table></figure><p>在不同包中，我们可以通过<code>包名.方法名()</code>来调用函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> myMath</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(number ...<span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> number &#123;</span><br><span class="line">sum = sum + num</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;go_code/function/myMath&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sum := myMath.Add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="参数进阶用法"><a href="#参数进阶用法" class="headerlink" title="参数进阶用法"></a>参数进阶用法</h2><h3 id="类型简写"><a href="#类型简写" class="headerlink" title="类型简写"></a>类型简写</h3><p>Golang中，对于相邻的参数，如果其类型相同，可以简写</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello2</span><span class="params">(name1 ,name2 <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;你们好！&quot;</span>,name1,name2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sayHello2(<span class="string">&quot;厉飞羽&quot;</span>,<span class="string">&quot;韩立&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你们好！ 厉飞羽 韩立</span><br></pre></td></tr></table></figure><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数是指函数的参数数量不固定。Golang中的可变参数通过在参数名后加<code>...</code>来标识。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello3</span><span class="params">(name ...<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, s := <span class="keyword">range</span> name &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;你好！&quot;</span>,s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sayHello3(<span class="string">&quot;厉飞羽&quot;</span>,<span class="string">&quot;韩立&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你好！ 厉飞羽</span><br><span class="line">你好！ 韩立</span><br></pre></td></tr></table></figure><h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>在golang中，函数的返回值可以有多个。通过<code>return</code> 关键字返回数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getPhoneByName</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> name+<span class="string">&quot; 的手机号是 &quot;</span> + <span class="string">&quot;120-6379-3306&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getPhoneByName2</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(str <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">str = name+<span class="string">&quot; 的手机号是 &quot;</span> + <span class="string">&quot;120-6379-3306&quot;</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">s1 := getPhoneByName(<span class="string">&quot;南宫婉&quot;</span>)</span><br><span class="line">fmt.Println(s1)</span><br><span class="line">s2 := getPhoneByName2(<span class="string">&quot;南宫婉&quot;</span>)</span><br><span class="line">fmt.Println(s2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">南宫婉 的手机号是 120-6379-3306</span><br><span class="line">南宫婉 的手机号是 120-6379-3306</span><br></pre></td></tr></table></figure><p>说明：</p><p>在Golang当中。对于返回值，函数定义时可以给返回值命名，并可以直接<code>return</code> </p><h2 id="将函数作为参数"><a href="#将函数作为参数" class="headerlink" title="将函数作为参数"></a>将函数作为参数</h2><p>在Golang当中，函数可以作为参数去传递，然后在其他函数内调用执行，这一般称之为回调。请看下面的这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">name := <span class="string">&quot;喜小乐&quot;</span></span><br><span class="line">sayHello(name,callback)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callback</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello &quot;</span>,name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(name <span class="keyword">string</span>,f <span class="keyword">func</span>(name <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;我是&quot;</span>,name)</span><br><span class="line">f(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我是 喜小乐</span><br><span class="line">hello  喜小乐</span><br></pre></td></tr></table></figure><h2 id="defer关键词"><a href="#defer关键词" class="headerlink" title="defer关键词"></a>defer关键词</h2><p><code>defer</code> 关键词允许我们推迟到函数返回之前（或任意位置执行<code>return</code> 语句之后）一刻才执行某个语句或函数。</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sayHello(<span class="string">&quot;南宫婉&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;before&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fun1()</span><br><span class="line">fmt.Println(<span class="string">&quot;after&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before</span><br><span class="line">after</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p><code>defer</code> 关键词的用法类似于Java语言当中的<code>finally</code> 关键词，它经常用来释放某些已分配的资源。例如释放锁操作、关闭数据库连接等等。</p><h2 id="匿名函数与闭包"><a href="#匿名函数与闭包" class="headerlink" title="匿名函数与闭包"></a>匿名函数与闭包</h2><p>当我们不想给函数命名的时候，我们可以使用匿名函数（可以理解为没有名字的函数），也称之为闭包。在Golang当中，匿名函数是不能单独存在的，你必须将其赋值给某一变量（将函数的地址保存在变量当中），然后通过变量名对函数进行调用。请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fun := <span class="function"><span class="keyword">func</span> <span class="params">(name <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello&quot;</span>,name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun(<span class="string">&quot;向北&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello 向北</span><br></pre></td></tr></table></figure><h2 id="闭包的应用：将函数作为返回值"><a href="#闭包的应用：将函数作为返回值" class="headerlink" title="闭包的应用：将函数作为返回值"></a>闭包的应用：将函数作为返回值</h2><p>在前面我们讲到，函数可以作为它可以参数进行传递，同样，函数还可以作为返回值。请看下面的例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">getPhone := sayHello(<span class="string">&quot;厉飞羽&quot;</span>)</span><br><span class="line"></span><br><span class="line">getPhone()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;你好！&quot;</span>,name)</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;我的手机号是： 131****3901&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你好！ 厉飞羽</span><br><span class="line">我的手机号是： 131****3901</span><br></pre></td></tr></table></figure><p>在Golang中，一个返回值为另一个函数的函数可以被称之为<em>工厂函数</em> ，例如上方例子当中的<code>sayHello</code> . 可以返回其它函数的函数和接受其它函数作为参数的函数均被称之为<code>高阶函数</code>，是函数式语言的特点。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>关于Golang的函数部分学习就暂时写到这，本文的例子可以<a href="https://github.com/code81192/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p>]]></content:encoded>
      
      
      
      <category domain="https://bingfenglai.github.io/tags/golang/">golang</category>
      
      
      <comments>https://bingfenglai.github.io/2021/09/05/golang/06_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E5%87%BD%E6%95%B0/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
