<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>golang中的协程与通道（三）</title>
      <link href="/2022/01/12/golang/17_golang%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2022/01/12/golang/17_golang%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/bingfenglai/art-demo/master/art-img/british-shorthair-g32cbd97b6_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在前一篇文章《<a href="https://bingfenglai.github.io/2021/12/15/golang/16_golang%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93%EF%BC%88%E4%BA%8C%EF%BC%89/">golang中的协程与通道（二） </a>》当中，我们初步学习了通道的相关内容，并结合协程进行了简单的应用，接下来，我们将通过具体的练习来进一步学习该知识点。</p><span id="more"></span><h2 id="使用-select-切换协程"><a href="#使用-select-切换协程" class="headerlink" title="使用 select 切换协程"></a>使用 select 切换协程</h2><p>从不同的并发执行的协程中获取值可以通过关键字<code>select</code>来完成，它和<code>switch</code>控制语句非常相似，也被称作通信开关。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-ch1:</span><br><span class="line">fmt.Println(i)</span><br><span class="line"><span class="keyword">case</span> j := &lt;-ch2:</span><br><span class="line">fmt.Println(j)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot; default&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<code>select</code> 使用的说明：</p><ol><li><p><code>default</code> 语句是可选的；</p></li><li><p>在任何一个 case 中执行 <code>break</code> 或者 <code>return</code>，select 就结束了；</p></li><li><p><code>select</code> 做的就是：选择处理列出的多个通信情况中的一个：</p><p>3.1 如果通道都属于阻塞状态，则会等待直到其中一个可以处理（没有default的情况下）</p><p>3.2 如果多个可以处理，则随机选择其中一个</p><p>3.3 如果没有通道操作可以处理了并且写了<code>default</code> 语句，则会执行<code>default</code>语句：<code>default</code> 永远是可运行的。</p></li></ol><h2 id="惰性生成器的实现"><a href="#惰性生成器的实现" class="headerlink" title="惰性生成器的实现"></a>惰性生成器的实现</h2><p>生成器是指被调用时返回下一个序列中下一个值的函数。一般用来生成订单号等。因为生成器每次返回的是序列中下一个值而非整个序列，这种特性也被称之为<strong>惰性求值</strong>。</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> interval</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interval <span class="keyword">struct</span> &#123;</span><br><span class="line">maxValue    <span class="keyword">int</span></span><br><span class="line">currentVale <span class="keyword">int</span></span><br><span class="line">step        <span class="keyword">int</span></span><br><span class="line">lock        sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewInterval</span><span class="params">(maxValue, step <span class="keyword">int</span>)</span> *<span class="title">Interval</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;Interval&#123;</span><br><span class="line">maxValue:    maxValue,</span><br><span class="line">currentVale: <span class="number">1</span>,</span><br><span class="line">step:        step,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取序列的下一个区间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver *Interval)</span> <span class="title">GetNextInterval</span><span class="params">()</span> <span class="params">(min, max <span class="keyword">int</span>,err error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">receiver.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> receiver.lock.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> receiver.currentVale &gt;= receiver.maxValue &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, errors.New(<span class="string">&quot;序列号已耗尽&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">min = receiver.currentVale</span><br><span class="line">max = receiver.currentVale + receiver.step</span><br><span class="line"><span class="keyword">if</span> max &gt; receiver.maxValue &#123;</span><br><span class="line">max = receiver.maxValue</span><br><span class="line">&#125;</span><br><span class="line">receiver.currentVale = max + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> min, max,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;go_code/channel_demo/gen/interval&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个chan int 类型的通道</span></span><br><span class="line"><span class="keyword">var</span> resume <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间实例</span></span><br><span class="line"><span class="keyword">var</span> myInterval = interval.NewInterval(<span class="number">99999</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> count <span class="keyword">struct</span> &#123;</span><br><span class="line">i <span class="keyword">int</span></span><br><span class="line">mu sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化通道</span></span><br><span class="line">resume = intergers()</span><br><span class="line"></span><br><span class="line">count := count&#123;</span><br><span class="line">i:  <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不断地获取下一个序列值并格式化打印</span></span><br><span class="line"><span class="comment">// 为了验证所有的协程获取的序列号不重复，每获取一个记录数count+1</span></span><br><span class="line"><span class="keyword">for</span> j :=<span class="number">10</span>;j&gt;<span class="number">0</span>;j-- &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(fmt.Sprintf(<span class="string">&quot;%05d&quot;</span>, generateInteger()))</span><br><span class="line">count.mu.Lock()</span><br><span class="line">count.i = count.i+<span class="number">1</span></span><br><span class="line">count.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">1e9</span>*<span class="number">3</span>)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;总共获取：&quot;</span>,count.i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从chan int 通道当作获取下一个值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateInteger</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &lt;-resume</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个chan int 类型的通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intergers</span><span class="params">()</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">yield := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">min, max, _ := myInterval.GetNextInterval()</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="comment">// 开启一个协程，不断地向通道当中写入下一个序列号（阻塞的）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> min &lt;= max &#123;</span><br><span class="line">yield &lt;- min</span><br><span class="line">min++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">min, max, err = myInterval.GetNextInterval()</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> yield</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子当中，Interval存储的是整个序列的信息，包括序列的最大值，步长，当前开始值。函数<code>GetNextInterval()</code> 获取下一个区间值。函数<code>generateInteger()</code>获取序列当中的下一个值。我们在main函数当中，使用协程和无限循环不断地获取序列值并打印，每获取一个<code>count</code>+1，最终打印获取到的总数。</p><p>程序输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总共获取： 99999</span><br></pre></td></tr></table></figure><h2 id="实现-Futures-模式"><a href="#实现-Futures-模式" class="headerlink" title="实现 Futures 模式"></a>实现 Futures 模式</h2><p>所谓的<strong>Futures</strong>指的是：在某些场景当中，我们使用某一个值之前需要先对其进行计算。在这种情况下，我们可以在另一个处理器上进行该值的计算，到使用时，该值就已经计算完毕。</p><p>Futures类似于生成器，不同的地方在于Futures需要返回一个值。</p><p>请看下面的例子：</p><p>在某一场景当中，我们的程序需要不断地接收图片并对其进行特征提取。那么，我们应当如何实现呢？</p><p>实现方式一：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">file := receiverImagesFile()</span><br><span class="line">resolve(file)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receiverImagesFile</span><span class="params">()</span>  <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;1.png&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resolve</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;对图片 &quot;</span>+s+<span class="string">&quot; 进行特征提取&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方式当中，接收文件跟对文件进行处理采用同步的方式进行，分为接收函数<code>receiverImagesFile()</code>和处理函数<code>resolve（）</code> 。在这个简单的模式当中，因为是同步的，当接收函数正在接收文件时（IO相对而言是缓慢的），处理函数可能会存在空闲状态，这样会导致资源的浪费。</p><p>那么，Futures模式是如何处理的呢？请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">resolve()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resolve</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">s := &lt;-receiverImageFile()</span><br><span class="line">time.Sleep(<span class="number">1e9</span> * <span class="number">0.3</span>)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;文件&quot;</span> + s + <span class="string">&quot;处理完毕&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receiverImageFile</span><span class="params">()</span> <span class="title">chan</span> <span class="title">string</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟接收文件过程</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;接收文件中...&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">1e9</span> * <span class="number">1</span>)</span><br><span class="line">ch &lt;- time.Now().Format(<span class="string">&quot;20060102150405&quot;</span>) + <span class="string">&quot;.png&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Futures当中，接收函数跟处理函数通过通道进行解耦。接收函数可以不断地接收新的图片文件，而处理函数不断地对图片进行运算。再给通道设置缓存后，两者之间可以（理想情况下）做到互不影响，使得资源利用率得到提升。并且，我们可以配置多数接收函数对应少数的处理函数，进而减少计算资源的等待时间。对于密集计算型任务，Futures模式可以使得API以异步的形式暴露出来，使得API调用方可以在等待结果的时间处理其他任务。</p><h2 id="协程与通道在CS模式中的应用"><a href="#协程与通道在CS模式中的应用" class="headerlink" title="协程与通道在CS模式中的应用"></a>协程与通道在CS模式中的应用</h2><p>客户端（client）可以是运行在任意设备上的任意程序，它会按需发送请求（rrequest）到服务器。服务器（server）接收到请求后开始对应的工作，并将结果（也称之为响应，response）返回给客户端。一般情况下，多个客户端对应少数的服务器。日常我们使用的浏览器，移动App等都属于客户端。</p><p>在Golang当中，请求的执行一般在协程当中进行。请求的响应将通过请求当中包含的通道将结果进行返回。而server程序将不断地从通道当中接收请求，并开启一个协程对其进行处理。</p><p>请看下面的demo:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求</span></span><br><span class="line"><span class="keyword">type</span> request <span class="keyword">struct</span> &#123;</span><br><span class="line">args   <span class="keyword">string</span></span><br><span class="line">replyc <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sayHello <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟调度具体的业务方法，并通过通道返回结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(do sayHello, req *request)</span></span> &#123;</span><br><span class="line">req.replyc &lt;- do(req.args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟服务器应用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">(do sayHello, service <span class="keyword">chan</span> *request, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">close</span>(quit)</span><br><span class="line"><span class="keyword">for</span>  &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span>(service) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">close</span>(service)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;程序退出&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> req := &lt;-service:</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;收到请求&quot;</span>, req.args)</span><br><span class="line"><span class="keyword">go</span> run(do, req)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> &lt;-quit:</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;收到退出指令&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器方法</span></span><br><span class="line"><span class="comment">// resp: 请求通道、退出信号通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startServer</span><span class="params">(do sayHello)</span> <span class="params">(seivice <span class="keyword">chan</span> *request, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">seivice = <span class="built_in">make</span>(<span class="keyword">chan</span> *request)</span><br><span class="line">quit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> server(do, seivice, quit)</span><br><span class="line"><span class="keyword">return</span> seivice, quit</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">4</span>)</span><br><span class="line">service, quit := startServer(<span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello! &quot;</span> + name</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> N = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reqs [N]request</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化N个请求实例，并对服务器发器请求</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">req := &amp;reqs[i]</span><br><span class="line">req.args = strconv.Itoa(i) + <span class="string">&quot; name&quot;</span></span><br><span class="line">req.replyc = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟接收响应结果</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := &lt;-req.replyc</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;接收响应：&quot;</span>,s)</span><br><span class="line"></span><br><span class="line">&#125;()</span><br><span class="line">service &lt;- req</span><br><span class="line"><span class="keyword">if</span> i == N<span class="number">-1</span> &#123;</span><br><span class="line">quit&lt;<span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">2</span> * <span class="number">1e9</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子当中，我们封装了请求<code>request</code> ，里面包含了请求参数和结果返回的通道信息。在服务器当中，每收到一个请求就开启一个协程对该请求进行处理（go协程是非常轻量的），并将结果发送到请求的响应通道当中。服务器通过<code>select</code>机制进行不同通道之间的切换。</p><h2 id="通道在限制并发当中的应用"><a href="#通道在限制并发当中的应用" class="headerlink" title="通道在限制并发当中的应用"></a>通道在限制并发当中的应用</h2><p>我们知道，在硬件资源不变的情况下，计算机处理的最大请求数是固定。当某些极限情况下，可能会出现大量的请求打到计算机上，这时，可能会出现请求过载，导致计算机宕机。因此，我们需要将请求最大值限制在计算机能够处理的范围之内，也就是<code>限流</code>。在<code>Golang</code>中使用带有缓冲的通道就很容易实现这一点，<strong>通道的缓冲大小就是同时处理请求的最大数量。</strong></p><p>我们将上面的例子当中的<code>service</code>通道修改一下，在初始化时指定缓冲大小</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动服务器方法</span></span><br><span class="line"><span class="comment">// resp: 请求通道、退出信号通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startServer</span><span class="params">(do sayHello)</span> <span class="params">(seivice <span class="keyword">chan</span> *request, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">seivice = <span class="built_in">make</span>(<span class="keyword">chan</span> *request,<span class="number">4</span>)</span><br><span class="line">quit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> server(do, seivice, quit)</span><br><span class="line"><span class="keyword">return</span> seivice, quit</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，我们再次运行一下demo,就可以看到此时服务器函数同时接收到请求就扩大到了4.</p><h2 id="并行计算的应用"><a href="#并行计算的应用" class="headerlink" title="并行计算的应用"></a>并行计算的应用</h2><p>现代计算机绝大多数都是多核心CPU。并行计算可以理解为：利用多个处理器协同求解同一问题的过程。接下来，我们通过一个demo了解Golang在并行计算上面的应用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数列求和函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(list []<span class="keyword">int</span>, ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, j := <span class="keyword">range</span> list &#123;</span><br><span class="line">i = i + j</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;分段结果:&quot;</span> + strconv.Itoa(i))</span><br><span class="line">ch &lt;- i</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参与运算的cpu数</span></span><br><span class="line"><span class="keyword">const</span> cpu_num = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">runtime.GOMAXPROCS(cpu_num)</span><br><span class="line"><span class="keyword">var</span> list = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">34</span>, <span class="number">52</span>, <span class="number">46</span>, <span class="number">87</span>, <span class="number">18</span>, <span class="number">91</span>, <span class="number">101</span>, <span class="number">161</span>, <span class="number">182</span>&#125;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 分为六等份</span></span><br><span class="line">num := <span class="built_in">cap</span>(list) / cpu_num</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;每份大小：&quot;</span> + strconv.Itoa(num))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cpu_num; i++ &#123;</span><br><span class="line">sub := list[i*num : i*num+num]</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> sum(sub, ch)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> total []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cpu_num; i++ &#123;</span><br><span class="line">sum := &lt;-ch</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;收到结果&quot;</span> + strconv.Itoa(sum))</span><br><span class="line">total = <span class="built_in">append</span>(total, sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;结果长度&quot;</span>, <span class="built_in">len</span>(total))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(total)<span class="number">-1</span>; i++ &#123;</span><br><span class="line"><span class="built_in">println</span>(total[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;==========&quot;</span>)</span><br><span class="line"><span class="keyword">go</span> sum(total, ch)</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(&lt;-ch)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">每份大小：<span class="number">2</span></span><br><span class="line">分段结果:<span class="number">23</span></span><br><span class="line">收到结果<span class="number">23</span></span><br><span class="line">分段结果:<span class="number">98</span></span><br><span class="line">收到结果<span class="number">98</span></span><br><span class="line">分段结果:<span class="number">343</span></span><br><span class="line">分段结果:<span class="number">192</span></span><br><span class="line">分段结果:<span class="number">65</span></span><br><span class="line">收到结果<span class="number">343</span></span><br><span class="line">收到结果<span class="number">192</span></span><br><span class="line">收到结果<span class="number">65</span></span><br><span class="line">分段结果:<span class="number">105</span></span><br><span class="line">收到结果<span class="number">105</span></span><br><span class="line">结果长度 <span class="number">6</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">98</span></span><br><span class="line"><span class="number">343</span></span><br><span class="line"><span class="number">192</span></span><br><span class="line"><span class="number">65</span></span><br><span class="line">==========</span><br><span class="line">分段结果:<span class="number">826</span></span><br><span class="line"><span class="number">826</span></span><br></pre></td></tr></table></figure><p>在这个例子当中，存在一个长度为N的数组，我们需要对数组内的元素（元素是无规律的）进行求和。我们将其分为n（n为N的公约数且n小于计算机CPU核心数）等份，并通过协程去同时计算n等分的分段和，最后进行再对分段和组成的数组（可以再次切分为m等分，依次类推）进行求和。</p><p>在这个例子当中，我们可以充分的利用资源进行协同求解，使得计算效率大大提升。</p><h2 id="通过通道来访问共享资源"><a href="#通过通道来访问共享资源" class="headerlink" title="通过通道来访问共享资源"></a>通过通道来访问共享资源</h2><p>在这之前，我们为了安全地访问共享资源，一般通过加锁来实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Info <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu sync.Mutex</span><br><span class="line">    <span class="comment">// ... other fields, e.g.: Str string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，对于通道内的元素，我们将其取出是具备顺序性的，因此，我们可不可利用此特性来实现对共享资源的访问呢？请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 共享资源</span></span><br><span class="line"><span class="keyword">type</span> Count <span class="keyword">struct</span> &#123;</span><br><span class="line">count <span class="keyword">int</span></span><br><span class="line">funCh <span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCount</span><span class="params">(i <span class="keyword">int</span>)</span> *<span class="title">Count</span></span> &#123;</span><br><span class="line"></span><br><span class="line">count := &amp;Count&#123;</span><br><span class="line"></span><br><span class="line">count: i,</span><br><span class="line">funCh: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span>),</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> count.backend()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后台协程方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver *Count)</span> <span class="title">backend</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">f := &lt;-receiver.funCh</span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问资源的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver *Count)</span> <span class="title">AddCount</span><span class="params">(count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">receiver.count = receiver.count + count</span><br><span class="line">&#125;</span><br><span class="line">receiver.funCh &lt;- f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">runtime.GOMAXPROCS(<span class="number">2</span>)</span><br><span class="line">count := NewCount(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">total := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(count *Count)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">500</span>; i++ &#123;</span><br><span class="line">count.AddCount(<span class="number">1</span>)</span><br><span class="line">total = total + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;(count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(count *Count)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">500</span>; i++ &#123;</span><br><span class="line">count.AddCount(<span class="number">-1</span>)</span><br><span class="line">total = total - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;(count)</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">1</span> * <span class="number">1e9</span>)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;通过通道访问的资源：&quot;</span>, count.count)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;直接访问的资源：&quot;</span>, total)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子当中，我们分别通过通道和直接访问的方式操作资源，最后打印结果。可以看到，通过通道去组织对资源的访问，可以起到对资源加锁的作用。当然，这仅仅是一个简化的demo，虽然不能直接用于实际开发，但是这种方式给我们提供了在实际场景中并发编程对于资源访问方面提供了思路。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>在这篇文章当中，我们通过几个小案例跟大家探讨了关于协程、通道的应用，使得我们可以更好地掌握这些知识点。</p><p>本文当中涉及到的例子可以<a href="https://github.com/bingfenglai/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang中的协程与通道（二）</title>
      <link href="/2021/12/15/golang/16_golang%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2021/12/15/golang/16_golang%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/bingfenglai/art-demo/master/art-img/woman-ga2a1fc987_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在上一篇文章<a href="https://bingfenglai.github.io/2021/12/12/golang/15_golang%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93/">《golang中的协程与通道（上）》</a>当中，我们初步认识了golang当中的协程的相关知识点。接下来，我们将开始学习通道(channel) 的相关知识点。</p><h2 id="通道的概念"><a href="#通道的概念" class="headerlink" title="通道的概念"></a>通道的概念</h2><p>在上一篇文章的demo当中，协程是独立执行的，他们之间没有进行通信。然而在实际情况下，协程之间必须要通信才会变得更加有用：协程之间通过发送和接收消息来协调或同步他们之间的工作。</p><span id="more"></span><p>一组协程组成一条流水线，他们通过皮带流水装配线来协同工作，以提升资源利用率和工作效率。</p><p>Golang中有一种特殊的类型，通道（channel），它是一个可以用于发送类型化数据的管道，由其负责协程之间的通信，通过这种通信方式从而保证了同步性。</p><h2 id="通道的声明"><a href="#通道的声明" class="headerlink" title="通道的声明"></a>通道的声明</h2><p>通道的声明方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 通道标识符 <span class="keyword">chan</span> datatype</span><br></pre></td></tr></table></figure><p>未初始化的通道的值是<code>nil</code>.</p><p>从上面的声明语句当中我们知道，通道只能传输一种类型的数据，并且所有的数据类型都可用于通道。interface{}类型也是可以的。</p><p>实际上，通道是类型化消息的队列：它是先进先出（FIFO）的结构的，这保证了数据传输的顺序性。</p><p>通道是一种引用类型，因此我们可以使用make()函数来给它分配内存。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">ch1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br></pre></td></tr></table></figure><p>通道是第一类对象：可以存储在变量中，作为函数的参数传递，从函数返回以及通过通道发送它们自身。另外它们是类型化的，允许类型检查，比如尝试使用整数通道发送一个指针。</p><h2 id="通信操作符-lt"><a href="#通信操作符-lt" class="headerlink" title="通信操作符&lt;-"></a>通信操作符&lt;-</h2><p>通信操作符<code>&lt;-</code>箭头的方向为数据的流向。</p><p>流向通道：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch :=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch &lt;- int1</span><br></pre></td></tr></table></figure><p>从通道流出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int2 := &lt;- ch</span><br></pre></td></tr></table></figure><p><code>&lt;- ch</code> 可以单独调用获取通道的（下一个）值，当前值会被丢弃:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;- ch !=<span class="number">-1</span>&#123;</span><br><span class="line">    do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通道的特点"><a href="#通道的特点" class="headerlink" title="通道的特点"></a>通道的特点</h2><ol><li>为了可读性通道的命名通常以 <code>ch</code> 开头或者包含 <code>chan</code>。</li><li>通道的发送和接收都是原子操作：它们总是互不干扰的完成的。</li></ol><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>在下面的这个demo当中，我们结合前面学到的协程实际运用一下通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;runtime&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">2</span>)</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">ch1 :=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> sendData(ch)</span><br><span class="line"><span class="keyword">go</span> sayHello(ch,ch1)</span><br><span class="line"></span><br><span class="line">&lt;-ch1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendData</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="string">&quot;韩立&quot;</span></span><br><span class="line">ch &lt;- <span class="string">&quot;厉飞羽&quot;</span></span><br><span class="line">ch &lt;- <span class="string">&quot;张铁&quot;</span></span><br><span class="line">ch &lt;- <span class="string">&quot;墨大夫&quot;</span></span><br><span class="line">ch &lt;- <span class="string">&quot;南宫婉&quot;</span></span><br><span class="line">ch &lt;- <span class="string">&quot;六道传人&quot;</span></span><br><span class="line">ch &lt;- <span class="string">&quot;董萱儿&quot;</span></span><br><span class="line">ch &lt;-<span class="string">&quot;EOF&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(ch,ch1 <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">input := &lt;-ch</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> input!=<span class="string">&quot;EOF&quot;</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;hello !&quot;</span>,input)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ch1 &lt;- <span class="string">&quot;EOF&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hello ! 韩立</span><br><span class="line">hello ! 厉飞羽</span><br><span class="line">hello ! 张铁</span><br><span class="line">hello ! 墨大夫</span><br><span class="line">hello ! 南宫婉</span><br><span class="line">hello ! 六道传人</span><br><span class="line">hello ! 董萱儿</span><br></pre></td></tr></table></figure><p>在这个例子当中，<code>sendData()</code>函数向通道<code>ch</code>发送数据,<code>sayHello()</code>函数接受并处理，处理完数据后向<code>ch1</code>通道发送结束符，主程序退出。在这个例子当中，很好地展示了通道以及协程的综合使用。</p><h2 id="通道阻塞"><a href="#通道阻塞" class="headerlink" title="通道阻塞"></a>通道阻塞</h2><p>在上面的例子我们可以发现：在默认情况下，使用通道通信是同步且无缓冲的,必须要一个接收者准备好接收通道的数据后发送者才可以将数据发送给接收者，在这之前，通道是阻塞的。</p><p>在默认情况下：</p><ol><li><p>对于同一个通道，发送操作（协程或者函数中的），在接收者准备好之前是阻塞的：如果ch中的数据无人接收，就无法再给通道传入其他数据：新的输入无法在通道非空的情况下传入。所以发送操作会等待 ch 再次变为可用状态：就是通道值被接收时（可以传入变量）。</p></li><li><p>对于同一个通道，接收操作是阻塞的（协程或函数中的），直到发送者可用：如果通道中没有数据，接收者就阻塞了。</p></li></ol><h2 id="使用带缓冲的通道"><a href="#使用带缓冲的通道" class="headerlink" title="使用带缓冲的通道"></a>使用带缓冲的通道</h2><p>下面，我们将通过一个例子来学习带缓冲通道的使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 缓冲元素个数</span></span><br><span class="line">buf := <span class="number">3</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,buf)</span><br><span class="line"></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> sendData(ch)</span><br><span class="line"><span class="keyword">go</span> receivingData(ch,ch1)</span><br><span class="line"></span><br><span class="line">&lt;-ch1</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendData</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">data := [...]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;韩立&quot;</span>,</span><br><span class="line"><span class="string">&quot;厉飞羽&quot;</span>,</span><br><span class="line"><span class="string">&quot;张铁&quot;</span>,</span><br><span class="line"><span class="string">&quot;墨大夫&quot;</span>,</span><br><span class="line"><span class="string">&quot;南宫婉&quot;</span>,</span><br><span class="line"><span class="string">&quot;六道传人&quot;</span>,</span><br><span class="line"><span class="string">&quot;董萱儿&quot;</span>,</span><br><span class="line"><span class="string">&quot;EOF&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;开始发送数据&quot;</span>,time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> data &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ch &lt;- data[i]</span><br><span class="line">fmt.Println(<span class="string">&quot;发送数据：&quot;</span>, data[i])</span><br><span class="line"><span class="keyword">if</span> data[i] == <span class="string">&quot;EOF&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;数据发送完毕&quot;</span>,time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receivingData</span><span class="params">(ch, ch1 <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 为了演示缓冲效果，先让接收者函数休眠3秒</span></span><br><span class="line">time.Sleep(<span class="number">3</span>*<span class="number">1e9</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;开始接收数据&quot;</span>,time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">input := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> input != <span class="string">&quot;EOF&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;接收到数据：&quot;</span>, input)</span><br><span class="line">fmt.Println(<span class="string">&quot;数据处理中...&quot;</span>)</span><br><span class="line"><span class="comment">// 模拟数据处理耗时</span></span><br><span class="line">time.Sleep(<span class="number">1</span>*<span class="number">1e9</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;数据接收完毕&quot;</span>,time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ch1 &lt;- <span class="string">&quot;EOF&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">开始发送数据 <span class="number">2021</span><span class="number">-12</span><span class="number">-14</span> <span class="number">22</span>:<span class="number">25</span>:<span class="number">24</span></span><br><span class="line">发送数据： 韩立</span><br><span class="line">发送数据： 厉飞羽</span><br><span class="line">发送数据： 张铁</span><br><span class="line">开始接收数据 <span class="number">2021</span><span class="number">-12</span><span class="number">-14</span> <span class="number">22</span>:<span class="number">25</span>:<span class="number">27</span></span><br><span class="line">接收到数据： 韩立</span><br><span class="line">数据处理中...</span><br><span class="line">发送数据： 墨大夫</span><br><span class="line">接收到数据： 厉飞羽</span><br><span class="line">发送数据： 南宫婉</span><br><span class="line">数据处理中...</span><br><span class="line">接收到数据： 张铁</span><br><span class="line">数据处理中...</span><br><span class="line">发送数据： 六道传人</span><br><span class="line">接收到数据： 墨大夫</span><br><span class="line">数据处理中...</span><br><span class="line">发送数据： 董萱儿</span><br><span class="line">接收到数据： 南宫婉</span><br><span class="line">数据处理中...</span><br><span class="line">发送数据： EOF</span><br><span class="line">数据发送完毕 <span class="number">2021</span><span class="number">-12</span><span class="number">-14</span> <span class="number">22</span>:<span class="number">25</span>:<span class="number">31</span></span><br><span class="line">接收到数据： 六道传人</span><br><span class="line">数据处理中...</span><br><span class="line">接收到数据： 董萱儿</span><br><span class="line">数据处理中...</span><br><span class="line">数据接收完毕 <span class="number">2021</span><span class="number">-12</span><span class="number">-14</span> <span class="number">22</span>:<span class="number">25</span>:<span class="number">34</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子当中，<code>ch</code>是一个缓冲大小为3的通道。这意味着数据发送方可以在接收方未准备好的情况下先往通道里面塞3个数据，等接收方拿第一个数据后发送方就可以继续往里面塞数据。</p><p>总结如下：</p><ol><li><p>以上demo中buf 是通道可以同时容纳的元素（这里是 string）个数</p></li><li><p>在缓冲满载（缓冲被全部使用）之前，给一个带缓冲的通道发送数据是不会阻塞的，而从通道读取数据也不会阻塞，直到缓冲空了。</p></li><li><p>缓冲容量和类型无关，所以可以（尽管可能导致危险）给一些通道设置不同的容量，只要他们拥有同样的元素类型。内置的 <code>cap</code> 函数可以返回缓冲区的容量。</p></li><li><p>如果容量大于 0，通道就是异步的了：缓冲满载（发送）或变空（接收）之前通信不会阻塞，元素会按照发送的顺序被接收。如果容量是0或者未设置，通信仅在收发双方准备好的情况下才可以成功。</p></li></ol><h2 id="信号量模式"><a href="#信号量模式" class="headerlink" title="信号量模式"></a>信号量模式</h2><p>在上面的例子当中，为了告诉数据接收方数据已经发送完了，双方约定好：当接收到的数据等于”EOF”符号时，表示数据已发送完毕。数据接收方处理完数据后通过通道<code>ch1</code>发送”EOF”告诉主程序数据处理完毕，使得主程序退出。这里的”EOF”就是一个信号.</p><p>除此之外，信号量还经常用以实现互斥锁，限制对资源的并发访问。</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">2</span>)</span><br><span class="line">ch :=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i :=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++ &#123;</span><br><span class="line"><span class="keyword">go</span> buyGoods(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">3</span>* <span class="number">1e9</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buyGoods</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;准备下单&quot;</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;购买成功！库存剩余&quot;</span>,<span class="built_in">cap</span>(ch)-<span class="built_in">len</span>(ch))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">准备下单</span><br><span class="line">购买成功！库存剩余 <span class="number">2</span></span><br><span class="line">准备下单</span><br><span class="line">购买成功！库存剩余 <span class="number">1</span></span><br><span class="line">准备下单</span><br><span class="line">购买成功！库存剩余 <span class="number">0</span></span><br><span class="line">准备下单</span><br><span class="line">准备下单</span><br><span class="line">准备下单</span><br><span class="line">准备下单</span><br><span class="line">准备下单</span><br><span class="line">准备下单</span><br><span class="line">准备下单</span><br></pre></td></tr></table></figure><p>在这个例子当中，我们使用通道缓存元素个数来表示商品的库存，使用协程模拟并发访问，来模拟下单场景。可以看到使用通道缓存来实现信号量机制，可以保护我们的共享资源的并发访问。</p><p>除此之外，大家可以考虑一种计算场景：输入是一个很长的数据序列，我们要对这个序列求和，也就是1+2+…+n-1+n。这时，我们可以通过协程加通道的形式，使用并行计算的方式，计算好每个分段的和，然后将其发送到通道当中，主程序收到后进行最后的运算，这样可以极大的提高资源利用率，加快运算速度。关于这一块，这里只是顺嘴提一句，大家可以尝试着实现一下。</p><h2 id="通道的方向与习惯用法"><a href="#通道的方向与习惯用法" class="headerlink" title="通道的方向与习惯用法"></a>通道的方向与习惯用法</h2><h3 id="通道的方向"><a href="#通道的方向" class="headerlink" title="通道的方向"></a>通道的方向</h3><p>通道类型可以用注解来表示它只发送或者只接收：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只发送</span></span><br><span class="line"><span class="keyword">var</span> send_only <span class="keyword">chan</span>&lt;- <span class="keyword">int</span> </span><br><span class="line"><span class="comment">// 只接收</span></span><br><span class="line"><span class="keyword">var</span> recv_only &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>       </span><br></pre></td></tr></table></figure><p>只接收的通道（&lt;-chan T）无法关闭，因为关闭通道是发送者用来表示不再给通道发送值了，所以对只接收通道是没有意义的。</p><p>通道在创建时都是双向的，但是我们可以分配有方向的通道变量。</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch :=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> sendData(ch)</span><br><span class="line"><span class="keyword">go</span> receivingData(ch)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendData</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receivingData</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="习惯用法1：通道迭代器"><a href="#习惯用法1：通道迭代器" class="headerlink" title="习惯用法1：通道迭代器"></a>习惯用法1：通道迭代器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> container <span class="keyword">struct</span> &#123;</span><br><span class="line">items []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *container)</span> <span class="title">Len</span><span class="params">()</span><span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(c.items)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *container)</span> <span class="title">Iter</span> <span class="params">()</span> &lt;- <span class="title">chan</span> <span class="title">string</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; c.Len(); i++&#123;</span><br><span class="line">ch &lt;- c.items[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">&#125; ()</span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := container&#123;items: []<span class="keyword">string</span>&#123;<span class="string">&quot;韩立&quot;</span>,<span class="string">&quot;南宫婉&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s := <span class="keyword">range</span> c.Iter() &#123;</span><br><span class="line"><span class="built_in">println</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">韩立</span><br><span class="line">南宫婉</span><br></pre></td></tr></table></figure><p>以上就是给通道使用for循环实现的迭代器,其中<code>container</code>为存放资源的容器。使用for循环遍历通道，意味着它从指定通道中读取数据直到通道关闭，才继续执行下边的代码。<strong>写入完成后必须要关闭通道</strong> 。因为Iter函数返回的是一个只读通道，它是没法关闭的。</p><h3 id="习惯用法2-：生产者消费者模式"><a href="#习惯用法2-：生产者消费者模式" class="headerlink" title="习惯用法2 ：生产者消费者模式"></a>习惯用法2 ：生产者消费者模式</h3><p>假设存在生产者函数Produce()不断产生消费者consume()所需要的值，它们都可以运行在独立的协程中,那么你可以使用一下的写法:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">Consume(Produce(<span class="number">10</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Produce</span><span class="params">(size <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span>&#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;size;i++ &#123;</span><br><span class="line">ch&lt;-i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Consume</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ch &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;收到数据&quot;</span>,i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">收到数据 <span class="number">0</span></span><br><span class="line">收到数据 <span class="number">1</span></span><br><span class="line">收到数据 <span class="number">2</span></span><br><span class="line">收到数据 <span class="number">3</span></span><br><span class="line">收到数据 <span class="number">4</span></span><br><span class="line">收到数据 <span class="number">5</span></span><br><span class="line">收到数据 <span class="number">6</span></span><br><span class="line">收到数据 <span class="number">7</span></span><br><span class="line">收到数据 <span class="number">8</span></span><br><span class="line">收到数据 <span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>关于通道的内容我们就简单学习到这，下面一篇文章将学习协程与通道的更多用法。</p><p>本文当中涉及到的例子可以<a href="https://github.com/bingfenglai/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang中的协程与通道（一）</title>
      <link href="/2021/12/12/golang/15_golang%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93/"/>
      <url>/2021/12/12/golang/15_golang%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/bingfenglai/art-demo/master/art-img/fox-ge22f332d8_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在上一篇文章<a href="https://bingfenglai.github.io/2021/12/11/golang/14_golang%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/">《golang中的错误处理》</a>当中，我们简单介绍了Golang当中的错误处理部分的内容。接下来，我们将学习Golang当中的<strong>协程</strong>（goroutine）和<strong>通道</strong>（channel）两部分的内容。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>作为一门 21 世纪的语言，Go 原生支持应用之间的通信和程序的并发。程序可以在不同的处理器和计算机上同时执行不同的代码段。Go 语言为构建并发程序的基本代码块是 <strong>协程</strong> (go-routine) 与<strong>通道</strong> (channel)。</p><span id="more"></span><h2 id="并发、并行和协程"><a href="#并发、并行和协程" class="headerlink" title="并发、并行和协程"></a>并发、并行和协程</h2><h3 id="协程的定义"><a href="#协程的定义" class="headerlink" title="协程的定义"></a>协程的定义</h3><p>在讲协程的定义之前，我们首先需要来了解什么是并发和并行，以及他们之间的区别。</p><p>一般来说，一个应用程序运行在机器上时，它对应着一个进程。一个进程由一个或多个操作系统线程组成，这些线程共享进程的内存地址空间。那么我们说，<strong>一个并发程序可以在一个处理器或者内核上使用多个线程来执行任务，但是只有同一个程序在某个时间点同时运行在多核或者多处理器上才是真正的并行。</strong></p><p>公认的，使用多线程的应用难以做到准确，最主要的问题是内存中的数据共享，它们会被多线程以无法预知的方式进行操作，导致一些无法重现或者随机的结果（称作 <code>竞态</code>）。那么解决这个问题的方法便是对数据加锁。这样同时就只有一个线程可以变更数据。在 Go 的标准库 <code>sync</code> 中有一些工具用来在低级别的代码中实现加锁。</p><p>为了方便大家理解加锁这个问题，下面给大家举一个形象的例子：</p><p>例如，在现实生活当中，妹子可以类比做数据。为了数据访问合法性，假设有一线程男要对某一数据女进行操作，那么在这之前，他需要带着妹子先去领证。那么领完证之后，就类比于对数据加了锁（排他锁、独占锁）。那么线程对数据才能进行操作，其他线程想要操作这个数据，那么就得等到原先的线程释放锁。而释放锁的过程正好与加锁的过程相反，就可以类比于离婚了。</p><p>上面的例子当中只是为了方便部分读者去理解锁的相关概念，例子当中涉及到的只有独占锁一类锁。实际编程当中还涉及到了读写锁、更新锁、乐观锁、悲观锁等等概念，关于这部分，大家可以去Google，这并不是今天的重点。</p><p>在过去的软件开发经验告诉我们这会带来更高的复杂度，更容易使代码出错以及更低的性能，所以这个经典的方法明显不再适合现代多核/多处理器编程。</p><p>在Golang当中，应用程序并发处理这部分被称作<strong>go-routines</strong>（协程或者go协程）（需要注意的是：这里的协程与Python当中的协程概念并不相同，这是两个完全不同的东西。），并鼓励开发者使用channels进行协程同步（后面会详细讲），而不是通过<code>sync</code>包当中的锁来实现。</p><h3 id="协程的特点"><a href="#协程的特点" class="headerlink" title="协程的特点"></a>协程的特点</h3><ol><li>协程与操作系统线程之间并没有一一对应的关系：协程是根据一个或多个线程的可用性，映射（多路复用）执行于他们之上的。</li><li>当系统调用（比如等待 I/O）阻塞协程时，其他协程会继续在其他线程上工作。协程的设计隐藏了许多线程创建和管理方面的复杂工作。</li><li>协程是轻量的，它比线程更轻。使用4K的栈内存就可以在堆当中创建它们。栈的管理是自动的，但不是由垃圾回收器管理的，而是在协程退出后自动释放。</li><li>协程可以运行在多个操作系统线程之间，也可以运行在线程之内，让你可以很小的内存占用就可以处理大量的任务。即使有协程阻塞，该线程的其他协程也可以被<code>runtime</code>调度，转移到其他可运行的线程上。并且这个细节对于开发者来说是透明的，降低了编程的难度。</li><li>线程是运行协程的实体，协程调度器将可运行的协程分配到工作线程上。</li></ol><h3 id="协程的调用"><a href="#协程的调用" class="headerlink" title="协程的调用"></a>协程的调用</h3><p>协程是通过使用关键字 <code>go</code> 调用（执行）一个函数或者方法来实现的（也可以是匿名或者 lambda 函数）。这样会在当前的计算过程中开始一个同时进行的函数，在相同的地址空间中并且分配了独立的栈，比如：<code>go sum(bigArray)</code>，在后台计算总和。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> 函数名（实参列表）</span><br></pre></td></tr></table></figure><h3 id="GOMAXPROCS参数的使用"><a href="#GOMAXPROCS参数的使用" class="headerlink" title="GOMAXPROCS参数的使用"></a>GOMAXPROCS参数的使用</h3><p>在上文中提到：线程是运行协程的实体，协程调度器将可运行的协程分配到工作线程上。那么，如何设置多少系统线程用于执行协程呢？这时就需要用到<strong>GOMAXPROCS</strong>参数。GOMAXPROCS参数默认值为1。这时，程序的所有协程都由1个线程执行，也就是N-1模式（关于其他几种模式，后面有时间再详细讲解）。</p><p>在N-1模式下，协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。但是缺点也很明显：无法使用多核加速能力，一旦某协程阻塞，就会造成线程阻塞。也因此，我们需要通过设置该参数，来充分利用多核CPU。</p><p>假设 n 是机器上处理器或者核心的数量。如果你设置环境变量 GOMAXPROCS&gt;=n，或者执行 <code>runtime.GOMAXPROCS(n)</code>，接下来协程会被分割（分散）到 n 个处理器上。更多的处理器并不意味着性能的线性提升。有这样一个经验法则，对于 n 个核心的情况设置 GOMAXPROCS 为 n-1 以获得最佳性能，也同样需要遵守这条规则：协程的数量 &gt; 1 + GOMAXPROCS &gt; 1。</p><p>一句话概括：GOMAXPROCS参数值等同于（并发的）线程数量，在一台核心数多于1个的机器上，会尽可能有等同于核心数的线程在并行运行。</p><h3 id="协程的简单应用demo"><a href="#协程的简单应用demo" class="headerlink" title="协程的简单应用demo"></a>协程的简单应用demo</h3><p>下面，我们将通过一个简单的的demo来实际应用协程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">i = <span class="built_in">append</span>(i, <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>)</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> sum(i)</span><br><span class="line"><span class="keyword">go</span> multiply(i)</span><br><span class="line"><span class="comment">// 为了保证协程逻辑执行完</span></span><br><span class="line">time.Sleep(<span class="number">1</span> * <span class="number">1e9</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求和函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(num []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> total <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> num &#123;</span><br><span class="line"></span><br><span class="line">total = num[i]+total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;求和结果为：&quot;</span>,total)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 乘积</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span><span class="params">(num []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> total <span class="keyword">int</span></span><br><span class="line">total = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> num &#123;</span><br><span class="line"></span><br><span class="line">total = num[i]*total</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;乘积结果为：&quot;</span>,total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">乘积结果为： 48</span><br><span class="line">求和结果为： 12</span><br></pre></td></tr></table></figure><p>在这个例子当中，我们需要对输入的一组数据分别进行求和运算与乘积运算。这两个运算可以同时进行。我们通过创建2个协程对其分别进行乘积与求和运算并打印最终的结果。</p><p>等我们学习完通道的相关知识点后，我们将对其进行一个综合的应用。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>在这篇文章当中，我们初步认识了Go语言当中的协程，并通过一个简单的demo跟大家分享协程的使用。在下一篇文章当中，我们将介绍通道的相关知识点。</p><p>本文当中涉及到的例子可以<a href="https://github.com/bingfenglai/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang中的错误处理</title>
      <link href="/2021/12/11/golang/14_golang%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
      <url>/2021/12/11/golang/14_golang%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/bingfenglai/art-demo/master/art-img/photographer-g1a4cb0395_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在前面的几篇文章当中，我们主要是学习了Golang当中文件的读写以及数据的编码方式相关的知识。接下来，我们将开始来学习Golang中的<strong>错误处理</strong>。</p><h2 id="Golang的错误处理模式"><a href="#Golang的错误处理模式" class="headerlink" title="Golang的错误处理模式"></a>Golang的错误处理模式</h2><p>Go并没有像Java那样的一套try/catch异常处理机制，它不能执行抛异常操作。它使用的是一套defer-panic-and-recover机制。</p><span id="more"></span><p>那么，Golang是怎么处理错误的呢？它的处理方式是这样的：通过在函数和方法中返回错误对象作为它们的唯一或最后一个返回值——如果返回 nil，则没有错误发生——并且主调（calling）函数总是应该检查收到的错误。而上面提到的<code>panic and recover</code> 是用来处理真正的异常（无法预测的错误）而不是普通的错误。</p><h2 id="定义一个错误"><a href="#定义一个错误" class="headerlink" title="定义一个错误"></a>定义一个错误</h2><p>在Go中有一个预先定义好的error类型的接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>errors</code>这个包当中有一个errorString的结构体实现了这个接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误值s用来表示异常状态,当你需要一个新的错误类型，都可以用 <code>errors</code>包的 <code>errors.New</code> 函数接收合适的错误信息来创建。</p><p>请看下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">hello, err := sayHello(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">log.Default().Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(hello)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>,error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;&quot;</span>==name &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, errors.New(<span class="string">&quot;name 不能是一个空字符串&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span>+name,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021/10/02 14:53:16 name 不能是一个空字符串</span><br></pre></td></tr></table></figure><p>在这个例子当中，如果函数<code>sayHello</code>收到的参数<code>name</code>是一个空串的话,函数将返回一个错误，主调函数当中必须对错误进行处理。如果有不同错误条件可能发生，那么可以对实际的错误使用类型断言或类型判断（type-switch），然后根据错误场景做一些补救和恢复操作。</p><p>在Golang当中，对于错误类型以及错误变量有以下的命名规范：错误类型以 “Error” 结尾，错误变量以 “err” 或 “Err” 开头。</p><h2 id="运行时异常与panic"><a href="#运行时异常与panic" class="headerlink" title="运行时异常与panic"></a>运行时异常与<code>panic</code></h2><p>在Golang中，当发生了类似于数组下标越界或者是类型断言失败这样的运行时错误时，Go将会触发运行时<code>panic</code> (程序崩溃)。</p><p>这里需要注意的一点是，**<code>panic</code>的使用条件应当是相当严苛的并且是不能由程序自行恢复的**。发生这样的错误时，意味着程序将不能为我们提供服务，而需要终止程序。</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;发生程序崩溃前&quot;</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;程序崩溃了&quot;</span>)</span><br><span class="line">    <span class="comment">// 下面这条语句将不会被执行</span></span><br><span class="line">fmt.Println(<span class="string">&quot;已产生panic...&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个程序将导致它抛出<code>panic</code>，它打印出错误信息和<code>goroutine</code>痕迹，并以非零状态(非正常状态)退出。</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">发生程序崩溃前</span><br><span class="line">panic: 程序崩溃了</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">G:/06_golangProject/golang/src/go_code/err/panic_demo/main.go:8 +0xa5</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="panic使用场景与panicking"><a href="#panic使用场景与panicking" class="headerlink" title="panic使用场景与panicking"></a>panic使用场景与panicking</h3><p>在前面我们介绍了panic。在这里，我们来探讨一个问题：<strong>我们应该给在什么时候使用panic呢？</strong></p><p>我个人理解，panic适用于这样的场景：当发生的错误是我们不知道要怎么处理时（不打算优雅处理时），这种错误必须要中止程序运行了，那么，我们将使用到panic。</p><p>例如在我们学习Golang读写数据时，编写的小程序mycat（它用于打印文件内容，<a href="https://code81192.github.io/2021/09/28/golang/11_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%AD%EF%BC%89/#more">博文点击此处传送</a>）当中，程序根据用户输入的参数打开一个指定的文件，当文件不存在时，就可以抛出<code>panic</code>.</p><p>在多层嵌套的函数调用中调用 panic，可以马上中止当前函数的执行，所有的 defer 语句都会保证执行并把控制权交还给接收到 panic 的函数调用者。这样向上冒泡直到最顶层，并执行（每层的） defer，在栈顶处程序崩溃，并在命令行中用传给 panic 的值报告错误情况：这个终止过程就是 <em>panicking</em>。</p><p><strong>注意：</strong> 不要随意地用 panic 中止程序，应当尽力补救错误让程序能继续执行。 </p><h2 id="从-panic-中恢复（Recover）"><a href="#从-panic-中恢复（Recover）" class="headerlink" title="从 panic 中恢复（Recover）"></a>从 panic 中恢复（Recover）</h2><p>学会了panic的基本使用，我们需要思考一个问题，那就是，对于panic，我们只能中止程序运行吗？有没有从panic中恢复的方法？</p><p>这时，我们将使用到内建函数<code>recover()</code> 。它用于从panic或错误场景当中恢复，从而使得程序可以从panicking重新获得控制权，停止终止过程进而恢复程序的正常运行。</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;done...&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err:=<span class="built_in">recover</span>();err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;end...&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;start...&quot;</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;this is a error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start...</span><br><span class="line">done...</span><br><span class="line">this is a error</span><br><span class="line">end...</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> </p><ol><li><code>recover</code> 只能在 defer 修饰的函数中使用：用于取得 panic 调用中传递过来的错误值，如果是正常执行，调用 <code>recover</code> 会返回 nil，且没有其它效果。</li><li><strong>panic 会导致栈被展开直到 defer 修饰的 recover() 被调用或者程序中止。</strong></li></ol><p>以上就是defer-panic-and-recover机制。你也可以将其理解为像if、for一样的流程控制。它类似于Java当中的<code>try...catch</code> 机制。</p><p>我们在使用panic时，可以遵循Go 库的原则：即使在包的内部使用了 panic，在它的对外接口（API）中也必须用 recover 处理成返回显式的错误。</p><h2 id="自定义包中的错误处理和-panicking"><a href="#自定义包中的错误处理和-panicking" class="headerlink" title="自定义包中的错误处理和 panicking"></a>自定义包中的错误处理和 panicking</h2><p>在自定义包中的错误处理时，我们遵循以下原则：</p><ol><li>在包内部，总是应该和<code>panic</code> 中<code>recover</code>: 不应该显式的超出包范围的<code>panic</code> ()</li><li>向包的调用者返回错误值</li></ol><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> name []<span class="keyword">string</span></span><br><span class="line">name = <span class="built_in">append</span>(name, <span class="string">&quot;韩立&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;南宫婉&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> name &#123;</span><br><span class="line"></span><br><span class="line">err := SayHello(name[i])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHello</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//var ok bool</span></span><br><span class="line">err = fmt.Errorf(<span class="string">&quot;%v&quot;</span>,r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 注意： 抛出panic的函数必须在defer之后调用</span></span><br><span class="line">doSayHello(name)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSayHello</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(name)==<span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;名字不能是一个空字符串&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;hello %s\n&quot;</span>, name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello 韩立</span><br><span class="line">名字不能是一个空字符串</span><br><span class="line">hello 南宫婉</span><br></pre></td></tr></table></figure><p>在这个例子当中，包内从<code>panic</code>中<code>recover</code>，并返回给调用者错误提示，使得程序可以继续往下执行。重要的事情多说几遍，<strong>panic</strong>的使用应当严格地限制其场景，尽可能地使程序从<strong>panic</strong>中<strong>recover</strong></p><h2 id="使用闭包优雅地处理错误"><a href="#使用闭包优雅地处理错误" class="headerlink" title="使用闭包优雅地处理错误"></a>使用闭包优雅地处理错误</h2><p>像上面的代码一样，每当调用函数时，必须检查错误是否发生，这将增加代码的重复率，到处充斥着错误检查，这一点都不优雅。那么，在Golang中有没有机制像Java当中一样，可以统一地对错误进行处理呢？</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 = <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> name != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;Hello! &quot;</span>,name)</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;姓名不能为空&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">errorHandler(<span class="string">&quot;&quot;</span>,f1)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">errorHandler</span><span class="params">(name <span class="keyword">string</span>,f1 <span class="keyword">func</span>(s <span class="keyword">string</span>)</span> <span class="title">error</span>)</span>  &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>();r!=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">err := f1(name)</span><br><span class="line">check(err)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(e error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">姓名不能为空</span><br></pre></td></tr></table></figure><p>在这个例子当中，<code>errorHandler</code>是一个包装函数。它有两个参数，一个是<code>string</code> 类型的参数<code>name</code>,另一个则是匿名函数<code>f1</code> 。在<code>errorHandler</code>函数当中将调用函数<code>f1</code>,并通过<code>check</code>函数对程序执行进行校验这时，所有的错误都将被recover.</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>关于Golang当中的错误处理我们就初步介绍到这里。</p><p>本文当中涉及到的例子可以<a href="https://github.com/bingfenglai/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang中的读写数据之Gob</title>
      <link href="/2021/10/01/golang/13_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E4%B9%8BGob/"/>
      <url>/2021/10/01/golang/13_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E4%B9%8BGob/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/sunset-gd662f1f15_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在上一篇文章<a href="https://bingfenglai.github.io/2021/09/29/golang/12_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%8B%EF%BC%89/">《Golang中的读写数据（下）》</a>当中，我们学会了Golang当中对于JSON数据的解析，接下来，我们将学习Gob编码方式。</p><h2 id="什么是Gob"><a href="#什么是Gob" class="headerlink" title="什么是Gob"></a>什么是Gob</h2><p><strong>Gob的定义：</strong> Gob是Go自己的以二进制形式序列化和反序列化程序数据的格式，这种数据格式简称之为<strong>Gob</strong> (Go binary)。</p><p>它类似于Java语言当中的<code>Serialization</code> 。你可以在<code>encoding</code> 包中找到它。</p><span id="more"></span><h2 id="Gob可以做什么"><a href="#Gob可以做什么" class="headerlink" title="Gob可以做什么"></a>Gob可以做什么</h2><p>Gob 通常用于远程方法调用（RPC）参数和结果的传输，以及应用程序和机器之间的数据传输。</p><p> 那么，它与我们之前普遍用到的JSON有什么不同呢？</p><p>Gob因为是 Go自己的以二进制形式序列化和反序列化程序数据的格式，因此呢只能用于纯Go环境当中，并不适用于异构的环境。例如，它可以用于两个Go程序之间的通信。</p><h2 id="Gob的特点"><a href="#Gob的特点" class="headerlink" title="Gob的特点"></a>Gob的特点</h2><ol><li><p>Gob 文件或流是完全自描述的：里面包含的所有类型都有一个对应的描述，并且总是可以用 Go 解码，而不需要了解文件的内容。</p></li><li><p>只有<strong>可导出</strong>的字段会被编码，零值会被忽略。</p></li><li><p>在解码结构体的时候，只有<strong>同时匹配名称和可兼容类型</strong>的字段才会被解码。</p></li><li><p>当源数据类型增加新字段后，Gob 解码客户端仍然可以以这种方式正常工作：解码客户端会继续识别以前存在的字段。</p></li></ol><h2 id="使用Gob传输数据"><a href="#使用Gob传输数据" class="headerlink" title="使用Gob传输数据"></a>使用Gob传输数据</h2><p>和 JSON 的使用方式一样，Gob 使用通用的 <code>io.Writer</code> 接口，通过 <code>NewEncoder()</code> 函数创建 <code>Encoder</code> 对象并调用 <code>Encode()</code>；相反的过程使用通用的 <code>io.Reader</code> 接口，通过 <code>NewDecoder()</code> 函数创建 <code>Decoder</code> 对象并调用 <code>Decode()</code>。</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/gob&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修仙者</span></span><br><span class="line"><span class="keyword">type</span> Immortal <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Age    <span class="keyword">int</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SimpleImmortal <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Age    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf  bytes.Buffer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hanli = Immortal&#123;</span><br><span class="line">Name:   <span class="string">&quot;韩立&quot;</span>,</span><br><span class="line">Age:    <span class="number">18</span>,</span><br><span class="line">Gender: <span class="string">&quot;男性&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;发送数据: &quot;</span>,hanli)</span><br><span class="line">sendMsg(&amp;hanli)</span><br><span class="line">fmt.Println(<span class="string">&quot;buf中的数据：&quot;</span>,buf)</span><br><span class="line"><span class="keyword">var</span> i SimpleImmortal</span><br><span class="line">msg, _ := receiveMsg(i)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;接收到数据：&quot;</span>,msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendMsg</span><span class="params">(immortal *Immortal)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">enc :=gob.NewEncoder(&amp;buf)</span><br><span class="line"><span class="keyword">return</span> enc.Encode(immortal)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receiveMsg</span><span class="params">(immortal SimpleImmortal)</span> <span class="params">(SimpleImmortal,error)</span></span> &#123;</span><br><span class="line">dec := gob.NewDecoder(&amp;buf)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> immortal,dec.Decode(&amp;immortal)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">发送数据:  &#123;韩立 <span class="number">18</span> 男性&#125;</span><br><span class="line">buf中的数据： &#123;[<span class="number">50</span> <span class="number">255</span> <span class="number">129</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span> <span class="number">8</span> <span class="number">73</span> <span class="number">109</span> <span class="number">109</span> <span class="number">111</span> <span class="number">114</span> <span class="number">116</span> <span class="number">97</span> <span class="number">108</span> <span class="number">1</span> <span class="number">255</span> <span class="number">130</span> <span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">78</span> <span class="number">97</span> <span class="number">109</span> <span class="number">101</span> <span class="number">1</span> <span class="number">12</span> <span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">65</span> <span class="number">103</span> <span class="number">101</span> <span class="number">1</span> <span class="number">4</span> <span class="number">0</span> <span class="number">1</span> <span class="number">6</span> <span class="number">71</span> <span class="number">101</span> <span class="number">110</span> <span class="number">100</span> <span class="number">101</span> <span class="number">114</span> <span class="number">1</span> <span class="number">12</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">21</span> <span class="number">255</span> <span class="number">130</span> <span class="number">1</span> <span class="number">6</span> <span class="number">233</span> <span class="number">159</span> <span class="number">169</span> <span class="number">231</span> <span class="number">171</span> <span class="number">139</span> <span class="number">1</span> <span class="number">36</span> <span class="number">1</span> <span class="number">6</span> <span class="number">231</span> <span class="number">148</span> <span class="number">183</span> <span class="number">230</span> <span class="number">128</span> <span class="number">167</span> <span class="number">0</span>] <span class="number">0</span> <span class="number">0</span>&#125;</span><br><span class="line">接收到数据： &#123;韩立 <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>关于Gob的内容我们就简单介绍到这里。本文当中涉及到的例子可以<a href="https://github.com/code81192/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p><p>在下一篇文章当中，我们将一起来学习Golang当中的错误处理相关的内容。</p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang中的读写数据（下）--JSON数据的编码与解码</title>
      <link href="/2021/09/29/golang/12_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2021/09/29/golang/12_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/woman-5590119_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在上一篇文章<a href="https://bingfenglai.github.io/2021/09/28/golang/11_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%AD%EF%BC%89/">《Golang中的读写数据（中）》</a>中，我们学习了在Golang中如何读取命令行参数，接下来我们将学习Golang中的数据格式化。</p><p>我们都知道数据要在网络当中进行传输，或者是将其保存到文件当中，就要必须对其编码和解码。常见的编码格式有JSON和XML等。</p><span id="more"></span><h3 id="一些概念的补充"><a href="#一些概念的补充" class="headerlink" title="一些概念的补充"></a>一些概念的补充</h3><p><strong>编码：</strong> 从特定数据结构到数据流这一过程</p><p><strong>解码：</strong> 解码是编码的逆过程，即从数据流到数据结构这一过程</p><p><strong>序列化：</strong> 将内存当中的数据抓换成指定的格式的过程，例如将一个Java对象转为一个字符串</p><p>接下来我们将介绍在Golang中将数据编码为JSON的相关内容，在这一部分内容当中，我们将使用到<code>encoding</code>这个库</p><h2 id="JSON数据操作"><a href="#JSON数据操作" class="headerlink" title="JSON数据操作"></a>JSON数据操作</h2><p>为了演示这一部分的内容，我将之前我们学习结构体时用到的结构体抄写在下面</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修仙者</span></span><br><span class="line"><span class="keyword">type</span> Immortal <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Age    <span class="keyword">int</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后大家请看下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修仙者</span></span><br><span class="line"><span class="keyword">type</span> Immortal <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Age    <span class="keyword">int</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">immortal := &amp;Immortal&#123;</span><br><span class="line">Name:   <span class="string">&quot;韩立&quot;</span>,</span><br><span class="line">Age:    <span class="number">18</span>,</span><br><span class="line">Gender: <span class="string">&quot;男性&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将修仙者韩立编码为json的[]byte</span></span><br><span class="line">jsonByteImmortal, _ := json.Marshal(immortal)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, jsonByteImmortal)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;Name&quot;</span>:<span class="string">&quot;韩立&quot;</span>,<span class="attr">&quot;Age&quot;</span>:<span class="number">18</span>,<span class="attr">&quot;Gender&quot;</span>:<span class="string">&quot;男性&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>上面用到的<code>json.Marshal</code>函数的函数签名是<code>func Marshal(v interface&#123;&#125;) ([]byte, error)</code> 它返回的是byte数组，因此打印时需要指定格式。</p><p>JSON 与 Go 类型对应如下：</p><ul><li>bool 对应 JSON 的 boolean</li><li>float64 对应 JSON 的 number</li><li>string 对应 JSON 的 string</li><li>nil 对应 JSON 的 null</li></ul><p>不是所有的数据都可以编码为 JSON 类型：只有验证通过的数据结构才能被编码：</p><ul><li>JSON 对象只支持字符串类型的 key；要编码一个 Go map 类型，map 必须是 map[string]T（T是 <code>json</code> 包中支持的任何类型）</li><li>Channel，复杂类型和函数类型不能被编码</li><li>不支持循环数据结构；它将引起序列化进入一个无限循环</li><li>指针可以被编码，实际上是对指针指向的值进行编码（或者指针是 nil）</li></ul><h2 id="反序列化操作"><a href="#反序列化操作" class="headerlink" title="反序列化操作"></a>反序列化操作</h2><p>在Golang中如何将一个JSON转换为Golang中的数据结构呢？</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修仙者</span></span><br><span class="line"><span class="keyword">type</span> Immortal <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Age    <span class="keyword">int</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">immortal := &amp;Immortal&#123;</span><br><span class="line">Name:   <span class="string">&quot;韩立&quot;</span>,</span><br><span class="line">Age:    <span class="number">18</span>,</span><br><span class="line">Gender: <span class="string">&quot;男性&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonImmortal, _ := json.Marshal(immortal)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, jsonImmortal)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 事先知道json对应的数据类型时</span></span><br><span class="line"> <span class="keyword">var</span> jsonValue Immortal</span><br><span class="line"></span><br><span class="line">json.Unmarshal(jsonImmortal, &amp;jsonValue)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;name&quot;</span>,jsonValue.Name)</span><br><span class="line">fmt.Println(<span class="string">&quot;age&quot;</span>,jsonValue.Age)</span><br><span class="line">fmt.Println(<span class="string">&quot;gender&quot;</span>,jsonValue.Gender)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 不知道json对应的数据结构</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">json.Unmarshal(jsonImmortal,&amp;m)</span><br><span class="line"></span><br><span class="line">jsonMap := m.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> jsonMap &#123;</span><br><span class="line">printJson(key,value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printJson</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> value.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">fmt.Println(key,<span class="string">&quot;value is a string: &quot;</span>,value)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">fmt.Println(key,<span class="string">&quot;value is int type: &quot;</span>,value)</span><br><span class="line"><span class="keyword">case</span> []<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">fmt.Println(key,<span class="string">&quot;value is a array&quot;</span>,value)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">m:= value.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">printJson(k,v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;Name&quot;:&quot;韩立&quot;,&quot;Age&quot;:18,&quot;Gender&quot;:&quot;男性&quot;&#125;</span><br><span class="line">name 韩立</span><br><span class="line">age 18</span><br><span class="line">gender 男性</span><br><span class="line">Name value is a string:  韩立</span><br><span class="line">Age value is int type:  18</span><br><span class="line">Gender value is a string:  男性</span><br></pre></td></tr></table></figure><p>在这个例子当中，存在着两种情况：</p><p>第一种情况：<strong>我们事先知道JSON数据对应的数据结构</strong>，则调用<code>json.Unmarshal</code>函数将其解码（也可以理解为反序列化）并存入该数据结构指针变量指向的内存地址当中；</p><p>第二种情况：<strong>我们事先不知道JSON数据对应的数据结构</strong>，则可以使用<strong>类型断言</strong>技术得到JSON数据当中<code>key: value</code>对应的值。</p><h2 id="解码以及编码JSON数据流"><a href="#解码以及编码JSON数据流" class="headerlink" title="解码以及编码JSON数据流"></a>解码以及编码JSON数据流</h2><p>json 包提供 Decoder 和 Encoder 类型来支持常用 JSON 数据流读写。NewDecoder 和 NewEncoder 函数分别封装了 io.Reader 和 io.Writer 接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDecoder</span><span class="params">(r io.Reader)</span> *<span class="title">Decoderfunc</span> <span class="title">NewEncoder</span><span class="params">(w io.Writer)</span> *<span class="title">Encoder</span></span></span><br></pre></td></tr></table></figure><p>要想把 JSON 直接写入文件，可以使用 json.NewEncoder 初始化文件（或者任何实现 io.Writer 的类型），并调用 Encode()；反过来与其对应的是使用 json.NewDecoder 和 Decode() 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDecoder</span><span class="params">(r io.Reader)</span> *<span class="title">Decoderfunc</span> <span class="params">(dec *Decoder)</span> <span class="title">Decode</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>在Golang中解析转换JSON数据的内容我们就简单介绍到这里。本文当中涉及到的例子可以<a href="https://github.com/code81192/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p><p>在下一篇文章当中，我们将一起来学习Golang当中一种独有的编码格式<code>Gob</code> </p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang中的读写数据（中）</title>
      <link href="/2021/09/28/golang/11_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
      <url>/2021/09/28/golang/11_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/yoga-2176668_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在上一篇文章《<a href="https://bingfenglai.github.io/2021/09/24/golang/10_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE(%E4%B8%8A)/">Golang中的读写数据（上）</a>》当中，我们介绍了Golang中一些简单的文件读写、拷贝操作，接下来，我们将继续学习Golang中的读写数据的相关知识点。</p><span id="more"></span><h2 id="从命令行读取参数"><a href="#从命令行读取参数" class="headerlink" title="从命令行读取参数"></a>从命令行读取参数</h2><p>在一些场景当中，我们在执行一个软件，有时候需要传入一些初始化的信息，例如连接数据库的<code>username</code>和<code>password</code>等属性。那么，在Golang中是如何读取参数的呢？请看下面的例子:</p><h3 id="使用os-Args-获取参数"><a href="#使用os-Args-获取参数" class="headerlink" title="使用os.Args 获取参数"></a>使用<code>os.Args</code> 获取参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(os.Args);i++ &#123;</span><br><span class="line">sayHello(os.Args[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;参数为空&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(name... <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;hello!&quot;</span>,name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/image-20210927204103589.png" alt="image-20210927204103589"></p><p><strong>注意：</strong></p><p>这个命令行参数会放置在切片 <code>os.Args[]</code> 中（以空格分隔），从索引1开始（<code>os.Args[0]</code> 放的是程序本身的名字）。函数 <code>strings.Join</code> 以空格为间隔连接这些参数。</p><h3 id="使用flag-Args获取参数"><a href="#使用flag-Args获取参数" class="headerlink" title="使用flag.Args获取参数"></a>使用<code>flag.Args</code>获取参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, arg := <span class="keyword">range</span> flag.Args() &#123;</span><br><span class="line">sayHello(arg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(name... <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;hello!&quot;</span>,name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/image-20210927224440371.png" alt="image-20210927224440371"></p><p><strong>注意：</strong></p><p><code>flag.Arg(0)</code> 就是第一个真实的 flag，而不是像 <code>os.Args(0)</code> 放置程序的名字。</p><h3 id="一个例子：使用缓存读取文件与flag-Args的综合应用"><a href="#一个例子：使用缓存读取文件与flag-Args的综合应用" class="headerlink" title="一个例子：使用缓存读取文件与flag.Args的综合应用"></a>一个例子：使用缓存读取文件与<code>flag.Args</code>的综合应用</h3><p>接触过Linux系统的小伙伴们应该经常会<code>cat filename</code>这个命令，接下来，我们将使用Golang实现这个小工具.</p><h4 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h4><p>我们需要一个小工具来打印文件的内容，当文件不存在时给用户一个友好的提示。</p><h4 id="功能设计"><a href="#功能设计" class="headerlink" title="功能设计"></a>功能设计</h4><ol><li>根据用户输入的文件名读取文件到缓存并分批次打印</li><li>当文件不存在时输出”不存在文件 {文件名}”</li></ol><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">filename :=flag.Arg(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> filename==<span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Command Usage Format: mycat filename&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">open, err := os.Open(filename)</span><br><span class="line"><span class="keyword">defer</span> open.Close()</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">myCat(bufio.NewReader(open))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myCat</span><span class="params">(reader *bufio.Reader)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  &#123;</span><br><span class="line">buf, err := reader.ReadBytes(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">fmt.Fprintf(os.Stdout, <span class="string">&quot;%s\n&quot;</span>, buf)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><ol><li>当文件存在时打印文件内容：</li></ol><p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/image-20210927231646066.png" alt="image-20210927231646066"></p><ol start="2"><li>当文件不存在时给出提示：</li></ol><p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/image-20210927231918164.png" alt="image-20210927231918164"></p><h4 id="提个问题：这个程序能满足需求吗？"><a href="#提个问题：这个程序能满足需求吗？" class="headerlink" title="提个问题：这个程序能满足需求吗？"></a>提个问题：这个程序能满足需求吗？</h4><p>大家可以思考一下，如果被打印的文件是一个只有一行数据的大文件，会出现什么情况？</p><p>因此，为了避免出现这个情况，我们将对<code>mycat</code>进行改造。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">filename :=flag.Arg(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> filename==<span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Command Usage Format: mycat filename&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file, err := os.Open(filename)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myCatV2(bufio.NewReader(file))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myCatV2</span><span class="params">(reader *bufio.Reader)</span></span> &#123;</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">512</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  &#123;</span><br><span class="line">n, err := reader.Read(buf)</span><br><span class="line">fmt.Fprintf(os.Stdout,<span class="string">&quot;%s&quot;</span>,buf[<span class="number">0</span>:n])</span><br><span class="line"><span class="keyword">if</span> err ==io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这一版当中，我们指定了缓存区的大小，它是一个512位的<code>byte</code>数组。</p><p>输出：</p><p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/image-20210928002030354.png" alt="image-20210928002030354"></p><p>我们指定了缓冲区的大小，这样就避免了将整个文件都加载到内存当中。</p><p>当然，大家可以继续对程序进行改进，例如引入协程等技术，这便不在本文的讨论当中了。</p><h2 id="重要的一点：使用defer关闭文件"><a href="#重要的一点：使用defer关闭文件" class="headerlink" title="重要的一点：使用defer关闭文件"></a>重要的一点：使用<code>defer</code>关闭文件</h2><p>在前面的文章当中，我们介绍了<code>defer</code>关键字的作用：他将在函数退出时（return之后）执行其修饰的语句。在这里，我们使用其来在<code>main</code>函数退出前关闭文件。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>关于Golang中读取命令行参数以及与文件读写操作的综合应用我们就介绍到这里。本文当中涉及到的例子可以<a href="https://github.com/code81192/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p><p>在下一篇文章当中我们将一起来学习Golang中的数据格式化以及数据网络传输等内容。</p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang中的读写数据（上）</title>
      <link href="/2021/09/24/golang/10_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE(%E4%B8%8A)/"/>
      <url>/2021/09/24/golang/10_golang%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE(%E4%B8%8A)/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/spring-2298279_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在前面的文章当中，我们学会了如何去搭建Golang开发环境、学习了Golang当中常见的数据结构、学习了基本流程控制语句、学习了函数和结构体等内容，接下来我们将开始学习Golang当中的文件读写。</p><span id="more"></span><h2 id="读取用户在控制台的输入"><a href="#读取用户在控制台的输入" class="headerlink" title="读取用户在控制台的输入"></a>读取用户在控制台的输入</h2><p>在Golang当中，如何读取用户在控制台的输入呢？在这里，我们可以使用<code>fmt</code>包当中<code>Scan</code>开头的函数。</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> firstname,lastname <span class="keyword">string</span></span><br><span class="line">fmt.Println(<span class="string">&quot;请输入您的姓名：&quot;</span>)</span><br><span class="line">_, _ = fmt.Scanln(&amp;firstname, &amp;lastname)</span><br><span class="line">fmt.Printf(<span class="string">&quot;你好！%s · %s\n&quot;</span>, lastname, firstname)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请输入您的姓名：</span><br><span class="line">韩 立</span><br><span class="line">你好！立 · 韩</span><br></pre></td></tr></table></figure><p><code>Scanln</code> 扫描来自标准输入的文本，将空格分隔的值依次存放到后续的参数内，直到碰到换行。<code>Scanf</code> 与其类似，除了 <code>Scanf</code> 的第一个参数用作格式字符串，用来决定如何读取。<code>Sscan</code> 和以 <code>Sscan</code> 开头的函数则是从字符串读取，除此之外，与 <code>Scanf</code> 相同。如果这些函数读取到的结果与您预想的不同，你可以检查成功读入数据的个数和返回的错误。</p><p>除此之外，我们也可以使用 <code>bufio</code> 包提供的缓冲读取（buffered reader）来读取数据</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;请输入一段文字&quot;</span>)</span><br><span class="line">inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line">s,err := inputReader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;你输入的是：&quot;</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请输入一段文字</span><br><span class="line">去年今日此门中 人面桃花相映红。人面不知何处在 桃花依旧笑春风。</span><br><span class="line">你输入的是：</span><br><span class="line">去年今日此门中 人面桃花相映红。人面不知何处在 桃花依旧笑春风。</span><br></pre></td></tr></table></figure><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id="文件读操作"><a href="#文件读操作" class="headerlink" title="文件读操作"></a>文件读操作</h3><p>在 Go 语言中，文件使用指向 <code>os.File</code> 类型的指针来表示的，也叫做文件句柄。</p><h4 id="按行读取"><a href="#按行读取" class="headerlink" title="按行读取"></a>按行读取</h4><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">inputFile, err := os.Open(<span class="string">&quot;G:\\06_golangProject\\golang\\doc\\筑基部分\\10_golang中的读写数据.md&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> inputFile.Close()</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">input :=bufio.NewReader(inputFile)</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">readString, err := input.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">fmt.Println(readString)</span><br><span class="line"><span class="keyword">if</span> err==io.EOF &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子当中，我们使用<code>os.Open</code>打开一个文件，并在循环当中逐行地打印该文件，直到打印完该文件。</p><h4 id="带缓冲的文件读取"><a href="#带缓冲的文件读取" class="headerlink" title="带缓冲的文件读取"></a>带缓冲的文件读取</h4><p>很不幸的是，在很多情况下，文件的内容不是按行划分的，甚至有时候文件是一个二进制文件。这时，我们应当如何去读取它呢？</p><p>请看下面的这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">inputFile, err := os.Open(<span class="string">&quot;G:\\06_golangProject\\golang\\doc\\筑基部分\\10_golang中的读写数据.md&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> inputFile.Close()</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>  &#123;</span><br><span class="line">_, err := inputFile.Read(buf)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err==io.EOF &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(buf))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义了一个<code>[]byte</code>类型的缓存，在读取文件时，将读到的内容存入这个缓存中并进行打印。这样，我们就不需要去在意文件当中内容是如何划分的了。</p><h3 id="文件写操作"><a href="#文件写操作" class="headerlink" title="文件写操作"></a>文件写操作</h3><p>简单地介绍了Golang中的文件读操作，再讲一下文件的写操作，请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">file, err := os.OpenFile(<span class="string">&quot;古丹丹方.txt&quot;</span>, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;打开文件出错&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span>  file.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个缓冲区</span></span><br><span class="line">writer := bufio.NewWriter(file)</span><br><span class="line"></span><br><span class="line">s := <span class="string">&quot;Hello World\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="comment">// 写入缓冲区</span></span><br><span class="line">_, _ = writer.WriteString(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将缓冲区的数据写入文件</span></span><br><span class="line">_ = writer.Flush()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来我们看一下这个<code>os.OpenFile(name string, flag int, perm FileMode) (*File, error)</code>函数。我们可以看到，它有三个参数，第一个参数为文件名，第二个参数是打开标志（我们以只写打开文件，如果文件不存在则创建它），第三个参数是文件权限。</p><p>对于第二个参数，当存在多个标志时使用逻辑运算符<code>|</code>连接，常见的标志有以下几个：</p><ul><li><code>os.O_RDONLY</code>：只读</li><li><code>os.O_WRONLY</code>：只写</li><li><code>os.O_CREATE</code>：创建：如果指定文件不存在，就创建该文件。</li><li><code>os.O_TRUNC</code>：截断：如果指定文件已存在，就将该文件的长度截为0。</li></ul><p>在读文件的时候，文件的权限是被忽略的，所以在使用 <code>OpenFile</code> 时传入的第三个参数可以用0。而在写文件时，不管是 Unix 还是 Windows，都需要使用 0666。</p><h2 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h2><p>不知还有道友记得没，韩立在筑基期的洞府里用两株草药换了他雷师伯的丹方，他雷师伯当然不会直接将古方给他，而是将丹方拷贝了一份到玉简给了韩立。</p><p>那么？在Golang中如何实现将文件<code>source.txt</code>拷贝到<code>target.txt</code>呢？请看下面的这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">copyFile(<span class="string">&quot;古丹丹方.txt&quot;</span>,<span class="string">&quot;给韩立的玉简.txt&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;拷贝完成！&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyFile</span><span class="params">(source, target <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">openFile, err := os.Open(source)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;打开源文件出错&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> openFile.Close()</span><br><span class="line"></span><br><span class="line">createFile, err := os.Create(target)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;创建目标文件出错&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> createFile.Close()</span><br><span class="line"></span><br><span class="line">written, err := io.Copy(createFile, openFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(written)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实看起来还是很简单的，直接使用<code>io.Copy</code>函数就OK了，但是要注意的是<strong>第一个参数是目标文件名，第二个参数才是源文件</strong>。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>以上就是Golang关于文件读写的上半部分内容，本文当中涉及到的例子可以<a href="https://github.com/code81192/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p><p>在下一篇文章当中我们将一起来学习Golang读取命令行参数和Golang中的数据网络传输等内容。</p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang入门学习之接口（interface）</title>
      <link href="/2021/09/12/golang/09_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E6%8E%A5%E5%8F%A3/"/>
      <url>/2021/09/12/golang/09_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/avenue-815297_1920.jpg"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在上一篇文章<a href="https://bingfenglai.github.io/2021/09/09/golang/08_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E6%96%B9%E6%B3%95/">《Golang入门学习之方法（method）》</a>当中，我们学习了Golang当中的方法的定义与运用，在接下来的这篇文章当中，我们将一起来学习Goalng的接口（interface）。</p><h2 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h2><p>接口是定义了一组需要被实现的方法的<strong>抽象类型</strong>，实现接口的数据类型可以视为接口的实例。接口由一组方法与一个接口类型组成。声明格式如下：</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    方法名(形参列表) (返回值列表)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照Golang的编程风格（约定），只包含一个方法的接口的名字由方法名加 <code>[e]r</code> 后缀组成，例如 <code>Printer</code>、<code>Reader</code>、<code>Writer</code>、<code>Logger</code>、<code>Converter</code> 等等。还有一些不常用的方式（当后缀 <code>er</code> 不合适时），比如 <code>Recoverable</code>，此时接口名以 <code>able</code> 结尾，或者以 <code>I</code> 开头（像  <code>Java</code> 中那样）。</p><p>Go 语言中的接口都很简短，通常它们会包含 0 个、最多 3 个方法。</p><p>请看下面这个例子：</p><p>首先，我们在interfaces包中声明一个<code>SpiritualRootAble</code>（表示具备修行的能力,现了灵根接口的凡人即可修炼）接口</p><p><code>src/go_code/interface/interfaces/spiritual_root.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> interfaces</span><br><span class="line"></span><br><span class="line"><span class="comment">// 灵根接口，实现了灵根接口的凡人即可修炼</span></span><br><span class="line"><span class="keyword">type</span> SpiritualRootAble <span class="keyword">interface</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成灵根</span></span><br><span class="line">GenSpiritualRootNames() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取生成的灵根</span></span><br><span class="line">SpiritualRoot() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修行方法</span></span><br><span class="line">Practice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，我们在model包当中声明一个凡人结构体（<code>mortal</code>） 并实现<code>SpiritualRootAble</code>接口</p><p><code>src/go_code/interface/model/mortal.go</code> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/big&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 凡人</span></span><br><span class="line"><span class="keyword">type</span> Mortal <span class="keyword">struct</span> &#123;</span><br><span class="line">name ,</span><br><span class="line">gender ,</span><br><span class="line">spiritualRoot <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMortal</span><span class="params">(name, gender <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> <span class="title">Mortal</span></span> &#123;</span><br><span class="line">mortal:=Mortal&#123;</span><br><span class="line">name:   name,</span><br><span class="line">gender: gender,</span><br><span class="line">age:    age,</span><br><span class="line">&#125;</span><br><span class="line">mortal.spiritualRoot = mortal.GenSpiritualRootNames()</span><br><span class="line"><span class="keyword">return</span> mortal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv Mortal)</span> <span class="title">SpiritualRoot</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> &amp;recv.spiritualRoot == <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;没有灵根&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> recv.spiritualRoot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv Mortal)</span><span class="title">Practice</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(recv.name,<span class="string">&quot;开始修行...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv Mortal)</span> <span class="title">GenSpiritualRootNames</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">gsrn := []<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;金灵根&quot;</span>,<span class="string">&quot;水灵根&quot;</span>,<span class="string">&quot;木灵根&quot;</span>,<span class="string">&quot;火灵根&quot;</span>,<span class="string">&quot;土灵根&quot;</span>,<span class="string">&quot;没有灵根&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">index, _ := rand.Int(rand.Reader, big.NewInt(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  gsrn[index.Int64()]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，我们在main中使用他们</p><p><code>src/go_code/interface/main/main.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;go_code/interface/interfaces&quot;</span></span><br><span class="line"><span class="string">&quot;go_code/interface/model&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 声明了一个SpiritualRootAble接口类型的变量</span></span><br><span class="line"> <span class="keyword">var</span> sr interfaces.SpiritualRootAble</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 降生了一个凡人</span></span><br><span class="line"> mortal := model.NewMortal(<span class="string">&quot;韩立&quot;</span>,<span class="string">&quot;男性&quot;</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 接口变量指向凡人实例</span></span><br><span class="line">sr = mortal</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取凡人的灵根</span></span><br><span class="line">fmt.Println(sr.SpiritualRoot())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 凡人开始修炼</span></span><br><span class="line">sr.Practice()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">火灵根</span><br><span class="line">韩立 开始修行...</span><br></pre></td></tr></table></figure><p>可以看到：</p><p>在Golang中并需要显示地声明类型实现了某一接口（不需要如同Java那样<code>class implemments interfacesName</code>），只要类型实现了接口当中定义的方法集，类型即是实现了该接口。</p><p>实现某个接口的类型（除了实现接口方法外）可以有其他的方法。</p><p>一个类型可以实现多个接口(实际上<code>mortal</code>还实现了空接口，关于空接口的内容请继续往下看)。</p><p>接口类型可以包含一个实例的引用， 该实例的类型实现了此接口（接口是动态类型）。</p><h2 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h2><p>空接口即为不包含任何方法的接口。任何类型都实现了空接口。空接口有点类似于Java当中的Object的概念</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Any <span class="keyword">interface</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="接口嵌套接口"><a href="#接口嵌套接口" class="headerlink" title="接口嵌套接口"></a>接口嵌套接口</h2><p>一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。</p><p>比如接口 <code>File</code> 包含了 <code>ReadWrite</code> 和 <code>Lock</code> 的所有方法，它还额外有一个 <code>Close()</code> 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWrite <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(b Buffer) <span class="keyword">bool</span></span><br><span class="line">    Write(b Buffer) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Lock <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">interface</span> &#123;</span><br><span class="line">    ReadWrite</span><br><span class="line">    Lock</span><br><span class="line">    Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Golang中的类型断言"><a href="#Golang中的类型断言" class="headerlink" title="Golang中的类型断言"></a>Golang中的类型断言</h2><p>对于一个接口类型变量<code>varI</code>中可以包含任何类型的值，so,必须有一种方式来检测它的<strong>动态类型</strong>，也就是运行时变量var中存储的值的实际类型。而这，就是<strong>类型断言</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v := varI.(T)</span><br></pre></td></tr></table></figure><p>类型断言可能是无效的，虽然编译器会尽力检查转换是否有效，但是它不可能预见所有的可能性。如果转换在程序运行时失败会导致错误发生。更安全的方式是使用以下形式来进行类型断言：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v,ok :=varI.(T);ok&#123;</span><br><span class="line">    do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果转换合法，<code>v</code> 是 <code>varI</code> 转换到类型 <code>T</code> 的值，<code>ok</code> 会是 <code>true</code>；否则 <code>v</code> 是类型 <code>T</code> 的零值，<code>ok</code> 是 <code>false</code>，也没有运行时错误发生。</p><p>如果我们只是需要判断<code>varI</code>是否为T类型而不需要获取类型T的值时,可以这样做：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _,ok := varI.(T);ok&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们继续沿用上面的例子讲类型断言这部分的内容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;go_code/interface/interfaces&quot;</span></span><br><span class="line"><span class="string">&quot;go_code/interface/model&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 声明了一个SpiritualRootAble接口类型的变量</span></span><br><span class="line"> <span class="keyword">var</span> sr interfaces.SpiritualRootAble</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 降生了一个凡人</span></span><br><span class="line"> mortal := model.NewMortal(<span class="string">&quot;韩立&quot;</span>,<span class="string">&quot;男性&quot;</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 接口变量指向凡人实例</span></span><br><span class="line">sr = mortal</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型断言</span></span><br><span class="line"><span class="keyword">if</span> v,ok :=sr.(*model.Mortal);ok&#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;&#123;韩立 男性 金灵根 <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，我们在实现<code>SpiritualRootAble</code> 时方法的receiver类型为<code>*Mortal</code> ，即凡人的指针类型。因此实际上实现SpiritualRootAble接口的是*Mortal，因此在进行类型断言时T为<code>*Mortal</code> 。我们在使用类型断言的时候要注意这一点，不然编译器会报错。</p><h2 id="类型断言的应用"><a href="#类型断言的应用" class="headerlink" title="类型断言的应用"></a>类型断言的应用</h2><p>在Golang中，我们如何测试一个值是否实现了某一接口呢？答案就是通过类型断言</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m interfaceTypeName</span><br><span class="line"><span class="keyword">if</span> _,ok := m.(interfaceTypeName);ok &#123;</span><br><span class="line">fmt.Println(ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>接口可以理解为一种契约，实现类型必须满足它，它描述了类型的行为，规定类型可以做什么。接口彻底将类型能做什么，以及如何做分离开来，使得相同接口的变量在不同的时刻表现出不同的行为，这就是多态的本质。</p><p>在golang中：</p><ul><li>指针方法可以通过指针调用</li><li>值方法可以通过值调用</li><li>接收者是值的方法可以通过指针调用，因为指针会首先被解引用</li><li>接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址</li></ul><p>将一个值赋值给一个接口时，编译器会确保所有可能的接口方法都可以在此值上被调用，因此不正确的赋值在编译期就会失败。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>关于Golang当中接口的知识点我就简单介绍到这里。本文当中涉及到的例子可以<a href="https://github.com/code81192/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。从下一篇文章开始，我们将开启<strong>筑基系列</strong>的学习，具体涉及到的知识点有：反射、文件操作、数据交换、错误处理、Go协程（goroutine）和通道（channel）等内容。欢迎各位小伙伴订阅我的博客👊。</p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang入门学习之方法（method）</title>
      <link href="/2021/09/09/golang/08_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E6%96%B9%E6%B3%95/"/>
      <url>/2021/09/09/golang/08_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/young-woman-1745173_1920.jpg" alt="young-woman-1745173_1920"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在上一篇文章<a href="https://bingfenglai.github.io/2021/09/07/golang/07_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E7%BB%93%E6%9E%84%E4%BD%93/">《Golang入门学习之结构体（struct）》</a>当中，我们学习了Golang当中结构体（struct）的知识点，接下来我们讲学习Golang当中的方法（method）。</p><h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><p>在Golang当中，方法是作用在接收者（receiver）上的一个函数，接收者是某种类型的变量。因此，方法是一种特殊的函数。这里的接收者可以（几乎，接收者类型不能是一个接口类型或指针类型）任何类型，不仅仅是结构体类型，也就意味着，几乎任何类型都可以方法，甚至是函数类型，或者是int、bool等的别名类型。</p><p>我们可以这样理解：一个类型（比如说是结构体）加上它的方法就等价于面向对象语言当中的一个类。</p><span id="more"></span><h3 id="方法的定义格式"><a href="#方法的定义格式" class="headerlink" title="方法的定义格式"></a>方法的定义格式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv receiver_type)</span> <span class="title">methodName</span><span class="params">(parameter_list)</span> <span class="params">(return_value_list)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p><code>recv</code> 就像是面向对象语言中的 <code>this</code> 或 <code>self</code>，但是 Golang 中并没有这两个关键字。随个人喜好，你可以使用 <code>this</code> 或 <code>self</code> 作为 receiver 的名字。</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>在 Golang 中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在在不同的源文件，唯一的要求是：它们必须是同一个包的。请看下面这个例子：</p><p>我们在<code>src/go_code/method/model/immortal.go</code> 当中定义了一个修仙者类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修仙者</span></span><br><span class="line"><span class="keyword">type</span> immortal <span class="keyword">struct</span> &#123;</span><br><span class="line">name   <span class="keyword">string</span></span><br><span class="line">age    <span class="keyword">int</span></span><br><span class="line">gender <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们在<code>src/go_code/method/model/immortal_method.go</code> 当中定义<code>immortal</code> 类型的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewImmortal</span><span class="params">(age <span class="keyword">int</span>, name, gender <span class="keyword">string</span>)</span> *<span class="title">immortal</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;immortal&#123;</span><br><span class="line">name:   name,</span><br><span class="line">age:    age,</span><br><span class="line">gender: gender,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Getter</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv *immortal)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> recv.name</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>再然后，我们再main包当中使用它</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;go_code/method/model&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := model.NewImmortal(<span class="number">18</span>,<span class="string">&quot;韩立&quot;</span>,<span class="string">&quot;男&quot;</span>)</span><br><span class="line">name :=i.GetName()</span><br><span class="line">fmt.Println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">韩立</span><br></pre></td></tr></table></figure><h2 id="函数与方法的区别"><a href="#函数与方法的区别" class="headerlink" title="函数与方法的区别"></a>函数与方法的区别</h2><p>函数和方法都是一段可复用的代码段。他们的区别在于函数是面向过程的，方法是面向对象。从调用上来看，函数通过函数名进行调用，而方法则通过与实例关联的变量进行调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"><span class="comment">// 方法调用</span></span><br><span class="line">immortal := model.NewImmortal(<span class="number">18</span>,<span class="string">&quot;韩立&quot;</span>,<span class="string">&quot;男&quot;</span>)</span><br><span class="line">immortal.GetName()</span><br></pre></td></tr></table></figure><p>再看Golang当中，方法由接收者类型、方法名、形参列表、返回值列表和方法体五部分构成，并且接收者必须有一个显式的名字，这个名字必须在方法中被使用。而且，接收者类型（receiver_type）必须在和方法同样的包中被声明。</p><h2 id="Golang中方法的其他特性"><a href="#Golang中方法的其他特性" class="headerlink" title="Golang中方法的其他特性"></a>Golang中方法的其他特性</h2><p>在Golang当中，接收者类型关联的方法不写在类型结构里面（面向对象语言Java的方法是在类当中进行定义的）。因此，在Golang当中方法与接收者类型的耦合更加地宽松，也就是说，数据（字段）与其对应的行为是相互独立。</p><h2 id="接收者类型可以是一个值而不是类型的指针吗？"><a href="#接收者类型可以是一个值而不是类型的指针吗？" class="headerlink" title="接收者类型可以是一个值而不是类型的指针吗？"></a>接收者类型可以是一个值而不是类型的指针吗？</h2><p>接收者类型可以是一个值而不是类型的指针吗？答案是可以的。但是，基于性能方面的考虑，我并不建议大家这样做。因为接收者是作为值传递给对应的方法的，这相当于将实例的值拷贝传递给方法，这并不是一件划算的买卖。请看下面的例子，接收者完全可以是实例的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修仙者等级</span></span><br><span class="line"><span class="keyword">type</span> Level <span class="keyword">struct</span> &#123;</span><br><span class="line">level      <span class="keyword">string</span></span><br><span class="line">levelValue <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取等级描述</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv Level)</span> <span class="title">GetLevel</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> recv.level</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span></span>&#123;</span><br><span class="line">    level := model.Level&#123;<span class="string">&quot;练气九层&quot;</span>,<span class="number">9200</span>&#125;</span><br><span class="line">fmt.Println(level.GetLevel())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">练气九层</span><br></pre></td></tr></table></figure><p>注意：</p><p><strong>指针方法和值方法都可以在指针或非指针上被调用</strong>。如下面程序所示，类型 <code>Level</code> 在值上有一个方法 <code>GetLevel()</code>，在指针上有一个方法 <code>SetLevel()</code>，但是可以看到两个方法都可以在两种类型的变量上被调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修仙者等级</span></span><br><span class="line"><span class="keyword">type</span> Level <span class="keyword">struct</span> &#123;</span><br><span class="line">level      <span class="keyword">string</span></span><br><span class="line">levelValue <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLevel</span><span class="params">(level <span class="keyword">string</span>, levelValue <span class="keyword">int</span>)</span> <span class="title">Level</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Level&#123;</span><br><span class="line">level:      level,</span><br><span class="line">levelValue: levelValue,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取等级描述</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv Level)</span> <span class="title">Level</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> recv.level</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv *Level)</span> <span class="title">SetLevel</span><span class="params">(level <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">recv.level = level</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;go_code/method/model&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">level := model.NewLevel(<span class="string">&quot;练气九层&quot;</span>,<span class="number">9200</span>)</span><br><span class="line">levelPointer := &amp; level</span><br><span class="line">fmt.Println(<span class="string">&quot;晋级之前：&quot;</span>,level.Level())</span><br><span class="line">levelPointer.SetLevel(<span class="string">&quot;炼气大圆满&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;晋级之后：&quot;</span>,level.Level())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">晋级之前： 练气九层</span><br><span class="line">晋级之后： 炼气大圆满</span><br></pre></td></tr></table></figure><h2 id="方法和未导出字段"><a href="#方法和未导出字段" class="headerlink" title="方法和未导出字段"></a>方法和未导出字段</h2><p>在上面的例子当中，<code>level</code>类型的字段对包外部而言是不可见的（可以理解为面向对象语言当中的<code>private</code>属性）。因此如果在<code>main</code>包当中直接通过选择器进行访问的话，将会报错。这是，我们可以通过面向对象语言一个众所周知的技术来完成：提供 getter 和 setter 方法。在Golang当中，对于 setter 方法使用 Set 前缀，对于 getter 方法只使用成员名。</p><h3 id="关于并发访问对象"><a href="#关于并发访问对象" class="headerlink" title="关于并发访问对象"></a>关于并发访问对象</h3><p>对象的字段（属性）不应该由 2 个或 2 个以上的不同线程在同一时间去改变。如果在程序发生这种情况，为了安全并发访问，可以使用包 <code>sync</code>中的方法(比如加个互斥锁)。但是这并不是一个推荐的选项（之后我们将会学习通过 goroutines 和 channels 去探索一种新的方式）。请看下面的例子</p><p><code>src/go_code/method/model/level_lock.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修仙者等级</span></span><br><span class="line"><span class="keyword">type</span> levelLock <span class="keyword">struct</span> &#123;</span><br><span class="line">Lock sync.Mutex</span><br><span class="line">level      <span class="keyword">string</span></span><br><span class="line">levelValue <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLevelLock</span><span class="params">(level <span class="keyword">string</span>, levelValue <span class="keyword">int</span>)</span> *<span class="title">levelLock</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;levelLock&#123;</span><br><span class="line">level:      level,</span><br><span class="line">levelValue: levelValue,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv *levelLock)</span> <span class="title">SetLevel</span><span class="params">(level <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">recv.level  = level</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>src/go_code/struct/main/level_lock.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;go_code/method/model&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">level := model.NewLevelLock(<span class="string">&quot;练气九层&quot;</span>,<span class="number">9200</span>)</span><br><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">level.Lock.Lock()</span><br><span class="line"><span class="comment">//修改值</span></span><br><span class="line">level.SetLevel(<span class="string">&quot;练气圆满&quot;</span>)</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">defer</span> level.Lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="内嵌类型的方法和继承"><a href="#内嵌类型的方法和继承" class="headerlink" title="内嵌类型的方法和继承"></a>内嵌类型的方法和继承</h2><p>当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌，这在效果上等同于外层类型 <strong>继承</strong> 了这些方法：<strong>将父类型放在子类型中来实现亚型</strong>。这个机制提供了一种简单的方式来模拟经典面向对象语言中的子类和继承相关的效果。因为一个结构体可以嵌入多个匿名类型，所以实际上我们可以有一个简单版本的<code>多重继承</code>。</p><p>在model包当中定义一个<code>immortal2</code> 类型，并让其内嵌一个匿名类型<code>level</code> </p><p><code>src/go_code/method/model/anonymous_type.go</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修仙者</span></span><br><span class="line"><span class="keyword">type</span> immortal2 <span class="keyword">struct</span> &#123;</span><br><span class="line">name   <span class="keyword">string</span></span><br><span class="line">age    <span class="keyword">int</span></span><br><span class="line">gender <span class="keyword">string</span></span><br><span class="line">Level</span><br><span class="line">lingGen</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewImmortal2</span><span class="params">(age <span class="keyword">int</span>, name, gender <span class="keyword">string</span>,levelName <span class="keyword">string</span>,levelValue <span class="keyword">int</span>,lingGenNames...<span class="keyword">string</span>)</span> *<span class="title">immortal2</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;immortal2&#123;</span><br><span class="line">name:   name,</span><br><span class="line">age:    age,</span><br><span class="line">gender: gender,</span><br><span class="line">Level:  Level&#123;levelName,levelValue&#125;,</span><br><span class="line">lingGen: lingGen&#123;linGenNames: lingGenNames&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>src/go_code/method/model/level.go</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修仙者等级</span></span><br><span class="line"><span class="keyword">type</span> Level <span class="keyword">struct</span> &#123;</span><br><span class="line">level      <span class="keyword">string</span></span><br><span class="line">levelValue <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLevel</span><span class="params">(level <span class="keyword">string</span>, levelValue <span class="keyword">int</span>)</span> <span class="title">Level</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Level&#123;</span><br><span class="line">level:      level,</span><br><span class="line">levelValue: levelValue,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取等级描述</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv Level)</span> <span class="title">Level</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> recv.level</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv *Level)</span> <span class="title">SetLevel</span><span class="params">(level <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">recv.level = level</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv *Level)</span> <span class="title">LevelName</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> recv.level</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>src/go_code/method/model/lingen.go</code>: </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修士的灵根</span></span><br><span class="line"><span class="keyword">type</span> lingGen <span class="keyword">struct</span> &#123;</span><br><span class="line">linGenNames[] <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLinggen</span><span class="params">(name ...<span class="keyword">string</span>)</span> *<span class="title">lingGen</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;lingGen&#123;linGenNames: name&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv *lingGen)</span> <span class="title">LingGenNames</span><span class="params">()</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> recv.linGenNames</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在main包当中导入并使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;go_code/method/model&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">im := model.NewImmortal2(<span class="number">18</span>,<span class="string">&quot;韩立&quot;</span>,<span class="string">&quot;男&quot;</span>,</span><br><span class="line"><span class="string">&quot;练气九层&quot;</span>,<span class="number">9200</span>,<span class="string">&quot;木灵根&quot;</span>,<span class="string">&quot;水灵根&quot;</span>,<span class="string">&quot;火灵根&quot;</span>,<span class="string">&quot;土灵根&quot;</span>)</span><br><span class="line">im.SetLevel(<span class="string">&quot;练气大圆满&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;境界：&quot;</span>,im.LevelName())</span><br><span class="line">fmt.Println(<span class="string">&quot;灵根：&quot;</span>,im.LingGenNames())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">境界： 练气大圆满</span><br><span class="line">灵根： [木灵根 水灵根 火灵根 土灵根]</span><br></pre></td></tr></table></figure><h2 id="Go-的类型和方法和其他面向对象语言对比"><a href="#Go-的类型和方法和其他面向对象语言对比" class="headerlink" title="Go 的类型和方法和其他面向对象语言对比"></a>Go 的类型和方法和其他面向对象语言对比</h2><p>在如 C++、Java、C# 和 Python这样的面向对象语言中，方法在类的上下文中被定义和继承：在一个对象上调用方法时，运行时会检测类以及它的超类中是否有此方法的定义，如果没有会导致异常发生。</p><p>在 Golang 中，这样的继承层次是完全没必要的：如果方法在此类型定义了，就可以调用它，和其他类型上是否存在这个方法没有关系。在这个意义上，Golang具有更大的灵活性。</p><p>Golang不需要一个显式的类定义，如同 Java和C++等那样，相反地，“类”是通过提供一组作用于一个共同类型的方法集加类型本身来隐式定义的。类型可以是结构体或者任何用户自定义类型。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在Golang中，类=类型+与之关联的方法集。</p><p>在 Golang 中，代码复用通过组合和委托实现，多态通过接口的使用来实现：有时这也叫 <strong>组件编程（Component Programming）</strong>。</p><p>相比于类继承，Go 的接口提供了更强大、却更简单的多态行为。</p><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>关于Golang中方法的学习就写到这了。本文当中涉及到的例子可以<a href="https://github.com/code81192/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言入门学习之结构体（struct）</title>
      <link href="/2021/09/07/golang/07_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2021/09/07/golang/07_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/girl-2366438_1920.jpg" alt="girl-2366438_1920"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在上一文<a href="https://bingfenglai.github.io/2021/09/05/golang/06_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E5%87%BD%E6%95%B0/">《Golang入门学习之函数》</a>当中，我们学习了Golang当中函数的用法。接下来，我们将一起来学习Golang的结构体。</p><h2 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h2><p><code>结构体</code>（struct）类似于其他面向对象当中类（class）的概念，但它和类有着明显的不同。结构体是<code>复合类型</code>（composite types），它由一系列属性组成，这些属性对应着不同的值与类型。组成结构体类型的那些数据称为<code>字段</code>(fields).</p><p>Golang通过结构体的形式支持用户自定义类型，或者叫定制类型。</p><p>定义方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StructName <span class="keyword">struct</span> &#123;</span><br><span class="line">field1 type1</span><br><span class="line">field2 type2</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体的实例化"><a href="#结构体的实例化" class="headerlink" title="结构体的实例化"></a>结构体的实例化</h2><span id="more"></span><h3 id="使用new"><a href="#使用new" class="headerlink" title="使用new()"></a>使用new()</h3><p>我们可以使用 <strong>new</strong> 函数给一个新的结构体变量分配内存，它返回指向已分配内存的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t *StructName</span><br><span class="line">t = <span class="built_in">new</span>(StructName)</span><br></pre></td></tr></table></figure><p>请看下面这个例子：</p><p>首先，我们在<code>go_code/struct/model</code>这个包当中，定义了一个结构体<code>Immortal</code>表示修仙者，并在<code>main</code>当中引入这个包，并使用<code>Immortal</code></p><p><code>go_code/struct/model/immortal.go</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修仙者</span></span><br><span class="line"><span class="keyword">type</span> Immortal <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;go_code/struct/model&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// i是指向model.Immortal结构体变量的指针</span></span><br><span class="line"><span class="keyword">var</span> i *model.Immortal</span><br><span class="line">i= <span class="built_in">new</span>(model.Immortal)</span><br><span class="line">i.Age = <span class="number">500</span></span><br><span class="line">i.Name = <span class="string">&quot;韩立&quot;</span></span><br><span class="line">i.Gender = <span class="string">&quot;男&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(i.Name, strconv.Itoa(i.Age)+<span class="string">&quot;岁&quot;</span>,i.Gender)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">韩立 500岁 男</span><br></pre></td></tr></table></figure><p>我们可以通过点符号获取结构体的值或给其赋值，点符号在Golang中称之为选择器符(selector-notation)。</p><h3 id="使用混合字面量语法"><a href="#使用混合字面量语法" class="headerlink" title="使用混合字面量语法"></a>使用混合字面量语法</h3><p>初始化一个结构体实例的更简短和惯用的方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i的类型是 *model.Immortal</span></span><br><span class="line"><span class="keyword">var</span> i =  &amp;model.Immortal&#123;<span class="string">&quot;南宫婉&quot;</span>,<span class="number">18</span>,<span class="string">&quot;女&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> i model.Immortal</span><br><span class="line">i := model.Immortal&#123;<span class="string">&quot;南宫婉&quot;</span>,<span class="number">18</span>,<span class="string">&quot;女&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>上面这两个例子当中的写法(<code>&amp;model.Immortal&#123;&quot;南宫婉&quot;,18,&quot;女&quot;&#125;</code> )称之为<code>混合字面量语法</code> （composite literal sysntax），这是一种简写，底层仍然会调用new函数。在这种写法当中，需要注意的一点是<strong>值的顺序必须按照字段顺序来写</strong>。表达式<code>new(Type)</code>和<code>&amp;Type()</code>是等价的。</p><h2 id="Golang中结构体的特点"><a href="#Golang中结构体的特点" class="headerlink" title="Golang中结构体的特点"></a>Golang中结构体的特点</h2><h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><p>Go 语言中，结构体和它所包含的数据在内存中是以连续块的形式存在的，即使结构体中嵌套有其他的结构体，这在性能上带来了很大的优势。</p><h3 id="递归结构体"><a href="#递归结构体" class="headerlink" title="递归结构体"></a>递归结构体</h3><p>结构体类型可以通过引用自身来定义。这在定义链表或二叉树的元素（通常叫节点）时特别有用，此时节点包含指向临近节点的链接（地址）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">data <span class="keyword">string</span></span><br><span class="line">next *Node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，data字段当中存储的是当前节点的数据，next是指向下一个节点的指针</p><h3 id="结构体的转换"><a href="#结构体的转换" class="headerlink" title="结构体的转换"></a>结构体的转换</h3><p>Go 中的类型转换遵循严格的规则。当为结构体定义了一个 <code>alias</code> 类型时，此结构体类型和它的 alias 类型都有相同的底层类型。</p><p>请看下面的这个例子：</p><p><code>number.go</code> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Number <span class="keyword">struct</span> &#123;</span><br><span class="line">Value <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>conversion.go</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;go_code/struct/model&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = myNumber&#123;Value: <span class="number">18.0</span>&#125;</span><br><span class="line">b := model.Number(a)</span><br><span class="line"><span class="built_in">println</span>(b.Value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myNumber model.Number</span><br></pre></td></tr></table></figure><h2 id="使用工厂方法创建结构体实例"><a href="#使用工厂方法创建结构体实例" class="headerlink" title="使用工厂方法创建结构体实例"></a>使用工厂方法创建结构体实例</h2><p>Golang不支持其他面向对象编程语言（例如Java）那样的构造方法。我们通常通过定义一个构造工厂方法用于创建结构体实例。</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修仙者</span></span><br><span class="line"><span class="keyword">type</span> Immortal <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewImmortal</span><span class="params">(age <span class="keyword">int</span>, name, gender <span class="keyword">string</span>)</span> *<span class="title">Immortal</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> age&lt;<span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;Immortal&#123;Name: name,Gender: name,Age: age&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于工厂方法的命名，我们一般以<code>New</code>或<code>new</code>开头，它返回一个指向结构体实例的指针</p><h3 id="如何强制使用工厂方法而不是直接new？"><a href="#如何强制使用工厂方法而不是直接new？" class="headerlink" title="如何强制使用工厂方法而不是直接new？"></a>如何强制使用工厂方法而不是直接new？</h3><p>在讲这个问题之前，需要给大家补充一个知识点，那就是Golang当中包的可见性规则：</p><p>在Golang中，当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）。</p><p>因此，为了达到我们的目的，我们需要这样去定义我们的结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> v2</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> immortal <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">gender <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewImmortal</span><span class="params">(age <span class="keyword">int</span>, name, gender <span class="keyword">string</span>)</span> *<span class="title">immortal</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;immortal&#123;</span><br><span class="line">name:   name,</span><br><span class="line">age:    age,</span><br><span class="line">gender: gender,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带标签的结构体"><a href="#带标签的结构体" class="headerlink" title="带标签的结构体"></a>带标签的结构体</h2><p>结构体中的字段除了有名字和类型外，还可以有一个可选的标签（tag）：它是一个附属于字段的字符串，可以是文档或其他的重要标记。标签的内容不可以在一般的编程中使用，只有包 <code>reflect</code> 能获取它。在gorm（一个Golng的orm框架，类似于Java当中的<code>mybatis</code>）当中使用tag标记字段，从而起到映射数据库表字段的作用。</p><p>请看下面这个例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tag</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Immortal <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span> <span class="string">&quot;休仙者的名字&quot;</span></span><br><span class="line">Age <span class="keyword">int</span> <span class="string">&quot;修仙者的年龄&quot;</span></span><br><span class="line">Gender <span class="keyword">string</span> <span class="string">&quot;修仙者的性别&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintTag</span><span class="params">(im Immortal, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">imm :=reflect.TypeOf(im)</span><br><span class="line">value :=imm.Field(i)</span><br><span class="line">fmt.Println(value.Tag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;go_code/struct/model/tag&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> immortal = tag.Immortal&#123;Name: <span class="string">&quot;南宫婉&quot;</span>, Age: <span class="number">18</span>, Gender: <span class="string">&quot;女&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++ &#123;</span><br><span class="line">tag.PrintTag(immortal,i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">休仙者的名字</span><br><span class="line">修仙者的年龄</span><br><span class="line">修仙者的性别</span><br></pre></td></tr></table></figure><h2 id="匿名字段和内嵌结构体"><a href="#匿名字段和内嵌结构体" class="headerlink" title="匿名字段和内嵌结构体"></a>匿名字段和内嵌结构体</h2><p>结构体可以包含一个或多个 <strong>匿名（或内嵌）字段</strong>，即这些字段没有显式的名字，只有字段的类型是必须的，此时类型就是字段的名字。匿名字段本身可以是一个结构体类型，即 <strong>结构体可以包含内嵌结构体</strong>。在Golang当中，通过组合来实现其他面向对象编程语言当中的继承。</p><p>请看下面的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> immortal <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 姓名</span></span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"><span class="comment">// 年龄</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line"><span class="comment">// 修仙境界</span></span><br><span class="line">level</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> level <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 境界名称</span></span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"><span class="comment">// 灵气值</span></span><br><span class="line"><span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> im = immortal&#123;</span><br><span class="line"><span class="keyword">string</span>: <span class="string">&quot;韩立&quot;</span>,</span><br><span class="line"><span class="keyword">int</span>:    <span class="number">500</span>,</span><br><span class="line">level:  level&#123;</span><br><span class="line"><span class="string">&quot;练气七层&quot;</span>,</span><br><span class="line"><span class="number">7800.0</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;======修仙者资料卡======&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;姓名：&quot;</span>,im.<span class="keyword">string</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;年龄：&quot;</span>,im.<span class="keyword">int</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;------境界信息---------&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;境界名称：&quot;</span>,im.level.<span class="keyword">string</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;境界灵气值：&quot;</span>,im.level.<span class="keyword">float32</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;------境界信息---------&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;======修仙者资料卡======&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">======修仙者资料卡======</span><br><span class="line">姓名： 韩立</span><br><span class="line">年龄： <span class="number">500</span></span><br><span class="line">------境界信息---------</span><br><span class="line">境界名称： 练气七层</span><br><span class="line">境界灵气值： <span class="number">7800</span></span><br><span class="line">------境界信息---------</span><br><span class="line">======修仙者资料卡======</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>关于Golang结构体的学习就写到这里，本文当中涉及到的例子可以<a href="https://github.com/code81192/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang入门学习之函数</title>
      <link href="/2021/09/05/golang/06_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E5%87%BD%E6%95%B0/"/>
      <url>/2021/09/05/golang/06_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/woman-6572974_1920.jpg" alt="woman-6572974_1920"></p><h2 id="Golang-中函数的定义"><a href="#Golang-中函数的定义" class="headerlink" title="Golang 中函数的定义"></a>Golang 中函数的定义</h2><p>在编程语言中，函数是一段可复用的代码段，它由函数名、参数和返回值三部分构成。在golang当中，函数分为自定义函数和系统函数两大类。自定义函数就是你自己写的函数，系统函数就是系统原有的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(形参列表)</span><span class="params">(返回值列表)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">    <span class="keyword">return</span> 返回值列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>说明：</code></p><span id="more"></span><p>a. 函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也称不能重名;</p><p>b. 形参列表：形参列表也就是参数，参数由参数变量和参数类型组成，多个参数之间使用<code>,</code>隔开;</p><p>c. 返回值：返回值由返回值类型及其变量组成，也可以只写返回值类型，存在多个返回值时必须使用<code>()</code>括起来，并在其中用<code>,</code>分隔</p><p>d. 函数体： 实现特定功能、业务逻辑的代码块。</p><p>顺嘴说一句，<code>函数</code>是面向过程的概念，在面向对象语言中，称之为<code>方法</code></p><h2 id="Golang中函数的调用"><a href="#Golang中函数的调用" class="headerlink" title="Golang中函数的调用"></a>Golang中函数的调用</h2><p>对于同一个包中的函数，我们可以使用<code>函数名(参数)</code>的形式调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sayHello(<span class="string">&quot;厉飞羽&quot;</span>)</span><br><span class="line">s := getPhoneByName(<span class="string">&quot;南宫婉&quot;</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;你好！&quot;</span>,name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getPhoneByName</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> name+<span class="string">&quot; 的手机号是 &quot;</span> + <span class="string">&quot;120-6379-3306&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你好！ 厉飞羽</span><br><span class="line">南宫婉 的手机号是 <span class="number">120</span><span class="number">-6379</span><span class="number">-3306</span></span><br></pre></td></tr></table></figure><p>在不同包中，我们可以通过<code>包名.方法名()</code>来调用函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> myMath</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(number ...<span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> number &#123;</span><br><span class="line">sum = sum + num</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;go_code/function/myMath&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sum := myMath.Add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="参数进阶用法"><a href="#参数进阶用法" class="headerlink" title="参数进阶用法"></a>参数进阶用法</h2><h3 id="类型简写"><a href="#类型简写" class="headerlink" title="类型简写"></a>类型简写</h3><p>Golang中，对于相邻的参数，如果其类型相同，可以简写</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello2</span><span class="params">(name1 ,name2 <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;你们好！&quot;</span>,name1,name2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sayHello2(<span class="string">&quot;厉飞羽&quot;</span>,<span class="string">&quot;韩立&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你们好！ 厉飞羽 韩立</span><br></pre></td></tr></table></figure><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数是指函数的参数数量不固定。Golang中的可变参数通过在参数名后加<code>...</code>来标识。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello3</span><span class="params">(name ...<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, s := <span class="keyword">range</span> name &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;你好！&quot;</span>,s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sayHello3(<span class="string">&quot;厉飞羽&quot;</span>,<span class="string">&quot;韩立&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你好！ 厉飞羽</span><br><span class="line">你好！ 韩立</span><br></pre></td></tr></table></figure><h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>在golang中，函数的返回值可以有多个。通过<code>return</code> 关键字返回数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getPhoneByName</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> name+<span class="string">&quot; 的手机号是 &quot;</span> + <span class="string">&quot;120-6379-3306&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getPhoneByName2</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(str <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">str = name+<span class="string">&quot; 的手机号是 &quot;</span> + <span class="string">&quot;120-6379-3306&quot;</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">s1 := getPhoneByName(<span class="string">&quot;南宫婉&quot;</span>)</span><br><span class="line">fmt.Println(s1)</span><br><span class="line">s2 := getPhoneByName2(<span class="string">&quot;南宫婉&quot;</span>)</span><br><span class="line">fmt.Println(s2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">南宫婉 的手机号是 120-6379-3306</span><br><span class="line">南宫婉 的手机号是 120-6379-3306</span><br></pre></td></tr></table></figure><p>说明：</p><p>在Golang当中。对于返回值，函数定义时可以给返回值命名，并可以直接<code>return</code> </p><h2 id="将函数作为参数"><a href="#将函数作为参数" class="headerlink" title="将函数作为参数"></a>将函数作为参数</h2><p>在Golang当中，函数可以作为参数去传递，然后在其他函数内调用执行，这一般称之为回调。请看下面的这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">name := <span class="string">&quot;喜小乐&quot;</span></span><br><span class="line">sayHello(name,callback)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callback</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello &quot;</span>,name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(name <span class="keyword">string</span>,f <span class="keyword">func</span>(name <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;我是&quot;</span>,name)</span><br><span class="line">f(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我是 喜小乐</span><br><span class="line">hello  喜小乐</span><br></pre></td></tr></table></figure><h2 id="defer关键词"><a href="#defer关键词" class="headerlink" title="defer关键词"></a>defer关键词</h2><p><code>defer</code> 关键词允许我们推迟到函数返回之前（或任意位置执行<code>return</code> 语句之后）一刻才执行某个语句或函数。</p><p>请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sayHello(<span class="string">&quot;南宫婉&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;before&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fun1()</span><br><span class="line">fmt.Println(<span class="string">&quot;after&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before</span><br><span class="line">after</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p><code>defer</code> 关键词的用法类似于Java语言当中的<code>finally</code> 关键词，它经常用来释放某些已分配的资源。例如释放锁操作、关闭数据库连接等等。</p><h2 id="匿名函数与闭包"><a href="#匿名函数与闭包" class="headerlink" title="匿名函数与闭包"></a>匿名函数与闭包</h2><p>当我们不想给函数命名的时候，我们可以使用匿名函数（可以理解为没有名字的函数），也称之为闭包。在Golang当中，匿名函数是不能单独存在的，你必须将其赋值给某一变量（将函数的地址保存在变量当中），然后通过变量名对函数进行调用。请看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fun := <span class="function"><span class="keyword">func</span> <span class="params">(name <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello&quot;</span>,name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun(<span class="string">&quot;向北&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello 向北</span><br></pre></td></tr></table></figure><h2 id="闭包的应用：将函数作为返回值"><a href="#闭包的应用：将函数作为返回值" class="headerlink" title="闭包的应用：将函数作为返回值"></a>闭包的应用：将函数作为返回值</h2><p>在前面我们讲到，函数可以作为它可以参数进行传递，同样，函数还可以作为返回值。请看下面的例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">getPhone := sayHello(<span class="string">&quot;厉飞羽&quot;</span>)</span><br><span class="line"></span><br><span class="line">getPhone()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;你好！&quot;</span>,name)</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;我的手机号是： 131****3901&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你好！ 厉飞羽</span><br><span class="line">我的手机号是： 131****3901</span><br></pre></td></tr></table></figure><p>在Golang中，一个返回值为另一个函数的函数可以被称之为<em>工厂函数</em> ，例如上方例子当中的<code>sayHello</code> . 可以返回其它函数的函数和接受其它函数作为参数的函数均被称之为<code>高阶函数</code>，是函数式语言的特点。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>关于Golang的函数部分学习就暂时写到这，本文的例子可以<a href="https://github.com/code81192/golang">点击此处下载</a>。如果我的学习笔记能够给你带来帮助，还请多多点赞鼓励。文章如有错漏之处还请各位小伙伴帮忙斧正。</p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言入门之map</title>
      <link href="/2021/08/23/golang/05_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_map/"/>
      <url>/2021/08/23/golang/05_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_map/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>之前说好的每周更新一次技术博客，但是由于种种原因一直推迟到现在… …🐶</p><p>有一句话，我一直把它当作我的座右铭，写在这里与诸君共勉：业精于勤荒于嬉，行成于思毁于随。</p><p>废话不多说，开始我们今天的学习。</p><h2 id="什么是map"><a href="#什么是map" class="headerlink" title="什么是map"></a>什么是map</h2><p>map是一种无序的、基于键值对&lt;key,value&gt;的数据结构，又称之为字段或关联数组。</p><p>在Go语言当中，map是引用类型，必须初始化后才能使用，其内部也是使用散列表来实现的。</p><h2 id="map的定义与使用"><a href="#map的定义与使用" class="headerlink" title="map的定义与使用"></a>map的定义与使用</h2><h3 id="第一种方式：通过map关键字定义"><a href="#第一种方式：通过map关键字定义" class="headerlink" title="第一种方式：通过map关键字定义"></a>第一种方式：通过map关键字定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var mapname map[keytype]valuetype</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">map</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br></pre></td></tr></table></figure><p>其中：</p><span id="more"></span><ol><li><code>mapName</code> 为变量名</li><li><code>keyType</code> 为key的数据类型。key的数据类型可以是bool、数字、string、指针、channel、接口、结构体和数组</li><li><code>valueType</code>为值的数据类型。value包含的数据类型与key一样，通常为string、结构体和map</li></ol><p><strong>注意：</strong> </p><pre><code>1. 声明不会分配内存，需要使用make来初始化后才能使用。2. 对于上述的key是不可以重复的，value则是可以重复的。</code></pre><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过map关键字生命map</span></span><br><span class="line"><span class="keyword">var</span> peopleMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">peopleMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">peopleMap[<span class="string">&quot;01&quot;</span>] = <span class="string">&quot;喜小乐&quot;</span></span><br><span class="line">peopleMap[<span class="string">&quot;02&quot;</span>] = <span class="string">&quot;东小贝&quot;</span></span><br><span class="line">peopleMap[<span class="string">&quot;03&quot;</span>] = <span class="string">&quot;北小楠&quot;</span></span><br><span class="line">peopleMap[<span class="string">&quot;04&quot;</span>] = <span class="string">&quot;楠小茽&quot;</span></span><br><span class="line"></span><br><span class="line">fmt.Println(peopleMap)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map[01:喜小乐 02:东小贝 03:北小楠 04:楠小茽]</span><br></pre></td></tr></table></figure><h3 id="第二种方式：通过make定义并初始化"><a href="#第二种方式：通过make定义并初始化" class="headerlink" title="第二种方式：通过make定义并初始化"></a>第二种方式：通过make定义并初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过make声明并初始化</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">4</span>)</span><br><span class="line">m[<span class="string">&quot;no1&quot;</span>] = <span class="string">&quot;向北&quot;</span></span><br><span class="line">m[<span class="string">&quot;no2&quot;</span>] = <span class="string">&quot;向南&quot;</span></span><br><span class="line">m[<span class="string">&quot;no3&quot;</span>] = <span class="string">&quot;向东&quot;</span></span><br><span class="line">m[<span class="string">&quot;no4&quot;</span>] = <span class="string">&quot;向西&quot;</span></span><br><span class="line"></span><br><span class="line">fmt.Print(m)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map[no1:向北 no2:向南 no3:向东 no4:向西]</span><br></pre></td></tr></table></figure><h4 id="关于make函数的说明"><a href="#关于make函数的说明" class="headerlink" title="关于make函数的说明"></a>关于make函数的说明</h4><p>make（type,size）是一个内置函数，它用于分配并初始化一个类型为切片、映射和通道的对象，其中第一个参数为类型，第二个参数size是分配给type的初始大小，其返回值与实参type的类型一致，而非指针。</p><h3 id="第三种方式-声明时直接赋值"><a href="#第三种方式-声明时直接赋值" class="headerlink" title="第三种方式 声明时直接赋值"></a>第三种方式 声明时直接赋值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;小明&quot;</span>:<span class="string">&quot;小朋友&quot;</span>,</span><br><span class="line"><span class="string">&quot;小张&quot;</span>: <span class="string">&quot;是个大人&quot;</span>,</span><br><span class="line"><span class="string">&quot;小李&quot;</span>: <span class="string">&quot;是个司机&quot;</span>,</span><br><span class="line"><span class="string">&quot;小王&quot;</span>: <span class="string">&quot;家住隔壁&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map的CRUD"><a href="#map的CRUD" class="headerlink" title="map的CRUD"></a>map的CRUD</h2><h4 id="添加元素操作"><a href="#添加元素操作" class="headerlink" title="添加元素操作"></a>添加元素操作</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">map</span>[key] = value</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">m[<span class="string">&quot;小明&quot;</span>] = <span class="string">&quot;一听就是个小朋友&quot;</span></span><br><span class="line">m[<span class="string">&quot;小张&quot;</span>] = <span class="string">&quot;一听就是个大人&quot;</span></span><br><span class="line">m[<span class="string">&quot;小李&quot;</span>] = <span class="string">&quot;一听就是个司机&quot;</span></span><br><span class="line">m[<span class="string">&quot;小王&quot;</span>] = <span class="string">&quot;一听家就住在不远&quot;</span></span><br><span class="line"></span><br><span class="line">fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 如果key不存在，就是增加，如果key存在，则是修改操作</p><h3 id="修改元素操作"><a href="#修改元素操作" class="headerlink" title="修改元素操作"></a>修改元素操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m =  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> &#123;</span><br><span class="line"><span class="string">&quot;小王&quot;</span>:<span class="string">&quot;一听家就住在不远&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;修改前：&quot;</span>,m)</span><br><span class="line">m[<span class="string">&quot;小王&quot;</span>] = <span class="string">&quot;家住在隔壁&quot;</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;修改后&quot;</span>, m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修改前： <span class="keyword">map</span>[小王:一听家就住在不远]</span><br><span class="line">修改后 <span class="keyword">map</span>[小王:家住在隔壁]</span><br></pre></td></tr></table></figure><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>delete(m map[Type]Type1, key Type)是一个内建函数，它将删除map中指定key的元素。当key不存在时，则不进行删除。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">m[<span class="string">&quot;小明&quot;</span>] = <span class="string">&quot;一听就是个小朋友&quot;</span></span><br><span class="line">m[<span class="string">&quot;小张&quot;</span>] = <span class="string">&quot;一听就是个大人&quot;</span></span><br><span class="line">m[<span class="string">&quot;小李&quot;</span>] = <span class="string">&quot;一听就是个司机&quot;</span></span><br><span class="line">m[<span class="string">&quot;小王&quot;</span>] = <span class="string">&quot;一听家就住在不远&quot;</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;删除前： &quot;</span>,m)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// delete(m map[Type]Type1, key Type)是一个内建函数，它将删除map中指定key的元素。当key不存在时，则不进行删除</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;小王&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;删除后： &quot;</span>, m)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">删除前：  <span class="keyword">map</span>[小张:一听就是个大人 小明:一听就是个小朋友 小李:一听就是个司机 小王:一听家就住在不远]</span><br><span class="line">删除后：  <span class="keyword">map</span>[小张:一听就是个大人 小明:一听就是个小朋友 小李:一听就是个司机]</span><br></pre></td></tr></table></figure><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">m[<span class="string">&quot;小明&quot;</span>] = <span class="string">&quot;一听就是个小朋友&quot;</span></span><br><span class="line">m[<span class="string">&quot;小张&quot;</span>] = <span class="string">&quot;一听就是个大人&quot;</span></span><br><span class="line">m[<span class="string">&quot;小李&quot;</span>] = <span class="string">&quot;一听就是个司机&quot;</span></span><br><span class="line">m[<span class="string">&quot;小王&quot;</span>] = <span class="string">&quot;一听家就住在不远&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果map中存在key为“小王”的元素，则ok为true,value为对应的元素 </span></span><br><span class="line">value,ok := m[<span class="string">&quot;小王&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一听家就住在不远</span><br></pre></td></tr></table></figure><h2 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h2><h4 id="使用for-range遍历map的key和value"><a href="#使用for-range遍历map的key和value" class="headerlink" title="使用for range遍历map的key和value"></a>使用<code>for range</code>遍历<code>map</code>的<code>key</code>和<code>value</code></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">m[<span class="string">&quot;小明&quot;</span>] = <span class="string">&quot;一听就是个小朋友&quot;</span></span><br><span class="line">m[<span class="string">&quot;小张&quot;</span>] = <span class="string">&quot;一听就是个大人&quot;</span></span><br><span class="line">m[<span class="string">&quot;小李&quot;</span>] = <span class="string">&quot;一听就是个司机&quot;</span></span><br><span class="line">m[<span class="string">&quot;小王&quot;</span>] = <span class="string">&quot;一听家就住在不远&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">fmt.Println(key,value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">小张 一听就是个大人</span><br><span class="line">小李 一听就是个司机</span><br><span class="line">小王 一听家就住在不远</span><br><span class="line">小明 一听就是个小朋友</span><br></pre></td></tr></table></figure><h4 id="使用for-range遍历map的key"><a href="#使用for-range遍历map的key" class="headerlink" title="使用for range遍历map的key"></a>使用<code>for range</code>遍历<code>map</code>的<code>key</code></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traverse2</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">m[<span class="string">&quot;小明&quot;</span>] = <span class="string">&quot;一听就是个小朋友&quot;</span></span><br><span class="line">m[<span class="string">&quot;小张&quot;</span>] = <span class="string">&quot;一听就是个大人&quot;</span></span><br><span class="line">m[<span class="string">&quot;小李&quot;</span>] = <span class="string">&quot;一听就是个司机&quot;</span></span><br><span class="line">m[<span class="string">&quot;小王&quot;</span>] = <span class="string">&quot;一听家就住在不远&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s := <span class="keyword">range</span> m &#123;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">小王</span><br><span class="line">小明</span><br><span class="line">小张</span><br><span class="line">小李</span><br></pre></td></tr></table></figure><h4 id="按照一定的顺序遍历map"><a href="#按照一定的顺序遍历map" class="headerlink" title="按照一定的顺序遍历map"></a>按照一定的顺序遍历map</h4><p>在前文当中我们说到，map它是无序的，那么，我们应当如何对它进行有序的遍历呢？</p><p>实现思路是这个样子的，我们首先使用<code>for range</code> 遍历map当中的key，并将其存入到一个切片（slice）<code>keyArray</code>当中，然后对数组进行排序，最后再遍历数组<code>keyArray</code> ，并将map当中key对应的值取出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">orderlyTraversal</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">m[<span class="string">&quot;小明&quot;</span>] = <span class="string">&quot;一听就是个小朋友&quot;</span></span><br><span class="line">m[<span class="string">&quot;小张&quot;</span>] = <span class="string">&quot;一听就是个大人&quot;</span></span><br><span class="line">m[<span class="string">&quot;小李&quot;</span>] = <span class="string">&quot;一听就是个司机&quot;</span></span><br><span class="line">m[<span class="string">&quot;小王&quot;</span>] = <span class="string">&quot;一听家就住在不远&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> keyArray []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> m&#123;</span><br><span class="line">keyArray = <span class="built_in">append</span>(keyArray, key)</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(keyArray)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(keyArray); i++ &#123;</span><br><span class="line">fmt.Println(keyArray[i],m[keyArray[i]])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    orderlyTraversal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">小张 一听就是个大人</span><br><span class="line">小明 一听就是个小朋友</span><br><span class="line">小李 一听就是个司机</span><br><span class="line">小王 一听家就住在不远</span><br></pre></td></tr></table></figure><h2 id="slice-of-map"><a href="#slice-of-map" class="headerlink" title="slice  of  map"></a>slice  of  map</h2><p>当切片（slice）的数据类型为map时，我们称之为“slice of map”, map的切片，它是可以动态变化的。</p><p>便于大家理解这个数据结构，我这里举个案例。需求是这个样子的，我们需要一个数据结构用于存储学生（student）的信息，包括name、gender等属性，要求这个数据结构可以动态地变更学生的数量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> students []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">student1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;向北&quot;</span>,</span><br><span class="line"><span class="string">&quot;gender&quot;</span>: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">students = <span class="built_in">append</span>(students, student1)</span><br><span class="line">    </span><br><span class="line">student2 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;向东&quot;</span>,</span><br><span class="line"><span class="string">&quot;gender&quot;</span>: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">students = <span class="built_in">append</span>(students, student2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, student := <span class="keyword">range</span> students &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;name: &quot;</span>,student[<span class="string">&quot;name&quot;</span>],<span class="string">&quot;gender: &quot;</span>,student[<span class="string">&quot;gender&quot;</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name:  向北 gender:  male</span><br><span class="line">name:  向东 gender:  male</span><br></pre></td></tr></table></figure><p>可以看到，当需要动态地添加元素时，只要使用内置函数append就可以了。</p><h2 id="map的使用细节"><a href="#map的使用细节" class="headerlink" title="map的使用细节"></a>map的使用细节</h2><ol><li>map是引用数据类型，遵守引用数据类型的传递机制，在一个函数中接收map,修改后，会直接修改原先的map</li><li>map使用容量达到上前上限值后，会自动扩容，并不会发生panic</li><li>map的<code>value</code>经常是<code>struct</code>结构体类型，更适合于管理复杂的数据</li></ol><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>本文当中使用到的demo链接吧👉：<a href="https://github.com/code81192/golang">code81192/golang: Go语言学习笔记&amp;Demo (github.com)</a></p><p>如果你觉得这篇文章对你有所帮助，请点个赞鼓励一下，如有错漏的地方欢迎指正🤝</p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言入门之流程控制----练气三层</title>
      <link href="/2021/08/15/golang/03_go%E8%AF%AD%E8%A8%80%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2021/08/15/golang/03_go%E8%AF%AD%E8%A8%80%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-流程控制之if-else"><a href="#1-流程控制之if-else" class="headerlink" title="1 流程控制之if else"></a>1 流程控制之if else</h2><h3 id="一般写法"><a href="#一般写法" class="headerlink" title="一般写法"></a>一般写法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if 表达式1 &#123;</span><br><span class="line">    分支1</span><br><span class="line">&#125; else if 表达式2 &#123;</span><br><span class="line">    分支2</span><br><span class="line">&#125; else&#123;</span><br><span class="line">    分支3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 分支结构</span></span><br><span class="line"><span class="comment">  @author 赖柄沣 bingfengdev@aliyun.com</span></span><br><span class="line"><span class="comment">  @date 2020-09-29 00:00:39</span></span><br><span class="line"><span class="comment">  @version 1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a, b, c := <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">   <span class="keyword">if</span> a &gt;b &#123;</span><br><span class="line">      fmt.Println(a)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(c)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if-else的特殊写法"><a href="#if-else的特殊写法" class="headerlink" title="if else的特殊写法"></a>if else的特殊写法</h3><span id="more"></span><p>if条件判断还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断</p><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** if else的特殊写法</span></span><br><span class="line"><span class="comment">  @author 赖柄沣 bingfengdev@aliyun.com</span></span><br><span class="line"><span class="comment">  @date 2020-09-29 00:00:39</span></span><br><span class="line"><span class="comment">  @version 1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> a := <span class="number">3</span>; a &gt; <span class="number">0</span> &#123;</span><br><span class="line">      fmt.Println(a)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>： Go语言规定与<code>if</code>匹配的左括号<code>&#123;</code>必须与<code>if和表达式</code>放在同一行，<code>&#123;</code>放在其他位置会触发编译错误。 同理，与<code>else</code>匹配的<code>&#123;</code>也必须与<code>else</code>写在同一行，<code>else</code>也必须与上一个<code>if</code>或<code>else if</code>右边的大括号在同一行。</p><h2 id="2-流程控制之switch"><a href="#2-流程控制之switch" class="headerlink" title="2 流程控制之switch"></a>2 流程控制之switch</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch var1 &#123;</span><br><span class="line">    case val1:</span><br><span class="line">        ...</span><br><span class="line">    case val2:</span><br><span class="line">        ...</span><br><span class="line">    default:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** switch语句</span></span><br><span class="line"><span class="comment">  @author 赖柄沣 bingfengdev@aliyun.com</span></span><br><span class="line"><span class="comment">  @date 2020-09-29 00:00:39</span></span><br><span class="line"><span class="comment">  @version 1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   switchTest(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchTest</span><span class="params">(a <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">   <span class="keyword">switch</span> a &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      fmt.Println(<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      fmt.Println(<span class="number">2</span>)</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">      fmt.Println(a)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong> ：</p><ol><li>switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上直下逐一匹配，直到匹配对为止。</li><li>switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加break</li></ol><h3 id="type-switch"><a href="#type-switch" class="headerlink" title="type switch"></a>type switch</h3><p>switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">switch x.(type)&#123;</span><br><span class="line">    case type:</span><br><span class="line">       statement(s);      </span><br><span class="line">    case type:</span><br><span class="line">       statement(s); </span><br><span class="line">    /* 你可以定义任意个数的case */</span><br><span class="line">    default: /* 可选 */</span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** type switch</span></span><br><span class="line"><span class="comment">  @author 赖柄沣 bingfengdev@aliyun.com</span></span><br><span class="line"><span class="comment">  @date 2020-09-29 00:00:39</span></span><br><span class="line"><span class="comment">  @version 1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   switchTest(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchTest</span><span class="params">( a <span class="keyword">interface</span>&#123;&#125;  )</span></span>  &#123;</span><br><span class="line">   <span class="keyword">switch</span> a.(<span class="keyword">type</span>) &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">      fmt.Println(<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">case</span> <span class="keyword">float32</span>:</span><br><span class="line">      fmt.Println(<span class="number">2</span>)</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;未知的类型&quot;</span>)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-流程控制之-for循环"><a href="#3-流程控制之-for循环" class="headerlink" title="3 流程控制之 for循环"></a>3 流程控制之 for循环</h2><h3 id="写法一"><a href="#写法一" class="headerlink" title="写法一"></a>写法一</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for init; condition; post &#123; &#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> </p><ul><li>init： 一般为赋值表达式，给控制变量赋初值；</li><li>condition： 关系表达式或逻辑表达式，循环控制条件；</li><li>post： 一般为赋值表达式，给控制变量增量或减量。</li></ul><p><strong>实例</strong>  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**for 循环演示</span></span><br><span class="line"><span class="comment">  @author 赖柄沣 bingfengdev@aliyun.com</span></span><br><span class="line"><span class="comment">  @date 2020-09-30 11:30:57</span></span><br><span class="line"><span class="comment">  @version 1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   forDemo(<span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forDemo</span><span class="params">(y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; y; x++ &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Hello World&quot;</span>, x)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Hello World 0</span><br><span class="line">Hello World 1</span><br><span class="line">Hello World 2</span><br><span class="line">Hello World 3</span><br><span class="line">Hello World 4</span><br><span class="line">Hello World 5</span><br><span class="line">Hello World 6</span><br><span class="line">Hello World 7</span><br><span class="line">Hello World 8</span><br><span class="line">Hello World 9</span><br></pre></td></tr></table></figure><h3 id="写法二"><a href="#写法二" class="headerlink" title="写法二"></a>写法二</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for condition &#123; &#125;</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**for 循环演示</span></span><br><span class="line"><span class="comment">  @author 赖柄沣 bingfengdev@aliyun.com</span></span><br><span class="line"><span class="comment">  @date 2020-09-30 11:30:57</span></span><br><span class="line"><span class="comment">  @version 1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   forDemo1()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">   y := <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> ; y &lt; <span class="number">10</span>; y++ &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Ferrayman&quot;</span>,y)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Ferrayman 0</span><br><span class="line">Ferrayman 1</span><br><span class="line">Ferrayman 2</span><br><span class="line">Ferrayman 3</span><br><span class="line">Ferrayman 4</span><br><span class="line">Ferrayman 5</span><br><span class="line">Ferrayman 6</span><br><span class="line">Ferrayman 7</span><br><span class="line">Ferrayman 8</span><br><span class="line">Ferrayman 9</span><br></pre></td></tr></table></figure><h3 id="写法三"><a href="#写法三" class="headerlink" title="写法三"></a>写法三</h3><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**for 循环演示</span></span><br><span class="line"><span class="comment">  @author 赖柄沣 bingfengdev@aliyun.com</span></span><br><span class="line"><span class="comment">  @date 2020-09-30 11:30:57</span></span><br><span class="line"><span class="comment">  @version 1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   forDemo2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">   x := <span class="number">10</span></span><br><span class="line">   <span class="keyword">for</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Ferrayman&quot;</span>, x)</span><br><span class="line">      x--</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Ferrayman 10</span><br><span class="line">Ferrayman 9</span><br><span class="line">Ferrayman 8</span><br><span class="line">Ferrayman 7</span><br><span class="line">Ferrayman 6</span><br><span class="line">Ferrayman 5</span><br><span class="line">Ferrayman 4</span><br><span class="line">Ferrayman 3</span><br><span class="line">Ferrayman 2</span><br><span class="line">Ferrayman 1</span><br></pre></td></tr></table></figure><h2 id="4-break跳出循环"><a href="#4-break跳出循环" class="headerlink" title="4 break跳出循环"></a>4 break跳出循环</h2><p><code>break</code>语句可以结束<code>for</code>、<code>switch</code>和<code>select</code>的代码块。</p><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**break关键字的使用</span></span><br><span class="line"><span class="comment">  @author 赖柄沣 bingfengdev@aliyun.com</span></span><br><span class="line"><span class="comment">  @date 2020-09-30 22:45:55</span></span><br><span class="line"><span class="comment">  @version 1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">5</span>; j &gt; <span class="number">0</span>; j-- &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Ferrayman&quot;</span>,i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Ferrayman 0</span><br><span class="line">Ferrayman 1</span><br><span class="line">Ferrayman 2</span><br><span class="line">Ferrayman 0</span><br><span class="line">Ferrayman 1</span><br><span class="line">Ferrayman 2</span><br><span class="line">Ferrayman 0</span><br><span class="line">Ferrayman 1</span><br><span class="line">Ferrayman 2</span><br><span class="line">Ferrayman 0</span><br><span class="line">Ferrayman 1</span><br><span class="line">Ferrayman 2</span><br><span class="line">Ferrayman 0</span><br><span class="line">Ferrayman 1</span><br><span class="line">Ferrayman 2</span><br></pre></td></tr></table></figure><p><code>break</code>语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的<code>for</code>、<code>switch</code>和 <code>select</code>的代码块上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**break关键字的使用</span></span><br><span class="line"><span class="comment">  @author 赖柄沣 bingfengdev@aliyun.com</span></span><br><span class="line"><span class="comment">  @date 2020-09-30 22:45:55</span></span><br><span class="line"><span class="comment">  @version 1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   Tag:</span><br><span class="line">      <span class="keyword">for</span> j := <span class="number">10</span>; j &gt; <span class="number">0</span>; j-- &#123;</span><br><span class="line">         <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line">               <span class="keyword">break</span> Tag</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Ferrayman&quot;</span>,i)</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ferrayman 0</span><br><span class="line">Ferrayman 1</span><br><span class="line">Ferrayman 2</span><br><span class="line">Ferrayman 3</span><br><span class="line">Ferrayman 4</span><br></pre></td></tr></table></figure><h2 id="5-continuce跳过本次循环，继续下一次循环"><a href="#5-continuce跳过本次循环，继续下一次循环" class="headerlink" title="5 continuce跳过本次循环，继续下一次循环"></a>5 continuce跳过本次循环，继续下一次循环</h2><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**continue关键字的使用</span></span><br><span class="line"><span class="comment">  @author 赖柄沣 bingfengdev@aliyun.com</span></span><br><span class="line"><span class="comment">  @date 2020-09-30 22:45:55</span></span><br><span class="line"><span class="comment">  @version 1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      <span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Ferrayman&quot;</span>,i)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Ferryman 0</span><br><span class="line">Ferryman 1</span><br><span class="line">Ferryman 2</span><br><span class="line">Ferryman 3</span><br><span class="line">Ferryman 4</span><br><span class="line">Ferryman 6</span><br><span class="line">Ferryman 7</span><br><span class="line">Ferryman 8</span><br><span class="line">Ferryman 9</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>continue仅限在for循环当中使用</p><h2 id="6-goto关键字"><a href="#6-goto关键字" class="headerlink" title="6 goto关键字"></a>6 goto关键字</h2><p>Go 语言的 goto 语句可以无条件地转移到过程中指定的行。</p><p>不建议使用goto关键字。会让程序变得难以理解。</p><p><strong>实例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">/**goto关键字的使用</span><br><span class="line">  @author 赖柄沣 bingfengdev@aliyun.com</span><br><span class="line">  @date 2020-09-30 22:45:55</span><br><span class="line">  @version 1.0</span><br><span class="line">   */</span><br><span class="line">func main() &#123;</span><br><span class="line">Tag1:</span><br><span class="line">fmt.Println(&quot;haha,我又来了&quot;)</span><br><span class="line">for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">if i == 3 &#123;</span><br><span class="line">goto Tag</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;Ferrayman&quot;,i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Tag:</span><br><span class="line">fmt.Println(&quot;hehe，我出来了&quot;)</span><br><span class="line">goto Tag1</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hehe，我出来了</span><br><span class="line">haha,我又来了</span><br><span class="line">Ferryman 0</span><br><span class="line">Ferryman 1</span><br><span class="line">Ferryman 2</span><br><span class="line"></span><br><span class="line">死循环。。。</span><br><span class="line">而且第一次打印在程序的23行</span><br></pre></td></tr></table></figure><p>（每次执行标签tag和tag1的执行顺序不太一样，个人感觉这应该和go语言对并行编程的设计有关）</p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言入门之数组与切片</title>
      <link href="/2021/08/15/golang/04_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E6%95%B0%E7%BB%84/"/>
      <url>/2021/08/15/golang/04_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var name [SIZE] type</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list [<span class="number">10</span>] <span class="keyword">int</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li>数组长度必须是一个常量值</li><li>数组长度是数组类型的一部分，也就是说下面a，b两个数组是不同类型的</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>] <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b [<span class="number">6</span>] <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不能这样做，a、b是不同类型的数组</span></span><br><span class="line">a = b</span><br></pre></td></tr></table></figure><h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><span id="more"></span><h4 id="方式一-指定数组长度初始化"><a href="#方式一-指定数组长度初始化" class="headerlink" title="方式一  指定数组长度初始化"></a>方式一  指定数组长度初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list1 = [<span class="number">5</span>] <span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="方式二-推断长度初始化"><a href="#方式二-推断长度初始化" class="headerlink" title="方式二 推断长度初始化"></a>方式二 推断长度初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list1 = [...] <span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">list1 := [...] <span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="多维数组的声明与初始化"><a href="#多维数组的声明与初始化" class="headerlink" title="多维数组的声明与初始化"></a>多维数组的声明与初始化</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">2</span>][<span class="number">2</span>] <span class="keyword">int</span> &#123;</span><br><span class="line">   &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,</span><br><span class="line">   &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [...][<span class="number">2</span>] <span class="keyword">int</span> &#123;</span><br><span class="line">   &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,</span><br><span class="line">   &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ol><li>多维数组<strong>只有第一层</strong>可以使用<code>...</code>来让编译器推导数组长度。</li></ol><h3 id="数组的访问"><a href="#数组的访问" class="headerlink" title="数组的访问"></a>数组的访问</h3><p>与其他语言一样，数组可以通过下标来访问，例如<code>array[index]</code></p><h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><p>在go语言中，数组有两种遍历方式，具体请看下面的demo</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**遍历数组</span></span><br><span class="line"><span class="comment">  @author 赖柄沣 bingfengdev@aliyun.com</span></span><br><span class="line"><span class="comment">  @date 2020-10-01 10:57:25</span></span><br><span class="line"><span class="comment">  @version 1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> list =   [...] <span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历方式一</span></span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; <span class="built_in">len</span>(list); i++&#123;</span><br><span class="line">      fmt.Print(list[i])</span><br><span class="line">   &#125;</span><br><span class="line">fmt.Println()</span><br><span class="line"><span class="comment">// 遍历方式二</span></span><br><span class="line">   <span class="keyword">for</span> index := <span class="keyword">range</span> list &#123;</span><br><span class="line">      fmt.Print(list[index])</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12246</span><br><span class="line">12246</span><br></pre></td></tr></table></figure><h3 id="数组是值类型"><a href="#数组是值类型" class="headerlink" title="数组是值类型"></a>数组是值类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**数组是值类型证明</span></span><br><span class="line"><span class="comment">  @author 赖柄沣 bingfengdev@aliyun.com</span></span><br><span class="line"><span class="comment">  @date 2020-10-01 10:57:25</span></span><br><span class="line"><span class="comment">  @version 1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> list =   [...] <span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>&#125;</span><br><span class="line">   <span class="keyword">var</span> list2 = list</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   改变list2的值，如果数组是引用类型，那么list2和list指向同一个地址</span></span><br><span class="line"><span class="comment">   如果list2发生改变，则list也会发生改变</span></span><br><span class="line"><span class="comment">   否则，数组是值类型</span></span><br><span class="line"><span class="comment">   赋值语句会将数组值拷贝一份给副本，则改变副本的值对原数组不会产生影响</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">for</span> index := <span class="keyword">range</span> list2&#123;</span><br><span class="line">      list2[index] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Print(<span class="string">&quot;原数组&quot;</span>,list)</span><br><span class="line">   fmt.Println()</span><br><span class="line">   fmt.Print(<span class="string">&quot;副本&quot;</span>,list2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原数组[1 2 2 4 6]</span><br><span class="line">副本[1 1 1 1 1]</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的。</li><li><code>[n]*T</code>表示指针数组，<code>*[n]T</code>表示数组指针 。</li></ol><h2 id="切片类型"><a href="#切片类型" class="headerlink" title="切片类型"></a>切片类型</h2><h3 id="切片的定义"><a href="#切片的定义" class="headerlink" title="切片的定义"></a>切片的定义</h3><p>Go语言的切片（slice）切片是一个拥有相同类型元素的可变长度的序列，类似于Java的list。我们知道，数组的大小是一个确定值，因此，在某些需要动态地扩展容器大小的地方，数组将变得不太适用。而切片在数组的基础上做了一层封装，以便支持需要动态扩容的场景。</p><p>Go语言中切片的内部结构包含底层数组的地址、切片的大小和切片的容量三个部分。</p><h3 id="切片的声明"><a href="#切片的声明" class="headerlink" title="切片的声明"></a>切片的声明</h3><h4 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个int类型的切片</span></span><br><span class="line"><span class="keyword">var</span> i  [] <span class="keyword">int</span></span><br></pre></td></tr></table></figure><h4 id="方式二-从数组中获取切片（初始化操作）"><a href="#方式二-从数组中获取切片（初始化操作）" class="headerlink" title="方式二 从数组中获取切片（初始化操作）"></a>方式二 从数组中获取切片（初始化操作）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**由数组产生切片</span></span><br><span class="line"><span class="comment">  @author 赖柄沣 bingfengdev@aliyun.com</span></span><br><span class="line"><span class="comment">  @date 2020-10-01 23:18:21</span></span><br><span class="line"><span class="comment">  @version 1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [...] <span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;</span><br><span class="line">    <span class="comment">//注意，这里的切片截取是[)即左包含，而右不包含的</span></span><br><span class="line">i := a[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> index := <span class="keyword">range</span> i&#123;</span><br><span class="line">fmt.Print(i[index])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1234</span><br></pre></td></tr></table></figure><h4 id="方式三-通过make构造切片"><a href="#方式三-通过make构造切片" class="headerlink" title="方式三 通过make构造切片"></a>方式三 通过make构造切片</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// capacity代表切片容量，这是一个可选参数</span></span><br><span class="line">slice = <span class="built_in">make</span>([]T, length, capacity)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>： </p><ol><li>切片在未初始化之前是一个空切片(nil)</li><li>要检查切片是否为空，请始终使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断。</li><li>切片之间不能直接比较。切片唯一合法的比较操作是和<code>nil</code>比较。 一个<code>nil</code>值的切片并没有底层数组，一个<code>nil</code>值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是<code>nil</code></li></ol><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/**切片比较演示</span></span><br><span class="line"><span class="comment">  @author 赖柄沣 bingfengdev@aliyun.com</span></span><br><span class="line"><span class="comment">  @date 2020-10-02 09:27:38</span></span><br><span class="line"><span class="comment">  @version 1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a  [] <span class="keyword">int</span></span><br><span class="line">    b := [] <span class="keyword">int</span>&#123;&#125; <span class="comment">//或者 b := make([]int, 0)</span></span><br><span class="line">    <span class="built_in">println</span>(a==<span class="literal">nil</span>)</span><br><span class="line">    <span class="built_in">println</span>(b==<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h3 id="切片表达式"><a href="#切片表达式" class="headerlink" title="切片表达式"></a>切片表达式</h3><p>上一小节当中的从数组获取切片，也是切片表达式的一种，下面介绍其他几种写法。</p><h4 id="省略开始位置"><a href="#省略开始位置" class="headerlink" title="省略开始位置"></a>省略开始位置</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个数组a下面的例子中继续沿用</span></span><br><span class="line">a := [...] <span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;</span><br><span class="line">i := a[:<span class="number">4</span>]</span><br></pre></td></tr></table></figure><h4 id="省略结束位置"><a href="#省略结束位置" class="headerlink" title="省略结束位置"></a>省略结束位置</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i := a[<span class="number">4</span>:]</span><br></pre></td></tr></table></figure><h4 id="开始、结束都省略"><a href="#开始、结束都省略" class="headerlink" title="开始、结束都省略"></a>开始、结束都省略</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i := a[:]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong> 切片表达式也可以用来操作切片，即上面的数组a也可以是一个切片。</p><h3 id="len-和-cap-函数"><a href="#len-和-cap-函数" class="headerlink" title="len() 和 cap() 函数"></a>len() 和 cap() 函数</h3><p>切片是可索引的，并且可以由 len() 方法获取长度。</p><p>切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。</p><p>请看下方的demo</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/**len()和cap()函数演示</span></span><br><span class="line"><span class="comment">  @author 赖柄沣 bingfengdev@aliyun.com</span></span><br><span class="line"><span class="comment">  @date 2020-10-01 23:18:21</span></span><br><span class="line"><span class="comment">  @version 1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := [...] <span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;</span><br><span class="line">   i := a[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取切片长度并打印</span></span><br><span class="line">   <span class="built_in">println</span>(<span class="built_in">len</span>(i))</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取切片容量并打印</span></span><br><span class="line">   <span class="built_in">println</span>(<span class="built_in">cap</span>(i))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>看到这里，大家或许会对切片容量和长度这两个值感到疑惑。上文咱讲切片的定义时曾说到，切片是对数组的封装，内部结构包含底层数组的地址、切片的大小和切片的容量三个部分。</p><p>切片的长度等于切片结束下标值减去切片开始下标值：</p><p>length = endIndex-startIndex</p><p>切片容量capacity等于底层数组长度减去开始下标值</p><p>capacity = len(array) - startIndex</p><p>所以上面的例子中的切片长度和容量分别是4和8。而底层数组的地址指向的就是切片开始下标对应值所在的内存地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**切片地层数组地址演示</span></span><br><span class="line"><span class="comment">  @author 赖柄沣 bingfengdev@aliyun.com</span></span><br><span class="line"><span class="comment">  @date 2020-10-02 09:27:38</span></span><br><span class="line"><span class="comment">  @version 1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := [...] <span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;</span><br><span class="line">   i := a[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println</span>(&amp;i[<span class="number">0</span>])</span><br><span class="line">   <span class="built_in">println</span>(&amp;a[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><p><img src="04_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8_%E6%95%B0%E7%BB%84.assets/1601602182292.png" alt="60160218229"></p><p>这也再一次证明了切片是引用类型。</p><h3 id="切片的直接赋值和copy-函数"><a href="#切片的直接赋值和copy-函数" class="headerlink" title="切片的直接赋值和copy()函数"></a>切片的直接赋值和copy()函数</h3><h4 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/**切片的赋值</span></span><br><span class="line"><span class="comment">  @author 赖柄沣 bingfengdev@aliyun.com</span></span><br><span class="line"><span class="comment">  @date 2020-10-02 09:27:38</span></span><br><span class="line"><span class="comment">  @version 1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := [...] <span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;</span><br><span class="line">   i := a[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">   <span class="comment">//将i直接赋值给j，i、j将共用一个底层数组a</span></span><br><span class="line">   j := i</span><br><span class="line">   <span class="built_in">println</span>(&amp;i)</span><br><span class="line">   <span class="built_in">println</span>(&amp;j)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ol><li>对切片i的操作将影响到切片j</li></ol><p><strong>举个例子</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/**切片的赋值</span></span><br><span class="line"><span class="comment">  @author 赖柄沣 bingfengdev@aliyun.com</span></span><br><span class="line"><span class="comment">  @date 2020-10-02 09:27:38</span></span><br><span class="line"><span class="comment">  @version 1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := [...] <span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;</span><br><span class="line">   i := a[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">   <span class="comment">//将i直接赋值给j，i、j将共用一个底层数组a</span></span><br><span class="line">   j := i</span><br><span class="line"></span><br><span class="line">   i[<span class="number">0</span>] = <span class="number">6</span></span><br><span class="line">   <span class="built_in">println</span>(j[<span class="number">0</span>])</span><br><span class="line">   <span class="built_in">println</span>(a[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>这不难理解，因为i、j都是一个保持对数组a的引用，因此，改变i的值实际上改变的是数组a的值，所以j也会受到影响。</p><h4 id="copy-函数"><a href="#copy-函数" class="headerlink" title="copy()函数"></a>copy()函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/**copy（）函数的使用</span></span><br><span class="line"><span class="comment">  @author 赖柄沣 bingfengdev@aliyun.com</span></span><br><span class="line"><span class="comment">  @date 2020-10-02 09:27:38</span></span><br><span class="line"><span class="comment">  @version 1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := [...] <span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;</span><br><span class="line">   i := a[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">   j := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>(i),<span class="built_in">cap</span>(i))</span><br><span class="line">   <span class="built_in">copy</span>(j,i)</span><br><span class="line">   i[<span class="number">0</span>] = <span class="number">6</span></span><br><span class="line">   <span class="built_in">println</span>(j[<span class="number">0</span>])</span><br><span class="line">   <span class="built_in">println</span>(a[<span class="number">2</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>显然，这里的i、j所对应的底层数组不是同一个。</p><h3 id="append-函数的使用"><a href="#append-函数的使用" class="headerlink" title="append()函数的使用"></a>append()函数的使用</h3><h4 id="为切片添加新元素"><a href="#为切片添加新元素" class="headerlink" title="为切片添加新元素"></a>为切片添加新元素</h4><p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（切片参数后面加…）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**append()函数的使用</span></span><br><span class="line"><span class="comment">  @author 赖柄沣 bingfengdev@aliyun.com</span></span><br><span class="line"><span class="comment">  @date 2020-10-02 09:59:36</span></span><br><span class="line"><span class="comment">  @version 1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//声明一个int类型的切片</span></span><br><span class="line"><span class="keyword">var</span> a [] <span class="keyword">int</span></span><br><span class="line">b := [] <span class="keyword">int</span>&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line"><span class="comment">//向切片a中追加元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">//将切片a的元素追加切片b</span></span><br><span class="line">b  = <span class="built_in">append</span>(b,a...)</span><br><span class="line"></span><br><span class="line">fmt.Println(a)</span><br><span class="line">fmt.Println(b)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1 2 4]</span><br><span class="line">[5 6 7 1 2 4]</span><br></pre></td></tr></table></figure><h4 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h4><p>在go语言当中，目前并没有为切片移除元素的函数，因此我们使用append()来做移除操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**切片移除元素</span></span><br><span class="line"><span class="comment">  @author 赖柄沣 bingfengdev@aliyun.com</span></span><br><span class="line"><span class="comment">  @date 2020-10-02 10:23:51</span></span><br><span class="line"><span class="comment">  @version 1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := [] <span class="keyword">int</span>&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//删除索引为1的元素</span></span><br><span class="line">   a = <span class="built_in">append</span>(a[:<span class="number">1</span>],a[<span class="number">2</span>:]...)</span><br><span class="line"></span><br><span class="line">   fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[5 7]</span><br></pre></td></tr></table></figure><p><strong>提示</strong> </p><p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在<code>append()</code>函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p><h3 id="切片的排序"><a href="#切片的排序" class="headerlink" title="切片的排序"></a>切片的排序</h3><h4 id="对int类型的元素排序"><a href="#对int类型的元素排序" class="headerlink" title="对int类型的元素排序"></a>对int类型的元素排序</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**切片排序</span></span><br><span class="line"><span class="comment">  @author 赖柄沣 bingfengdev@aliyun.com</span></span><br><span class="line"><span class="comment">  @date 2020-10-02 10:23:51</span></span><br><span class="line"><span class="comment">  @version 1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := [] <span class="keyword">int</span>&#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对int类型的元素进行排序</span></span><br><span class="line">   sort.Ints(a)</span><br><span class="line"></span><br><span class="line">   fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[6 7 9]</span><br></pre></td></tr></table></figure><h4 id="对string类型的元素排序"><a href="#对string类型的元素排序" class="headerlink" title="对string类型的元素排序"></a>对string类型的元素排序</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**切片排序</span></span><br><span class="line"><span class="comment">  @author 赖柄沣 bingfengdev@aliyun.com</span></span><br><span class="line"><span class="comment">  @date 2020-10-02 10:23:51</span></span><br><span class="line"><span class="comment">  @version 1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s := [] <span class="keyword">string</span> &#123;<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;wangwu&quot;</span>,<span class="string">&quot;lisi&quot;</span>,<span class="string">&quot;zhaoliu&quot;</span>,<span class="string">&quot;suiqi&quot;</span>,<span class="string">&quot;songjiu&quot;</span>&#125;</span><br><span class="line">   sort.Strings(s)</span><br><span class="line">   fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lisi songjiu suiqi wangwu zhangsan zhaoliu]</span><br></pre></td></tr></table></figure><h3 id="查找元素位置"><a href="#查找元素位置" class="headerlink" title="查找元素位置"></a>查找元素位置</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**切片查找元素位置</span></span><br><span class="line"><span class="comment">  @author 赖柄沣 bingfengdev@aliyun.com</span></span><br><span class="line"><span class="comment">  @date 2020-10-02 10:23:51</span></span><br><span class="line"><span class="comment">  @version 1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := [] <span class="keyword">string</span> &#123;<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;赵六&quot;</span>,<span class="string">&quot;孙七&quot;</span>,<span class="string">&quot;宋九&quot;</span>&#125;</span><br><span class="line">sort.Strings(s)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">a := sort.SearchStrings(s,<span class="string">&quot;李四&quot;</span>)</span><br><span class="line">fmt.Println(s[a])</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[张三 王五 李四 赵六 孙七 宋九]</span><br><span class="line">王五</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ol><li>查找之前需要先对切片进行排序</li></ol><h3 id="切片的扩容策略"><a href="#切片的扩容策略" class="headerlink" title="切片的扩容策略"></a>切片的扩容策略</h3><p>以下源码摘自<code>/src/runtime/slice.go</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func growslice(et *_type, old slice, cap int) slice &#123;</span><br><span class="line">   //省略了不影响理解的部分代码</span><br><span class="line"></span><br><span class="line">   newcap := old.cap</span><br><span class="line">   doublecap := newcap + newcap</span><br><span class="line">   if cap &gt; doublecap &#123;</span><br><span class="line">      newcap = cap</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      if old.len &lt; 1024 &#123;</span><br><span class="line">         newcap = doublecap</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         // Check 0 &lt; newcap to detect overflow</span><br><span class="line">         // and prevent an infinite loop.</span><br><span class="line">         for 0 &lt; newcap &amp;&amp; newcap &lt; cap &#123;</span><br><span class="line">            newcap += newcap / 4</span><br><span class="line">         &#125;</span><br><span class="line">         // Set newcap to the requested cap when</span><br><span class="line">         // the newcap calculation overflowed.</span><br><span class="line">         if newcap &lt;= 0 &#123;</span><br><span class="line">            newcap = cap</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  //省略了不影响理解的部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：</p><ol><li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）；</li><li>否则，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap）；</li><li>否则，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）；</li><li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</li></ol><p>注意：</p><p>切片扩容还会根据切片中元素的类型不同而做不同的处理，比如<code>int</code>和<code>string</code>类型的处理方式就不一样。</p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言入门（下）</title>
      <link href="/2021/08/15/golang/02_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2021/08/15/golang/02_go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="Go常用命令总结"><a href="#Go常用命令总结" class="headerlink" title="Go常用命令总结"></a>Go常用命令总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//查看当前机子上的go sdk版本</span><br><span class="line">go version </span><br><span class="line"></span><br><span class="line">//执行go程序</span><br><span class="line">go run filename.go </span><br><span class="line"></span><br><span class="line">//本地安装</span><br><span class="line">//它先编译源代码得到可执行文件，然后将可执行文件移动到GOPATH的bin目录下</span><br><span class="line">//不常用</span><br><span class="line">go install</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//编译当前目录下的go程序</span><br><span class="line">go build</span><br><span class="line"></span><br><span class="line">//编译指定模块的go程序，该模块必须在go工作目录下的src目录下</span><br><span class="line">go build helloWorld</span><br><span class="line"></span><br><span class="line">//指定可执行文件名称编译</span><br><span class="line">go -o filename build</span><br><span class="line"></span><br><span class="line">//跨平台编译</span><br><span class="line">//windows下编译linux可执行文件</span><br><span class="line">SET CGO_ENABLED=0  // 禁用CGO</span><br><span class="line">SET GOOS=linux  // 目标平台是linux</span><br><span class="line">SET GOARCH=amd64  // 目标处理器架构是amd64</span><br><span class="line">go build</span><br><span class="line"></span><br><span class="line">//Mac平台编译Linux可执行文件</span><br><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="Go语言结构"><a href="#Go语言结构" class="headerlink" title="Go语言结构"></a>Go语言结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">入口程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//打印hello world</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Hello World !&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 语言的基础组成有以下几个部分：</p><ul><li>包声明</li><li>引入包</li><li>函数</li><li>变量</li><li>语句 &amp; 表达式</li><li>注释</li></ul><h2 id="Go语言基础语法"><a href="#Go语言基础语法" class="headerlink" title="Go语言基础语法"></a>Go语言基础语法</h2><h3 id="行分隔符"><a href="#行分隔符" class="headerlink" title="行分隔符"></a>行分隔符</h3><p>以换行的方式分割语句，如果两条语句在同一行，则需要用；分割，但不建议这样做。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">段落注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>由字母数字下划线组成，但必须是字母或下划线开头，这与其他大多数语言一样。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>下面列举了 Go 代码中会使用到的 25 个关键字或保留字：</p><table><thead><tr><th>break</th><th>default</th><th>func</th><th>interface</th><th>select</th></tr></thead><tbody><tr><td>case</td><td>defer</td><td>go</td><td>map</td><td>struct</td></tr><tr><td>chan</td><td>else</td><td>goto</td><td>package</td><td>switch</td></tr><tr><td>const</td><td>fallthrough</td><td>if</td><td>range</td><td>type</td></tr><tr><td>continue</td><td>for</td><td>import</td><td>return</td><td>var</td></tr></tbody></table><p>除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符：</p><table><thead><tr><th>append</th><th>bool</th><th>byte</th><th>cap</th><th>close</th><th>complex</th><th>complex64</th><th>complex128</th><th>uint16</th></tr></thead><tbody><tr><td>copy</td><td>false</td><td>float32</td><td>float64</td><td>imag</td><td>int</td><td>int8</td><td>int16</td><td>uint32</td></tr><tr><td>int32</td><td>int64</td><td>iota</td><td>len</td><td>make</td><td>new</td><td>nil</td><td>panic</td><td>uint64</td></tr><tr><td>print</td><td>println</td><td>real</td><td>recover</td><td>string</td><td>true</td><td>uint</td><td>uint8</td><td>uintptr</td></tr></tbody></table><h2 id="Go语言数据类型"><a href="#Go语言数据类型" class="headerlink" title="Go语言数据类型"></a>Go语言数据类型</h2><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>布尔型的值只可以是常量 true 或者 false。一个简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flag <span class="keyword">bool</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><p>包括int、float。Go 语言支持整型和浮点型数字，并且原生支持复数，其中位的运算采用补码。</p><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64</p><p>其中，<code>uint8</code>就是我们熟知的<code>byte</code>型，<code>int16</code>对应C语言中的<code>short</code>型，<code>int64</code>对应C语言中的<code>long</code>型。</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>uint8</td><td>无符号 8位整型 (0 到 255)</td></tr><tr><td>uint16</td><td>无符号 16位整型 (0 到 65535)</td></tr><tr><td>uint32</td><td>无符号 32位整型 (0 到 4294967295)</td></tr><tr><td>uint64</td><td>无符号 64位整型 (0 到 18446744073709551615)</td></tr><tr><td>int8</td><td>有符号 8位整型 (-128 到 127)</td></tr><tr><td>int16</td><td>有符号 16位整型 (-32768 到 32767)</td></tr><tr><td>int32</td><td>有符号 32位整型 (-2147483648 到 2147483647)</td></tr><tr><td>int64</td><td>有符号 64位整型 (-9223372036854775808 到 9223372036854775807)</td></tr></tbody></table><h4 id="特殊整型"><a href="#特殊整型" class="headerlink" title="特殊整型"></a>特殊整型</h4><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>uint</td><td>32位操作系统上就是<code>uint32</code>，64位操作系统上就是<code>uint64</code></td></tr><tr><td>int</td><td>32位操作系统上就是<code>int32</code>，64位操作系统上就是<code>int64</code></td></tr><tr><td>uintptr</td><td>无符号整型，用于存放一个指针</td></tr></tbody></table><p><strong>注意：</strong> 在使用<code>int</code>和 <code>uint</code>类型时，不能假定它是32位或64位的整型，而是考虑<code>int</code>和<code>uint</code>可能在不同平台上的差异。</p><p>获取对象的长度的内建<code>len()</code>函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用<code>int</code>来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用<code>int</code>和 <code>uint</code>。</p><h4 id="数字字面量语法（Number-literals-syntax）"><a href="#数字字面量语法（Number-literals-syntax）" class="headerlink" title="数字字面量语法（Number literals syntax）"></a>数字字面量语法（Number literals syntax）</h4><p>Go1.13版本之后引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如：</p><p><code>v := 0b00101101</code>， 代表二进制的 101101，相当于十进制的 45。 <code>v := 0o377</code>，代表八进制的 377，相当于十进制的 255。 <code>v := 0x1p-2</code>，代表十六进制的 1 除以 2²，也就是 0.25。</p><p>而且还允许我们用 <code>_</code> 来分隔数字，比如说： <code>v := 123_456</code> 表示 v 的值等于 123456。</p><p>我们可以借助fmt函数来将一个整数以不同进制形式展示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d \n&quot;</span>, a)  <span class="comment">// 10</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%b \n&quot;</span>, a)  <span class="comment">// 1010  占位符%b表示二进制</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 八进制  以0开头</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">077</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%o \n&quot;</span>, b)  <span class="comment">// 77</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 十六进制  以0x开头</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int</span> = <span class="number">0xff</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%x \n&quot;</span>, c)  <span class="comment">// ff</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%X \n&quot;</span>, c)  <span class="comment">// FF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code>。这两种浮点型数据格式遵循<code>IEEE 754</code>标准： <code>float32</code> 的浮点数的最大范围约为 <code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。 <code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code>。</p><p>打印浮点数时，可以使用<code>fmt</code>包配合动词<code>%f</code>，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%f\n&quot;</span>, math.Pi)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>, math.Pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复数类型"><a href="#复数类型" class="headerlink" title="复数类型"></a>复数类型</h4><p>包括complex64和complex128</p><p>复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。</p><h3 id="字符串类型string"><a href="#字符串类型string" class="headerlink" title="字符串类型string"></a>字符串类型string</h3><p>Go的字符串是由单个字节连接起来的。Go语言的字符串的字节使用UTF-8编码标识Unicode文本。</p><h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><h5 id="字符串转义"><a href="#字符串转义" class="headerlink" title="字符串转义"></a>字符串转义</h5><p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。</p><table><thead><tr><th>转义符</th><th>含义</th></tr></thead><tbody><tr><td><code>\r</code></td><td>回车符（返回行首）</td></tr><tr><td><code>\n</code></td><td>换行符（直接跳到下一行的同列位置）</td></tr><tr><td><code>\t</code></td><td>制表符</td></tr><tr><td><code>\&#39;</code></td><td>单引号</td></tr><tr><td><code>\&quot;</code></td><td>双引号</td></tr><tr><td><code>\\</code></td><td>反斜杠</td></tr></tbody></table><h5 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">`</span></span><br><span class="line"><span class="string">第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><h5 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h5><table><thead><tr><th>方法</th><th>介绍</th></tr></thead><tbody><tr><td>len(str)</td><td>求长度</td></tr><tr><td>+或fmt.Sprintf</td><td>拼接字符串</td></tr><tr><td>strings.Split</td><td>分割</td></tr><tr><td>strings.contains</td><td>判断是否包含</td></tr><tr><td>strings.HasPrefix,strings.HasSuffix</td><td>前缀/后缀判断</td></tr><tr><td>strings.Index(),strings.LastIndex()</td><td>子串出现的位置</td></tr><tr><td>strings.Join(a[]string, sep string)</td><td>join操作</td></tr></tbody></table><h5 id="字符类型-byte、rune"><a href="#字符类型-byte、rune" class="headerlink" title="字符类型 byte、rune"></a>字符类型 byte、rune</h5><p>Go 语言的字符有以下两种：</p><ol><li><code>uint8</code>类型，或者叫 byte 型，代表了<code>ASCII码</code>的一个字符。</li><li><code>rune</code>类型，代表一个 <code>UTF-8字符</code>。</li></ol><p>当需要处理复合字符比如中文时，则需要用到<code>rune</code>类型。<code>rune</code>类型实际是一个<code>int32</code>。</p><p>Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。</p><p>遍历字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 遍历字符串</span></span><br><span class="line">      s := <span class="string">&quot;hello你好&quot;</span></span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123; <span class="comment">//byte</span></span><br><span class="line">         fmt.Printf(<span class="string">&quot;%v(%c) &quot;</span>, s[i], s[i])</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println()</span><br><span class="line">      <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123; <span class="comment">//rune</span></span><br><span class="line">         fmt.Printf(<span class="string">&quot;%v(%c) &quot;</span>, r, r)</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">104(h) 101(e) 108(l) 108(l) 111(o) 228(ä) 189(½) 160( ) 229(å) 165(¥) 189(½)</span><br><span class="line">104(h) 101(e) 108(l) 108(l) 111(o) 20320(你) 22909(好)</span><br></pre></td></tr></table></figure><p>因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。</p><p>字符串底层是一个byte数组，所以可以和<code>[]byte</code>类型相互转换。字符串是不能修改的 ，字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。</p><h5 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h5><p>要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(表达式)</span><br></pre></td></tr></table></figure><h3 id="派生类型"><a href="#派生类型" class="headerlink" title="派生类型"></a>派生类型</h3><ul><li>指针类型（Pointer）</li><li> 数组类型</li><li>结构化类型(struct)</li><li>联合体类型 (union)</li><li> 函数类型</li><li>切片类型</li><li>接口类型（interface）</li><li>Map 类型</li><li>Channel 类型</li></ul><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><h3 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h3><p>声明变量的一般形式是使用 var 关键字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">type</span></span><br></pre></td></tr></table></figure><p>指定变量类型，声明后若不赋值，则使用默认值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v_name v_type</span><br><span class="line">v_name = value</span><br></pre></td></tr></table></figure><h3 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h3><p>根据值自行判定变量类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v_name = value</span><br></pre></td></tr></table></figure><h3 id="方式3"><a href="#方式3" class="headerlink" title="方式3"></a>方式3</h3><p>省略var, 注意 :=左侧的变量不能是已经声明过的，否则会导致编译错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//短变量声明。只能在函数体使用</span></span><br><span class="line">c := <span class="number">10</span></span><br></pre></td></tr></table></figure><p>另外，go语言变量如果只是声明而不使用，编译也会报错</p><h3 id="多变量声明"><a href="#多变量声明" class="headerlink" title="多变量声明"></a>多变量声明</h3><h4 id="类型相同的多个变量"><a href="#类型相同的多个变量" class="headerlink" title="类型相同的多个变量"></a>类型相同的多个变量</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span></span><br><span class="line">vname1, vname2, vname3 = v1, v2, v3</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动类型推断</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 = v1, v2, v3 </span><br><span class="line"></span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3</span><br></pre></td></tr></table></figure><h3 id="类型不同多个变量"><a href="#类型不同多个变量" class="headerlink" title="类型不同多个变量"></a>类型不同多个变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//既可以声明局部变量，也可以声明全局变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    <span class="keyword">var</span> name1 <span class="keyword">int8</span></span><br><span class="line">    <span class="keyword">var</span> flags <span class="keyword">bool</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种方式目前只能在函数体中使用</span></span><br><span class="line">name1, flag1 := <span class="string">&quot;zhangsan&quot;</span>, <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (<span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">name = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">age  = <span class="number">18</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> flags = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> flags &#123;</span><br><span class="line">fmt.Println(name)</span><br><span class="line">fmt.Println(age)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值</p><p>当使用等号 <code>=</code> 将一个变量的值赋值给另一个变量时，如：<code>j = i</code>，实际上是在内存中将 i 的值进行了拷贝</p><p>你可以通过 &amp;name来获取变量 name的内存地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (<span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> (</span><br><span class="line">      name = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">      age  = <span class="number">18</span></span><br><span class="line">   )</span><br><span class="line">   fmt.Println(name)</span><br><span class="line">   fmt.Println(age)</span><br><span class="line">   fmt.Print(<span class="string">&quot;name变量地址：&quot;</span> )</span><br><span class="line">   fmt.Print(&amp;name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="F:\05_Go语言学习\笔记\02_go语言入门（下）.assets\1601272486793.png" alt="60127248679"></p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。这个内存地址为称之为指针，这个指针实际上也被存在另外的某一个字中。</p><p>当使用赋值语句 r2 = r1 时，只有引用（地址）被复制。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>如果你想要交换两个变量的值，则可以简单地使用 a, b = b, a。</p><p>空白标识符 _ 也被用于抛弃值，如值 5 在：_, b = 5, 7 中被抛弃。</p><p>_ 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//只需要返回部分值 _ 用来接收不需要的值</span></span><br><span class="line">   _, age := people()</span><br><span class="line">   fmt.Println(age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">people</span><span class="params">()</span><span class="params">(<span class="keyword">string</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在同一个作用域里面，不能重复声明同名变量（声明变量相当于申请内存空间给变量）</p><p>_ 可以重复声明使用。</p><h2 id="常量声明"><a href="#常量声明" class="headerlink" title="常量声明"></a>常量声明</h2><h3 id="const声明常量"><a href="#const声明常量" class="headerlink" title="const声明常量"></a>const声明常量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//常量在定义时必须赋值</span><br><span class="line">//它在程序运行期间是不可变的</span><br><span class="line">const identifier [type] = value</span><br></pre></td></tr></table></figure><p>多个相同类型的声明可以简写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const c_name1, c_name2 = value1, value2</span><br></pre></td></tr></table></figure><p>用作枚举：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    Unknown = 0</span><br><span class="line">    Female = 1</span><br><span class="line">    Male = 2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>常量可以用len(), cap(), unsafe.Sizeof()常量计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   name  = <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">   nameLength = <span class="built_in">len</span>(name)</span><br><span class="line">   c = unsafe.Sizeof(nameLength)</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"> fmt.Println(c)</span><br><span class="line"> fmt.Println(nameLength)</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iota-特殊常量（常量计数器、枚举）"><a href="#iota-特殊常量（常量计数器、枚举）" class="headerlink" title="iota 特殊常量（常量计数器、枚举）"></a>iota 特殊常量（常量计数器、枚举）</h3><p>iota，特殊常量，可以认为是一个可以被编译器修改的常量。</p><p>在每一个const关键字出现时，被重置为0，然后再下一个const出现之前，每新增一行声明，iota增加1</p><p>iota 可以被用作枚举值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    a = iota</span><br><span class="line">    b = iota</span><br><span class="line">    c = iota</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    a = iota</span><br><span class="line">    //简写，相当于b = iota</span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   <span class="comment">//a = 0</span></span><br><span class="line">   a = <span class="literal">iota</span></span><br><span class="line">   b</span><br><span class="line">   c</span><br><span class="line">   d = <span class="number">100</span></span><br><span class="line">   <span class="comment">//相当于 e = 100</span></span><br><span class="line">   e</span><br><span class="line">   f</span><br><span class="line">   <span class="comment">//重新开始计数</span></span><br><span class="line">   g = <span class="literal">iota</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   fmt.Println(a)</span><br><span class="line">   fmt.Println(b)</span><br><span class="line">   fmt.Println(c)</span><br><span class="line">   fmt.Println(d)</span><br><span class="line">   fmt.Println(e)</span><br><span class="line">   fmt.Println(f)</span><br><span class="line">   fmt.Println(g)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义数量级 （这里的<code>&lt;&lt;</code>表示左移操作，<code>1&lt;&lt;10</code>表示将1的二进制表示向左移10位，也就是由<code>1</code>变成了<code>10000000000</code>，也就是十进制的1024。同理<code>2&lt;&lt;2</code>表示将2的二进制表示向左移2位，也就是由<code>10</code>变成了<code>1000</code>，也就是十进制的8。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">_  = <span class="literal">iota</span></span><br><span class="line">KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">PB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>多个<code>iota</code>定义在一行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a, b = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span> <span class="comment">//1,2</span></span><br><span class="line">c, d                      <span class="comment">//2,3</span></span><br><span class="line">e, f                      <span class="comment">//3,4</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="Go语言运算符"><a href="#Go语言运算符" class="headerlink" title="Go语言运算符"></a>Go语言运算符</h2><p>Go 语言内置的运算符有：</p><ul><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>赋值运算符</li><li>其他运算符</li></ul><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 相加</span><br><span class="line">- 相减</span><br><span class="line">* 相乘</span><br><span class="line">/ 相除</span><br><span class="line">% 取余</span><br><span class="line">++ 自增</span><br><span class="line">-- 自减</span><br></pre></td></tr></table></figure><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">== 等于</span><br><span class="line">！= 不等于</span><br><span class="line">&gt; 大于</span><br><span class="line">&lt; 小于</span><br><span class="line">&gt;= 大于等于</span><br><span class="line">&lt;= 小于等于</span><br></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp; 逻辑与</span><br><span class="line">|| 逻辑或</span><br><span class="line">！ 逻辑非</span><br></pre></td></tr></table></figure><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>位运算符对整数在内存中的二进制位进行操作。</p><p>下表列出了位运算符 &amp;, |, 和 ^ 的计算：</p><table><thead><tr><th>p</th><th>q</th><th>p &amp; q</th><th>p | q</th><th>p ^ q</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr></tbody></table><p><strong><code>&lt;&lt;</code></strong> 左移运算符”&lt;&lt;”是双目运算符。左移n位就是乘以2的n次方。 其功能把”&lt;&lt;”左边的运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。</p><p>**<code>&gt;&gt;</code>**右移运算符”&gt;&gt;”是双目运算符。右移n位就是除以2的n次方。 其功能是把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数。</p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><h2 id="赋值运算符-1"><a href="#赋值运算符-1" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>下表列出了所有Go语言的赋值运算符。</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>=</td><td>简单的赋值运算符，将一个表达式的值赋给一个左值</td><td>C = A + B 将 A + B 表达式结果赋值给 C</td></tr><tr><td>+=</td><td>相加后再赋值</td><td>C += A 等于 C = C + A</td></tr><tr><td>-=</td><td>相减后再赋值</td><td>C -= A 等于 C = C - A</td></tr><tr><td>*=</td><td>相乘后再赋值</td><td>C *= A 等于 C = C * A</td></tr><tr><td>/=</td><td>相除后再赋值</td><td>C /= A 等于 C = C / A</td></tr><tr><td>%=</td><td>求余后再赋值</td><td>C %= A 等于 C = C % A</td></tr><tr><td>&lt;&lt;=</td><td>左移后赋值</td><td>C &lt;&lt;= 2 等于 C = C &lt;&lt; 2</td></tr><tr><td>&gt;&gt;=</td><td>右移后赋值</td><td>C &gt;&gt;= 2 等于 C = C &gt;&gt; 2</td></tr><tr><td>&amp;=</td><td>按位与后赋值</td><td>C &amp;= 2 等于 C = C &amp; 2</td></tr><tr><td>^=</td><td>按位异或后赋值</td><td>C ^= 2 等于 C = C ^ 2</td></tr><tr><td>|=</td><td>按位或后赋值</td><td>C |= 2 等于 C = C | 2</td></tr></tbody></table><h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><p>下表列出了Go语言的其他运算符。</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;</td><td>返回变量存储地址</td><td>&a; 将给出变量的实际地址。</td></tr><tr><td>*</td><td>指针变量。</td><td>*a; 是一个指针变量</td></tr></tbody></table><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><table><thead><tr><th>优先级</th><th>运算符</th></tr></thead><tbody><tr><td>7</td><td>^ !</td></tr><tr><td>6</td><td>* / % &lt;&gt; &amp; &amp;^</td></tr><tr><td>5</td><td>+ - | ^</td></tr><tr><td>4</td><td>== != &lt; = &gt;</td></tr><tr><td>3</td><td>&lt;-</td></tr><tr><td>2</td><td>&amp;&amp;</td></tr><tr><td>1</td><td>||</td></tr></tbody></table><p>除此之外，你可以用（）将对应表达式的运算符优先级整体提升。</p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang语言 序章</title>
      <link href="/2021/08/15/golang/01_golang%E5%85%A5%E9%97%A8/"/>
      <url>/2021/08/15/golang/01_golang%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是go语言"><a href="#1-什么是go语言" class="headerlink" title="1. 什么是go语言"></a>1. 什么是go语言</h2><p><strong>Go</strong>（又称 <strong>Golang</strong>）是 Google 的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态 、强类型、编译型语言 。Go 语言语法与 C相近，但功能上有：内存安全，GC（垃圾回收），结构形态及 CSP-style 并发计算。</p><p>​                                                        ———–百度百科</p><p>Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。</p><p>Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。</p><p>它是编译型语言。</p><p>它考虑了多核计算机的执行特点。（并行编程）</p><span id="more"></span><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>简单易学习</li><li>开发效率高</li><li>执行效率好（号称21世纪的C语言）</li></ol><p>兼具效率、性能、安全、健壮等特性</p><h2 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h2><ol><li>服务端开发：日志处理、文件系统、监控服务</li><li>容器虚拟化：Docker、k8s、Docker Swarm</li><li>存储：etcd、TiDB、GroupCache</li><li>Web开发：http/net、Gin、Echo</li><li>区块链：以太坊、fabric</li><li>云平台，目前国外很多云平台在采用Go开发，CloudFoundy的部分组建，前VMare的技术总监自己出来搞的apcera云平台。</li></ol><h2 id="成功的案例"><a href="#成功的案例" class="headerlink" title="成功的案例"></a>成功的案例</h2><ul><li>nsq：bitly开源的消息队列系统，性能非常高，目前他们每天处理数十亿条的消息</li><li>docker:基于lxc的一个虚拟打包工具，能够实现PAAS平台的组建。</li><li>packer:用来生成不同平台的镜像文件，例如VM、vbox、AWS等，作者是vagrant的作者</li><li>skynet：分布式调度框架</li><li>Doozer：分布式同步工具，类似ZooKeeper</li><li>Heka：mazila开源的日志处理系统</li><li>cbfs：couchbase开源的分布式文件系统</li><li>tsuru：开源的PAAS平台，和SAE实现的功能一模一样</li><li>groupcache：memcahe作者写的用于Google下载系统的缓存系统</li><li>god：类似redis的缓存系统，但是支持分布式和扩展性</li><li>gor：网络流量抓包和重放工具</li></ul><h2 id="语言环境安装"><a href="#语言环境安装" class="headerlink" title="语言环境安装"></a>语言环境安装</h2><p>在线下载：<a href="https://golang.org/dl/">https://golang.org/dl/</a></p><p>配置go环境变量；</p><p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/1601258721248.png" alt="60125872124"></p><p>cmd输入go version查看版本</p><p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/1601257561739.png" alt="60125756173"></p><h2 id="Go语言的Hello-World"><a href="#Go语言的Hello-World" class="headerlink" title="Go语言的Hello World"></a>Go语言的Hello World</h2><p>创建一个go语言的工作空间</p><p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/1601258608119.png" alt="60125860811"></p><p>新建src、pkg、bin三个目录</p><p>在src目录下新建demo.go文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;Hello World !&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该文件夹打开cmd 执行go demo.go</p><p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/1601259334521.png" alt="60125933452"></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/1601260414015.png" alt="60126041401"></p><p>输入dir查看目录文件</p><p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/1601260535940.png" alt="60126053594"></p><p>会发现多了一个exe可执行文件，文件默认的名称是当前文件夹的名称</p><p>我们可以指定可执行文件名称编译</p><p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/1601260732908.png" alt="60126073290"></p><p>跨平台编译</p><p>默认我们<code>go build</code>的可执行文件都是当前操作系统可执行的文件，如果需要编译其他平台的go可执行文件，需要先指定平台再编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET CGO_ENABLED=0  // 禁用CGO，cgo不支持跨平台</span><br><span class="line">SET GOOS=linux  // 目标平台是linux</span><br><span class="line">SET GOARCH=amd64  // 目标处理器架构是amd64</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/1601261881709.png" alt="60126188170"></p><p>使用sublime打开可以发现是一个二进制文件，拷贝到linux上即可执行</p><p>（在执行之前需要查看文件是否有执行权限，不然需要授权）</p><p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/1601262422038.png" alt="60126242203"></p><h2 id="Go语言项目目录结构"><a href="#Go语言项目目录结构" class="headerlink" title="Go语言项目目录结构"></a>Go语言项目目录结构</h2><p><img src="https://raw.githubusercontent.com/code81192/art-demo/master/art-img/1601259247380.png" alt="60125924738"></p><h2 id="开发工具（IDE）"><a href="#开发工具（IDE）" class="headerlink" title="开发工具（IDE）"></a>开发工具（IDE）</h2><p>免费的VS Code（安装go插件）</p><p>收费的Goland</p><p>vim</p><p>等等</p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fluent mybatis初体验</title>
      <link href="/2021/08/15/java/orm/fluent-mybatis%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2021/08/15/java/orm/fluent-mybatis%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> ibatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/08/13/hello-world/"/>
      <url>/2021/08/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
